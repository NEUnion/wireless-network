diff -u -r -N ns-2.34.original/Makefile.in ns-2.34/Makefile.in
--- ns-2.34.original/Makefile.in	2009-06-15 01:35:44.000000000 +0800
+++ ns-2.34/Makefile.in	2012-08-08 15:11:48.046375000 +0800
@@ -1,610 +1,612 @@
-#  Copyright (c) 1994, 1995, 1996
-# 	The Regents of the University of California.  All rights reserved.
-#
-#  Redistribution and use in source and binary forms, with or without
-#  modification, are permitted provided that: (1) source code distributions
-#  retain the above copyright notice and this paragraph in its entirety, (2)
-#  distributions including binary code include the above copyright notice and
-#  this paragraph in its entirety in the documentation or other materials
-#  provided with the distribution, and (3) all advertising materials mentioning
-#  features or use of this software display the following acknowledgement:
-#  ``This product includes software developed by the University of California,
-#  Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
-#  the University nor the names of its contributors may be used to endorse
-#  or promote products derived from this software without specific prior
-#  written permission.
-#  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
-#  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
-#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
-#
-# @(#) $Header: 2002/10/09 15:34:11
-
-#
-# Various configurable paths (remember to edit Makefile.in, not Makefile)
-#
-
-# Top level hierarchy
-prefix	= @prefix@
-# Pathname of directory to install the binary
-BINDEST	= @prefix@/bin
-# Pathname of directory to install the man page
-MANDEST	= @prefix@/man
-
-BLANK	= # make a blank space.  DO NOT add anything to this line
-
-# The following will be redefined under Windows (see WIN32 lable below)
-CC	= @CC@
-CPP	= @CXX@
-LINK	= $(CPP)
-LINK_SHLIB = @SHLIB_LD@
-MKDEP	= ./conf/mkdep
-TCLSH	= @V_TCLSH@
-TCL2C	= @V_TCL2CPP@
-AR	= ar rc $(BLANK)
-
-RANLIB	= @V_RANLIB@
-INSTALL	= @INSTALL@
-LN	= ln
-TEST	= test
-RM	= rm -f
-MV      = mv
-PERL	= @PERL@
-
-# for diffusion
-#DIFF_INCLUDES = "./diffusion3/main ./diffusion3/lib ./diffusion3/nr ./diffusion3/ns"
-
-CCOPT	= @V_CCOPT@ 
-STATIC	= @V_STATIC@
-#LDFLAGS	= $(STATIC)
-LDFLAGS	= @LDFLAGS@ 
-LDOUT	= -o $(BLANK)
-
-DEFINE	= -DTCP_DELAY_BIND_ALL -DNO_TK @V_DEFINE@ @V_DEFINES@ @DEFS@ -DNS_DIFFUSION -DSMAC_NO_SYNC -DCPP_NAMESPACE=@CPP_NAMESPACE@ -DUSE_SINGLE_ADDRESS_SPACE -Drng_test
-
-INCLUDES = \
-	-I. @V_INCLUDE_X11@ \
-	-I. \
-	@V_INCLUDES@ \
-	-I./tcp -I./sctp -I./common -I./link -I./queue \
-	-I./adc -I./apps -I./mac -I./mobile -I./trace \
-	-I./routing -I./tools -I./classifier -I./mcast \
-	-I./diffusion3/lib/main -I./diffusion3/lib \
-	-I./diffusion3/lib/nr -I./diffusion3/ns \
-	-I./diffusion3/filter_core -I./asim/ -I./qs \
-	-I./diffserv -I./satellite \
-	-I./wpan
-
-
-LIB	= \
-	@V_LIBS@ \
-	@V_LIB_X11@ \
-	@V_LIB@ \
-	-lm @LIBS@
-#	-L@libdir@ \
-
-CFLAGS	+= $(CCOPT) $(DEFINE) 
-
-# Explicitly define compilation rules since SunOS 4's make doesn't like gcc.
-# Also, gcc does not remove the .o before forking 'as', which can be a
-# problem if you don't own the file but can write to the directory.
-.SUFFIXES: .cc	# $(.SUFFIXES)
-
-.cc.o:
-	@rm -f $@
-	$(CPP) -c $(CFLAGS) $(INCLUDES) -o $@ $*.cc
-
-.c.o:
-	@rm -f $@
-	$(CC) -c $(CFLAGS) $(INCLUDES) -o $@ $*.c
-
-
-GEN_DIR	= gen/
-LIB_DIR	= lib/
-NS	= ns
-NSLIB   = @NSLIB@
-NSX	= nsx
-NSE	= nse
-NSTK = nstk
-
-# To allow conf/makefile.win overwrite this macro
-# We will set these two macros to empty in conf/makefile.win since VC6.0
-# does not seem to support the STL in gcc 2.8 and up. 
-OBJ_STL = diffusion3/lib/nr/nr.o diffusion3/lib/dr.o \
-	diffusion3/filters/diffusion/one_phase_pull.o \
-	diffusion3/filters/diffusion/two_phase_pull.o \
-	diffusion3/lib/diffapp.o \
-	diffusion3/ns/diffagent.o diffusion3/ns/diffrtg.o \
-	diffusion3/ns/difftimer.o \
-	diffusion3/filter_core/filter_core.o \
-	diffusion3/filter_core/iolog.o \
-	diffusion3/filter_core/iostats.o \
-	diffusion3/lib/main/attrs.o \
-	diffusion3/lib/main/events.o \
-	diffusion3/lib/main/iodev.o \
-	diffusion3/lib/main/iohook.o \
-	diffusion3/lib/main/timers.o \
-	diffusion3/lib/main/message.o \
-	diffusion3/lib/main/tools.o \
-	diffusion3/apps/gear_examples/gear_common.o \
-	diffusion3/apps/gear_examples/gear_receiver.o \
-	diffusion3/apps/gear_examples/gear_sender.o \
-	diffusion3/apps/rmst_examples/rmst_sink.o \
-	diffusion3/apps/rmst_examples/rmst_source.o \
-	diffusion3/apps/ping/1pp_ping_sender.o \
-	diffusion3/apps/ping/1pp_ping_receiver.o \
-	diffusion3/apps/ping/2pp_ping_sender.o \
-	diffusion3/apps/ping/2pp_ping_receiver.o \
-	diffusion3/apps/ping/ping_common.o \
-	diffusion3/apps/ping/push_receiver.o \
-	diffusion3/apps/ping/push_sender.o \
-	diffusion3/filters/gear/gear_attr.o \
-	diffusion3/filters/gear/gear.o \
-	diffusion3/filters/gear/gear_tools.o \
-	diffusion3/filters/misc/log.o \
-	diffusion3/filters/misc/srcrt.o \
-	diffusion3/filters/misc/tag.o \
-	diffusion3/filters/rmst/rmst.o \
-	diffusion3/filters/rmst/rmst_filter.o \
-	delaybox/delaybox.o \
-	packmime/packmime_HTTP.o packmime/packmime_HTTP_rng.o \
-	packmime/packmime_OL.o packmime/packmime_OL_ranvar.o\
-	packmime/packmime_ranvar.o \
-	tmix/tmix.o tmix/tmix_delaybox.o
-
-NS_TCL_LIB_STL = tcl/lib/ns-diffusion.tcl \
-	tcl/delaybox/delaybox.tcl \
-	tcl/packmime/packmime.tcl \
-	tcl/tmix/tmix.tcl \
-	tcl/tmix/tmix_delaybox.tcl
-
-
-# WIN32: uncomment the following line to include specific make for VC++
-# !include <conf/makefile.win>
-
-OBJ_CC = \
-	tools/random.o tools/rng.o tools/ranvar.o common/misc.o common/timer-handler.o \
-	common/scheduler.o common/object.o common/packet.o \
-	common/ip.o routing/route.o common/connector.o common/ttl.o \
-	trace/trace.o trace/trace-ip.o \
-	classifier/classifier.o classifier/classifier-addr.o \
-	classifier/classifier-hash.o \
-	classifier/classifier-virtual.o \
-	classifier/classifier-mcast.o \
-	classifier/classifier-bst.o \
-	classifier/classifier-mpath.o mcast/replicator.o \
-	classifier/classifier-mac.o \
-	classifier/classifier-qs.o \
-	classifier/classifier-port.o src_rtg/classifier-sr.o \
-        src_rtg/sragent.o src_rtg/hdr_src.o adc/ump.o \
-	qs/qsagent.o qs/hdr_qs.o \
-	apps/app.o apps/telnet.o tcp/tcplib-telnet.o \
-	tools/trafgen.o trace/traffictrace.o tools/pareto.o \
-	tools/expoo.o tools/cbr_traffic.o \
-	adc/tbf.o adc/resv.o adc/sa.o tcp/saack.o \
-	tools/measuremod.o adc/estimator.o adc/adc.o adc/ms-adc.o \
-	adc/timewindow-est.o adc/acto-adc.o \
-        adc/pointsample-est.o adc/salink.o adc/actp-adc.o \
-	adc/hb-adc.o adc/expavg-est.o\
-	adc/param-adc.o adc/null-estimator.o \
-	adc/adaptive-receiver.o apps/vatrcvr.o adc/consrcvr.o \
-	common/agent.o common/message.o apps/udp.o \
-	common/session-rtp.o apps/rtp.o tcp/rtcp.o \
-	common/ivs.o \
-	common/messpass.o common/tp.o common/tpm.o apps/worm.o \
-	tcp/tcp.o tcp/tcp-sink.o tcp/tcp-reno.o \
-	tcp/tcp-newreno.o \
-	tcp/tcp-vegas.o tcp/tcp-rbp.o tcp/tcp-full.o tcp/rq.o \
-	baytcp/tcp-full-bay.o baytcp/ftpc.o baytcp/ftps.o \
-	tcp/scoreboard.o tcp/scoreboard-rq.o tcp/tcp-sack1.o tcp/tcp-fack.o \
-	tcp/linux/tcp_naivereno.o\
-	tcp/linux/src/tcp_cong.o\
-	tcp/linux/src/tcp_highspeed.o tcp/linux/src/tcp_bic.o tcp/linux/src/tcp_htcp.o tcp/linux/src/tcp_scalable.o tcp/linux/src/tcp_cubic.o\
-	tcp/linux/src/tcp_westwood.o tcp/linux/src/tcp_vegas.o tcp/linux/src/tcp_hybla.o\
-	tcp/linux/src/tcp_illinois.o tcp/linux/src/tcp_yeah.o \
-	tcp/linux/src/tcp_veno.o tcp/linux/src/tcp_compound.o tcp/linux/src/tcp_lp.o\
-	tcp/scoreboard1.o tcp/tcp-linux.o tcp/linux/ns-linux-util.o tcp/linux/ns-linux-c.o tcp/linux/ns-linux-param.o\
-	tcp/tcp-asym.o tcp/tcp-asym-sink.o tcp/tcp-fs.o \
-	tcp/tcp-asym-fs.o \
-	tcp/tcp-int.o tcp/chost.o tcp/tcp-session.o \
-	tcp/nilist.o \
-	sctp/sctp.o apps/sctp_app1.o\
-	sctp/sctp-timestamp.o sctp/sctp-hbAfterRto.o \
-	sctp/sctp-multipleFastRtx.o sctp/sctp-mfrHbAfterRto.o \
-	sctp/sctp-mfrTimestamp.o \
-	sctp/sctp-cmt.o \
-	sctp/sctpDebug.o \
-	tools/integrator.o tools/queue-monitor.o \
-	tools/flowmon.o tools/loss-monitor.o \
-	queue/queue.o queue/drop-tail.o \
-	adc/simple-intserv-sched.o queue/red.o \
-	queue/semantic-packetqueue.o queue/semantic-red.o \
-	tcp/ack-recons.o \
-	queue/sfq.o queue/fq.o queue/drr.o queue/srr.o queue/cbq.o \
-	queue/jobs.o queue/marker.o queue/demarker.o \
-	link/hackloss.o queue/errmodel.o queue/fec.o\
-	link/delay.o tcp/snoop.o \
-	gaf/gaf.o \
-	link/dynalink.o routing/rtProtoDV.o common/net-interface.o \
-	mcast/ctrMcast.o mcast/mcast_ctrl.o mcast/srm.o \
-	common/sessionhelper.o queue/delaymodel.o \
-	mcast/srm-ssm.o mcast/srm-topo.o \
-	routing/alloc-address.o routing/address.o \
-	$(LIB_DIR)int.Vec.o $(LIB_DIR)int.RVec.o \
-	$(LIB_DIR)dmalloc_support.o \
-	webcache/http.o webcache/tcp-simple.o webcache/pagepool.o \
-	webcache/inval-agent.o webcache/tcpapp.o webcache/http-aux.o \
-	webcache/mcache.o webcache/webtraf.o \
-	webcache/webserver.o \
-	webcache/logweb.o \
-	empweb/empweb.o \
-	empweb/empftp.o \
-	realaudio/realaudio.o \
-	mac/lanRouter.o classifier/filter.o \
-	common/pkt-counter.o \
-	common/Decapsulator.o common/Encapsulator.o \
-	common/encap.o \
-	mac/channel.o mac/mac.o mac/ll.o mac/mac-802_11.o \
-	mac/mac-802_11Ext.o \
-	mac/mac-802_3.o mac/mac-tdma.o mac/smac.o \
-	mobile/mip.o mobile/mip-reg.o mobile/gridkeeper.o \
-	mobile/propagation.o mobile/tworayground.o \
-	mobile/nakagami.o \
-	mobile/antenna.o mobile/omni-antenna.o \
-	mobile/shadowing.o mobile/shadowing-vis.o mobile/dumb-agent.o \
-	common/bi-connector.o common/node.o \
-	common/mobilenode.o \
-	mac/arp.o mobile/god.o mobile/dem.o \
-	mobile/topography.o mobile/modulation.o \
-	queue/priqueue.o queue/dsr-priqueue.o \
-	mac/phy.o mac/wired-phy.o mac/wireless-phy.o \
-	mac/wireless-phyExt.o \
-	mac/mac-timers.o trace/cmu-trace.o mac/varp.o \
-	mac/mac-simple.o \
-	satellite/sat-hdlc.o \
-	dsdv/dsdv.o dsdv/rtable.o queue/rtqueue.o \
-	routing/rttable.o \
-	imep/imep.o imep/dest_queue.o imep/imep_api.o \
-	imep/imep_rt.o imep/rxmit_queue.o imep/imep_timers.o \
-	imep/imep_util.o imep/imep_io.o \
-	tora/tora.o tora/tora_api.o tora/tora_dest.o \
-	tora/tora_io.o tora/tora_logs.o tora/tora_neighbor.o \
-	dsr/dsragent.o dsr/hdr_sr.o dsr/mobicache.o dsr/path.o \
-	dsr/requesttable.o dsr/routecache.o dsr/add_sr.o \
-	dsr/dsr_proto.o dsr/flowstruct.o dsr/linkcache.o \
-	dsr/simplecache.o dsr/sr_forwarder.o \
-	aodv/aodv_logs.o aodv/aodv.o \
-	aodv/aodv_rtable.o aodv/aodv_rqueue.o \
-	aomdv/aomdv_logs.o aomdv/aomdv.o \
-	aomdv/aomdv_rtable.o aomdv/aomdv_rqueue.o \
-	common/ns-process.o \
-	satellite/satgeometry.o satellite/sathandoff.o \
-	satellite/satlink.o satellite/satnode.o \
-	satellite/satposition.o satellite/satroute.o \
-	satellite/sattrace.o \
-	rap/raplist.o rap/rap.o rap/media-app.o rap/utilities.o \
-	common/fsm.o tcp/tcp-abs.o \
-	diffusion/diffusion.o diffusion/diff_rate.o diffusion/diff_prob.o \
-	diffusion/diff_sink.o diffusion/flooding.o diffusion/omni_mcast.o \
-	diffusion/hash_table.o diffusion/routing_table.o diffusion/iflist.o \
-	tcp/tfrc.o tcp/tfrc-sink.o mobile/energy-model.o apps/ping.o tcp/tcp-rfc793edu.o \
-	queue/rio.o queue/semantic-rio.o tcp/tcp-sack-rh.o tcp/scoreboard-rh.o \
-	plm/loss-monitor-plm.o plm/cbr-traffic-PP.o \
-	linkstate/hdr-ls.o \
-	mpls/classifier-addr-mpls.o mpls/ldp.o mpls/mpls-module.o \
-	routing/rtmodule.o classifier/classifier-hier.o \
-	routing/addr-params.o \
-         nix/hdr_nv.o nix/classifier-nix.o \
-         nix/nixnode.o \
-         routealgo/rnode.o \
-         routealgo/bfs.o \
-         routealgo/rbitmap.o \
-         routealgo/rlookup.o \
-         routealgo/routealgo.o \
-         nix/nixvec.o \
-	nix/nixroute.o \
-	diffserv/dsred.o diffserv/dsredq.o \
-	diffserv/dsEdge.o diffserv/dsCore.o \
-	diffserv/dsPolicy.o diffserv/ew.o diffserv/dewp.o \
-	queue/red-pd.o queue/pi.o queue/vq.o queue/rem.o \
-	queue/gk.o \
-	pushback/rate-limit.o pushback/rate-limit-strategy.o \
-	pushback/ident-tree.o pushback/agg-spec.o \
-	pushback/logging-data-struct.o \
-	pushback/rate-estimator.o \
-	pushback/pushback-queue.o pushback/pushback.o \
-	common/parentnode.o trace/basetrace.o \
-	common/simulator.o asim/asim.o \
-	common/scheduler-map.o common/splay-scheduler.o \
-	linkstate/ls.o linkstate/rtProtoLS.o \
-	pgm/classifier-pgm.o pgm/pgm-agent.o pgm/pgm-sender.o \
-	pgm/pgm-receiver.o mcast/rcvbuf.o \
-	mcast/classifier-lms.o mcast/lms-agent.o mcast/lms-receiver.o \
-	mcast/lms-sender.o \
-	queue/delayer.o \
-	xcp/xcpq.o xcp/xcp.o xcp/xcp-end-sys.o \
-	wpan/p802_15_4csmaca.o wpan/p802_15_4fail.o \
-	wpan/p802_15_4hlist.o wpan/p802_15_4mac.o \
-	wpan/p802_15_4nam.o wpan/p802_15_4phy.o \
-	wpan/p802_15_4sscs.o wpan/p802_15_4timer.o \
-	wpan/p802_15_4trace.o wpan/p802_15_4transac.o \
-	apps/pbc.o \
-	@V_STLOBJ@
-
-
-# don't allow comments to follow continuation lines
-
-#  mac-csma.o mac-multihop.o\
-#	sensor-nets/landmark.o mac-simple-wireless.o \
-#	sensor-nets/tags.o sensor-nets/sensor-query.o \
-#	sensor-nets/flood-agent.o \
-
-# what was here before is now in emulate/
-OBJ_C =
-
-OBJ_COMPAT = $(OBJ_GETOPT) common/win32.o
-#XXX compat/win32x.o compat/tkConsole.o
-
-OBJ_EMULATE_CC = \
-	emulate/net-ip.o \
-	emulate/net.o \
-	emulate/tap.o \
-	emulate/ether.o \
-	emulate/internet.o \
-	emulate/ping_responder.o \
-	emulate/arp.o \
-	emulate/icmp.o \
-	emulate/net-pcap.o \
-	emulate/nat.o  \
-	emulate/iptap.o \
-	emulate/tcptap.o
-
-OBJ_EMULATE_C = \
-	emulate/inet.o
-
-OBJ_GEN = $(GEN_DIR)version.o $(GEN_DIR)ns_tcl.o $(GEN_DIR)ptypes.o
-
-SRC =	$(OBJ_C:.o=.c) $(OBJ_CC:.o=.cc) \
-	$(OBJ_EMULATE_C:.o=.c) $(OBJ_EMULATE_CC:.o=.cc) \
-	common/tclAppInit.cc common/tkAppInit.cc 
-
-OBJ =	$(OBJ_C) $(OBJ_CC) $(OBJ_GEN) $(OBJ_COMPAT)
-
-CLEANFILES = ns nse nsx ns.dyn $(OBJ) $(OBJ_EMULATE_CC) \
-	$(OBJ_EMULATE_C) common/tclAppInit.o \
-	common/tkAppInit.o nstk \
-	$(GEN_DIR)* $(NS).core core core.$(NS) core.$(NSX) core.$(NSE) \
-	common/ptypes2tcl common/ptypes2tcl.o 
-
-SUBDIRS=\
-	indep-utils/cmu-scen-gen/setdest \
-	indep-utils/webtrace-conv/dec \
-	indep-utils/webtrace-conv/epa \
-	indep-utils/webtrace-conv/nlanr \
-	indep-utils/webtrace-conv/ucb
-
-BUILD_NSE = @build_nse@
-
-all: $(NS) $(BUILD_NSE) $(NSTK) all-recursive Makefile
-
-
-all-recursive:
-	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) all; ) done
-
-
-
-
-ifeq ($(NSLIB),libns.dll)
-
-# This is for cygwin
-
-NS_CPPFLAGS = -DNSLIBNAME=\"$(NSLIB)\" 
-NS_LIBS =  @DL_LIBS@
-
-$(NSLIB): $(OBJ) common/tclAppInit.o 
-	$(LINK) -shared $(LDFLAGS) \
-		$(LDOUT)$@  \
-		-Wl,--export-all-symbols \
-		-Wl,--enable-auto-import \
-		-Wl,--out-implib=$@.a \
-		-Wl,--whole-archive $^ \
-		-Wl,--no-whole-archive @V_IMPORT_LIBS@ 
-
-$(NS): $(NSLIB) common/main-modular.cc 
-	$(LINK) $(NS_CPPFLAGS) $(LDFLAGS) $(LDOUT)$@ common/main-modular.cc $(NS_LIBS)
-
-else 
-
-# default for all systems but cygwin
-
-$(NS): $(OBJ) common/tclAppInit.o common/main-monolithic.o
-	$(LINK) $(LDFLAGS) $(LDOUT)$@ $^ $(LIB)
-
-endif 
-
-
-
-Makefile: Makefile.in
-	@echo "Makefile.in is newer than Makefile."
-	@echo "You need to re-run configure."
-	false
-
-$(NSE): $(OBJ) common/tclAppInit.o common/main-monolithic.o $(OBJ_EMULATE_CC) $(OBJ_EMULATE_C)
-	$(LINK) $(LDFLAGS) $(LDOUT)$@ $^ $(LIB) 
-
-$(NSTK): $(OBJ) common/tkAppInit.o 
-	$(LINK) $(LDFLAGS) $(LDOUT)$@ $^ $(LIB)
-
-ns.dyn: $(OBJ) common/tclAppInit.o common/main-monolithic.o 
-	$(LINK) $(LDFLAGS) -o $@ $^ $(LIB)
-
-PURIFY	= purify -cache-dir=/tmp
-ns-pure: $(OBJ) common/tclAppInit.o common/main-monolithic.o 
-	$(PURIFY) $(LINK) $(LDFLAGS) -o $@ $^ $(LIB)
-
-NS_TCL_LIB = \
-	tcl/lib/ns-compat.tcl \
-	tcl/lib/ns-default.tcl \
-	tcl/lib/ns-errmodel.tcl \
-	tcl/lib/ns-lib.tcl \
-	tcl/lib/ns-link.tcl \
-	tcl/lib/ns-mobilenode.tcl \
-	tcl/lib/ns-sat.tcl \
-	tcl/lib/ns-cmutrace.tcl \
-	tcl/lib/ns-node.tcl \
-	tcl/lib/ns-rtmodule.tcl \
-	tcl/lib/ns-hiernode.tcl \
-	tcl/lib/ns-packet.tcl \
-	tcl/lib/ns-queue.tcl \
-	tcl/lib/ns-source.tcl \
-	tcl/lib/ns-nam.tcl \
-	tcl/lib/ns-trace.tcl \
-	tcl/lib/ns-agent.tcl \
-	tcl/lib/ns-random.tcl \
-	tcl/lib/ns-namsupp.tcl \
-	tcl/lib/ns-address.tcl \
-	tcl/lib/ns-intserv.tcl \
-	tcl/lib/ns-autoconf.tcl \
-	tcl/rtp/session-rtp.tcl \
-	tcl/lib/ns-mip.tcl \
-	tcl/rtglib/dynamics.tcl \
-	tcl/rtglib/route-proto.tcl \
-	tcl/rtglib/algo-route-proto.tcl \
-	tcl/rtglib/ns-rtProtoLS.tcl \
-        tcl/interface/ns-iface.tcl \
-	tcl/mcast/BST.tcl \
-        tcl/mcast/ns-mcast.tcl \
-        tcl/mcast/McastProto.tcl \
-        tcl/mcast/DM.tcl \
-	tcl/mcast/srm.tcl \
-	tcl/mcast/srm-adaptive.tcl \
-	tcl/mcast/srm-ssm.tcl \
-	tcl/mcast/timer.tcl \
-	tcl/mcast/McastMonitor.tcl \
-	tcl/mobility/dsdv.tcl \
-	tcl/mobility/dsr.tcl \
-        tcl/ctr-mcast/CtrMcast.tcl \
-        tcl/ctr-mcast/CtrMcastComp.tcl \
-        tcl/ctr-mcast/CtrRPComp.tcl \
-	tcl/rlm/rlm.tcl \
-	tcl/rlm/rlm-ns.tcl \
-	tcl/session/session.tcl \
-	tcl/lib/ns-route.tcl \
-	tcl/emulate/ns-emulate.tcl \
-	tcl/lan/vlan.tcl \
-	tcl/lan/abslan.tcl \
-	tcl/lan/ns-ll.tcl \
-	tcl/lan/ns-mac.tcl \
-	tcl/webcache/http-agent.tcl \
-	tcl/webcache/http-server.tcl \
-	tcl/webcache/http-cache.tcl \
-	tcl/webcache/http-mcache.tcl \
-	tcl/webcache/webtraf.tcl \
-	tcl/webcache/empweb.tcl \
-	tcl/webcache/empftp.tcl \
-	tcl/plm/plm.tcl \
-	tcl/plm/plm-ns.tcl \
-	tcl/plm/plm-topo.tcl \
-	tcl/mpls/ns-mpls-classifier.tcl \
-	tcl/mpls/ns-mpls-ldpagent.tcl \
-	tcl/mpls/ns-mpls-node.tcl \
-	tcl/mpls/ns-mpls-simulator.tcl \
-	tcl/lib/ns-pushback.tcl \
-	tcl/lib/ns-srcrt.tcl \
-	tcl/mcast/ns-lms.tcl \
-	tcl/lib/ns-qsnode.tcl \
-	@V_NS_TCL_LIB_STL@
-
-$(GEN_DIR)ns_tcl.cc: $(NS_TCL_LIB)
-	$(TCLSH) bin/tcl-expand.tcl tcl/lib/ns-lib.tcl @V_NS_TCL_LIB_STL@ | $(TCL2C) et_ns_lib > $@
-
-$(GEN_DIR)version.c: VERSION
-	$(RM) $@
-	$(TCLSH) bin/string2c.tcl version_string < VERSION > $@
-
-$(GEN_DIR)ptypes.cc: common/ptypes2tcl common/packet.h
-	./common/ptypes2tcl > $@
-
-common/ptypes2tcl: common/ptypes2tcl.o
-	$(LINK) $(LDFLAGS) $(LDOUT)$@ common/ptypes2tcl.o
-
-common/ptypes2tcl.o: common/ptypes2tcl.cc common/packet.h
-
-dirs:
-	for d in $(DESTDIR)$(MANDEST)/man1; do \
-		if [ ! -d $$d ]; then \
-			mkdir -p $$d ;\
-		fi;\
-	done
-
-
-install: dirs force install-ns install-man
-
-install-ns: force
-	$(INSTALL) -m 755 ns $(DESTDIR)$(BINDEST)
-
-install-man: force
-	$(INSTALL) -m 644 ns.1 $(DESTDIR)$(MANDEST)/man1
-
-install-recursive: force
-	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) install; ) done
-
-clean:
-	$(RM) $(CLEANFILES)
-
-AUTOCONF_GEN = tcl/lib/ns-autoconf.tcl
-distclean: distclean-recursive
-	$(RM) $(CLEANFILES) Makefile config.cache config.log config.status \
-	    autoconf.h gnuc.h os-proto.h $(AUTOCONF_GEN); \
-	$(MV) .configure .configure- ;\
-	echo "Moved .configure to .configure-"
-
-distclean-recursive:
-	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) clean; $(RM) Makefile; ) done
-
-tags:	force
-	ctags -wtd *.cc *.h webcache/*.cc webcache/*.h dsdv/*.cc dsdv/*.h \
-	dsr/*.cc dsr/*.h webcache/*.cc webcache/*.h lib/*.cc lib/*.h \
-	../Tcl/*.cc ../Tcl/*.h 
-
-TAGS:	force
-	etags *.cc *.h webcache/*.cc webcache/*.h dsdv/*.cc dsdv/*.h \
-	dsr/*.cc dsr/*.h webcache/*.cc webcache/*.h lib/*.cc lib/*.h \
-	../Tcl/*.cc ../Tcl/*.h
-
-tcl/lib/TAGS:	force
-	( \
-		cd tcl/lib; \
-		$(TCLSH) ../../bin/tcl-expand.tcl ns-lib.tcl | grep '^### tcl-expand.tcl: begin' | awk '{print $$5}' >.tcl_files; \
-		etags --lang=none -r '/^[ \t]*proc[ \t]+\([^ \t]+\)/\1/' `cat .tcl_files`; \
-		etags --append --lang=none -r '/^\([A-Z][^ \t]+\)[ \t]+\(instproc\|proc\)[ \t]+\([^ \t]+\)[ \t]+/\1::\3/' `cat .tcl_files`; \
-	)
-
-depend: $(SRC)
-	$(MKDEP) $(CFLAGS) $(INCLUDES) -- $(SRC) 2>&1 > /dev/null
-
-srctar:
-	@cwd=`pwd` ; dir=`basename $$cwd` ; \
-	    name=ns-`cat VERSION | tr A-Z a-z` ; \
-	    tar=ns-src-`cat VERSION`.tar.gz ; \
-	    list="" ; \
-	    for i in `cat FILES` ; do list="$$list $$name/$$i" ; done; \
-	    echo \
-	    "(rm -f $$tar; cd .. ; ln -s $$dir $$name)" ; \
-	     (rm -f $$tar; cd .. ; ln -s $$dir $$name) ; \
-	    echo \
-	    "(cd .. ; tar cfhz $$tar [lots of files])" ; \
-	     (cd .. ; tar cfhz - $$list) > $$tar ; \
-	    echo \
-	    "rm ../$$name; chmod 444 $$tar" ;  \
-	     rm ../$$name; chmod 444 $$tar
-
-force:
-
-test:	force
-	./validate
-
-# Create makefile.vc for Win32 development by replacing:
-# "# !include ..." 	-> 	"!include ..."
-makefile.vc:	Makefile.in
-	$(PERL) bin/gen-vcmake.pl < Makefile.in > makefile.vc
-#	$(PERL) -pe 's/^# (\!include)/\!include/o' < Makefile.in > makefile.vc
+#  Copyright (c) 1994, 1995, 1996
+# 	The Regents of the University of California.  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that: (1) source code distributions
+#  retain the above copyright notice and this paragraph in its entirety, (2)
+#  distributions including binary code include the above copyright notice and
+#  this paragraph in its entirety in the documentation or other materials
+#  provided with the distribution, and (3) all advertising materials mentioning
+#  features or use of this software display the following acknowledgement:
+#  ``This product includes software developed by the University of California,
+#  Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
+#  the University nor the names of its contributors may be used to endorse
+#  or promote products derived from this software without specific prior
+#  written permission.
+#  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
+#  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+#
+# @(#) $Header: 2002/10/09 15:34:11
+
+#
+# Various configurable paths (remember to edit Makefile.in, not Makefile)
+#
+
+# Top level hierarchy
+prefix	= @prefix@
+# Pathname of directory to install the binary
+BINDEST	= @prefix@/bin
+# Pathname of directory to install the man page
+MANDEST	= @prefix@/man
+
+BLANK	= # make a blank space.  DO NOT add anything to this line
+
+# The following will be redefined under Windows (see WIN32 lable below)
+CC	= @CC@
+CPP	= @CXX@
+LINK	= $(CPP)
+LINK_SHLIB = @SHLIB_LD@
+MKDEP	= ./conf/mkdep
+TCLSH	= @V_TCLSH@
+TCL2C	= @V_TCL2CPP@
+AR	= ar rc $(BLANK)
+
+RANLIB	= @V_RANLIB@
+INSTALL	= @INSTALL@
+LN	= ln
+TEST	= test
+RM	= rm -f
+MV      = mv
+PERL	= @PERL@
+
+# for diffusion
+#DIFF_INCLUDES = "./diffusion3/main ./diffusion3/lib ./diffusion3/nr ./diffusion3/ns"
+
+CCOPT	= @V_CCOPT@ 
+STATIC	= @V_STATIC@
+#LDFLAGS	= $(STATIC)
+LDFLAGS	= @LDFLAGS@ 
+LDOUT	= -o $(BLANK)
+
+DEFINE	= -DTCP_DELAY_BIND_ALL -DNO_TK @V_DEFINE@ @V_DEFINES@ @DEFS@ -DNS_DIFFUSION -DSMAC_NO_SYNC -DCPP_NAMESPACE=@CPP_NAMESPACE@ -DUSE_SINGLE_ADDRESS_SPACE -Drng_test
+
+INCLUDES = \
+	-I. @V_INCLUDE_X11@ \
+	-I. \
+	@V_INCLUDES@ \
+	-I./tcp -I./sctp -I./common -I./link -I./queue \
+	-I./adc -I./apps -I./mac -I./mobile -I./trace \
+	-I./routing -I./tools -I./classifier -I./mcast \
+	-I./diffusion3/lib/main -I./diffusion3/lib \
+	-I./diffusion3/lib/nr -I./diffusion3/ns \
+	-I./diffusion3/filter_core -I./asim/ -I./qs \
+	-I./diffserv -I./satellite \
+	-I./wpan
+
+
+LIB	= \
+	@V_LIBS@ \
+	@V_LIB_X11@ \
+	@V_LIB@ \
+	-lm @LIBS@
+#	-L@libdir@ \
+
+CFLAGS	+= $(CCOPT) $(DEFINE) 
+
+# Explicitly define compilation rules since SunOS 4's make doesn't like gcc.
+# Also, gcc does not remove the .o before forking 'as', which can be a
+# problem if you don't own the file but can write to the directory.
+.SUFFIXES: .cc	# $(.SUFFIXES)
+
+.cc.o:
+	@rm -f $@
+	$(CPP) -c $(CFLAGS) $(INCLUDES) -o $@ $*.cc
+
+.c.o:
+	@rm -f $@
+	$(CC) -c $(CFLAGS) $(INCLUDES) -o $@ $*.c
+
+
+GEN_DIR	= gen/
+LIB_DIR	= lib/
+NS	= ns
+NSLIB   = @NSLIB@
+NSX	= nsx
+NSE	= nse
+NSTK = nstk
+
+# To allow conf/makefile.win overwrite this macro
+# We will set these two macros to empty in conf/makefile.win since VC6.0
+# does not seem to support the STL in gcc 2.8 and up. 
+OBJ_STL = diffusion3/lib/nr/nr.o diffusion3/lib/dr.o \
+	diffusion3/filters/diffusion/one_phase_pull.o \
+	diffusion3/filters/diffusion/two_phase_pull.o \
+	diffusion3/lib/diffapp.o \
+	diffusion3/ns/diffagent.o diffusion3/ns/diffrtg.o \
+	diffusion3/ns/difftimer.o \
+	diffusion3/filter_core/filter_core.o \
+	diffusion3/filter_core/iolog.o \
+	diffusion3/filter_core/iostats.o \
+	diffusion3/lib/main/attrs.o \
+	diffusion3/lib/main/events.o \
+	diffusion3/lib/main/iodev.o \
+	diffusion3/lib/main/iohook.o \
+	diffusion3/lib/main/timers.o \
+	diffusion3/lib/main/message.o \
+	diffusion3/lib/main/tools.o \
+	diffusion3/apps/gear_examples/gear_common.o \
+	diffusion3/apps/gear_examples/gear_receiver.o \
+	diffusion3/apps/gear_examples/gear_sender.o \
+	diffusion3/apps/rmst_examples/rmst_sink.o \
+	diffusion3/apps/rmst_examples/rmst_source.o \
+	diffusion3/apps/ping/1pp_ping_sender.o \
+	diffusion3/apps/ping/1pp_ping_receiver.o \
+	diffusion3/apps/ping/2pp_ping_sender.o \
+	diffusion3/apps/ping/2pp_ping_receiver.o \
+	diffusion3/apps/ping/ping_common.o \
+	diffusion3/apps/ping/push_receiver.o \
+	diffusion3/apps/ping/push_sender.o \
+	diffusion3/filters/gear/gear_attr.o \
+	diffusion3/filters/gear/gear.o \
+	diffusion3/filters/gear/gear_tools.o \
+	diffusion3/filters/misc/log.o \
+	diffusion3/filters/misc/srcrt.o \
+	diffusion3/filters/misc/tag.o \
+	diffusion3/filters/rmst/rmst.o \
+	diffusion3/filters/rmst/rmst_filter.o \
+	delaybox/delaybox.o \
+	packmime/packmime_HTTP.o packmime/packmime_HTTP_rng.o \
+	packmime/packmime_OL.o packmime/packmime_OL_ranvar.o\
+	packmime/packmime_ranvar.o \
+	tmix/tmix.o tmix/tmix_delaybox.o
+
+NS_TCL_LIB_STL = tcl/lib/ns-diffusion.tcl \
+	tcl/delaybox/delaybox.tcl \
+	tcl/packmime/packmime.tcl \
+	tcl/tmix/tmix.tcl \
+	tcl/tmix/tmix_delaybox.tcl
+
+
+# WIN32: uncomment the following line to include specific make for VC++
+# !include <conf/makefile.win>
+
+OBJ_CC = \
+	tools/random.o tools/rng.o tools/ranvar.o common/misc.o common/timer-handler.o \
+	common/scheduler.o common/object.o common/packet.o \
+	common/ip.o routing/route.o common/connector.o common/ttl.o \
+	trace/trace.o trace/trace-ip.o \
+	classifier/classifier.o classifier/classifier-addr.o \
+	classifier/classifier-hash.o \
+	classifier/classifier-virtual.o \
+	classifier/classifier-mcast.o \
+	classifier/classifier-bst.o \
+	classifier/classifier-mpath.o mcast/replicator.o \
+	classifier/classifier-mac.o \
+	classifier/classifier-qs.o \
+	classifier/classifier-port.o src_rtg/classifier-sr.o \
+        src_rtg/sragent.o src_rtg/hdr_src.o adc/ump.o \
+	qs/qsagent.o qs/hdr_qs.o \
+	apps/app.o apps/telnet.o tcp/tcplib-telnet.o \
+	tools/trafgen.o trace/traffictrace.o tools/pareto.o \
+	tools/expoo.o tools/cbr_traffic.o \
+	adc/tbf.o adc/resv.o adc/sa.o tcp/saack.o \
+	tools/measuremod.o adc/estimator.o adc/adc.o adc/ms-adc.o \
+	adc/timewindow-est.o adc/acto-adc.o \
+        adc/pointsample-est.o adc/salink.o adc/actp-adc.o \
+	adc/hb-adc.o adc/expavg-est.o\
+	adc/param-adc.o adc/null-estimator.o \
+	adc/adaptive-receiver.o apps/vatrcvr.o adc/consrcvr.o \
+	common/agent.o common/message.o apps/udp.o \
+	common/session-rtp.o apps/rtp.o tcp/rtcp.o \
+	common/ivs.o \
+	common/messpass.o common/tp.o common/tpm.o apps/worm.o \
+	tcp/tcp.o tcp/tcp-sink.o tcp/tcp-reno.o \
+	tcp/tcp-newreno.o \
+	tcp/tcp-vegas.o tcp/tcp-rbp.o tcp/tcp-full.o tcp/rq.o \
+	baytcp/tcp-full-bay.o baytcp/ftpc.o baytcp/ftps.o \
+	tcp/scoreboard.o tcp/scoreboard-rq.o tcp/tcp-sack1.o tcp/tcp-fack.o \
+	tcp/linux/tcp_naivereno.o\
+	tcp/linux/src/tcp_cong.o\
+	tcp/linux/src/tcp_highspeed.o tcp/linux/src/tcp_bic.o tcp/linux/src/tcp_htcp.o tcp/linux/src/tcp_scalable.o tcp/linux/src/tcp_cubic.o\
+	tcp/linux/src/tcp_westwood.o tcp/linux/src/tcp_vegas.o tcp/linux/src/tcp_hybla.o\
+	tcp/linux/src/tcp_illinois.o tcp/linux/src/tcp_yeah.o \
+	tcp/linux/src/tcp_veno.o tcp/linux/src/tcp_compound.o tcp/linux/src/tcp_lp.o\
+	tcp/scoreboard1.o tcp/tcp-linux.o tcp/linux/ns-linux-util.o tcp/linux/ns-linux-c.o tcp/linux/ns-linux-param.o\
+	tcp/tcp-asym.o tcp/tcp-asym-sink.o tcp/tcp-fs.o \
+	tcp/tcp-asym-fs.o \
+	tcp/tcp-int.o tcp/chost.o tcp/tcp-session.o \
+	tcp/nilist.o \
+	sctp/sctp.o apps/sctp_app1.o\
+	sctp/sctp-timestamp.o sctp/sctp-hbAfterRto.o \
+	sctp/sctp-multipleFastRtx.o sctp/sctp-mfrHbAfterRto.o \
+	sctp/sctp-mfrTimestamp.o \
+	sctp/sctp-cmt.o \
+	sctp/sctpDebug.o \
+	tools/integrator.o tools/queue-monitor.o \
+	tools/flowmon.o tools/loss-monitor.o \
+	queue/queue.o queue/drop-tail.o \
+	adc/simple-intserv-sched.o queue/red.o \
+	queue/semantic-packetqueue.o queue/semantic-red.o \
+	tcp/ack-recons.o \
+	queue/sfq.o queue/fq.o queue/drr.o queue/srr.o queue/cbq.o \
+	queue/jobs.o queue/marker.o queue/demarker.o \
+	link/hackloss.o queue/errmodel.o queue/fec.o\
+	link/delay.o tcp/snoop.o \
+	gaf/gaf.o \
+	link/dynalink.o routing/rtProtoDV.o common/net-interface.o \
+	mcast/ctrMcast.o mcast/mcast_ctrl.o mcast/srm.o \
+	common/sessionhelper.o queue/delaymodel.o \
+	mcast/srm-ssm.o mcast/srm-topo.o \
+	routing/alloc-address.o routing/address.o \
+	$(LIB_DIR)int.Vec.o $(LIB_DIR)int.RVec.o \
+	$(LIB_DIR)dmalloc_support.o \
+	webcache/http.o webcache/tcp-simple.o webcache/pagepool.o \
+	webcache/inval-agent.o webcache/tcpapp.o webcache/http-aux.o \
+	webcache/mcache.o webcache/webtraf.o \
+	webcache/webserver.o \
+	webcache/logweb.o \
+	empweb/empweb.o \
+	empweb/empftp.o \
+	realaudio/realaudio.o \
+	mac/lanRouter.o classifier/filter.o \
+	common/pkt-counter.o \
+	common/Decapsulator.o common/Encapsulator.o \
+	common/encap.o \
+	mac/channel.o mac/mac.o mac/ll.o mac/mac-802_11.o \
+	mac/mac-802_11Ext.o \
+	mac/mac-802_3.o mac/mac-tdma.o mac/smac.o \
+	mobile/mip.o mobile/mip-reg.o mobile/gridkeeper.o \
+	mobile/propagation.o mobile/tworayground.o \
+	mobile/nakagami.o \
+	mobile/antenna.o mobile/omni-antenna.o \
+	mobile/shadowing.o mobile/shadowing-vis.o mobile/dumb-agent.o \
+	common/bi-connector.o common/node.o \
+	common/mobilenode.o \
+	mac/arp.o mobile/god.o mobile/dem.o \
+	mobile/topography.o mobile/modulation.o \
+	queue/priqueue.o queue/dsr-priqueue.o \
+	mac/phy.o mac/wired-phy.o mac/wireless-phy.o \
+	mac/wireless-phyExt.o \
+	mac/mac-timers.o trace/cmu-trace.o mac/varp.o \
+	mac/mac-simple.o \
+	satellite/sat-hdlc.o \
+	dsdv/dsdv.o dsdv/rtable.o queue/rtqueue.o \
+	routing/rttable.o \
+	imep/imep.o imep/dest_queue.o imep/imep_api.o \
+	imep/imep_rt.o imep/rxmit_queue.o imep/imep_timers.o \
+	imep/imep_util.o imep/imep_io.o \
+	tora/tora.o tora/tora_api.o tora/tora_dest.o \
+	tora/tora_io.o tora/tora_logs.o tora/tora_neighbor.o \
+	dsr/dsragent.o dsr/hdr_sr.o dsr/mobicache.o dsr/path.o \
+	dsr/requesttable.o dsr/routecache.o dsr/add_sr.o \
+	dsr/dsr_proto.o dsr/flowstruct.o dsr/linkcache.o \
+	dsr/simplecache.o dsr/sr_forwarder.o \
+	aodv/aodv_logs.o aodv/aodv.o \
+	aodv/aodv_rtable.o aodv/aodv_rqueue.o \
+	aomdv/aomdv_logs.o aomdv/aomdv.o \
+	aomdv/aomdv_rtable.o aomdv/aomdv_rqueue.o \
+	common/ns-process.o \
+	satellite/satgeometry.o satellite/sathandoff.o \
+	satellite/satlink.o satellite/satnode.o \
+	satellite/satposition.o satellite/satroute.o \
+	satellite/sattrace.o \
+	rap/raplist.o rap/rap.o rap/media-app.o rap/utilities.o \
+	common/fsm.o tcp/tcp-abs.o \
+	diffusion/diffusion.o diffusion/diff_rate.o diffusion/diff_prob.o \
+	diffusion/diff_sink.o diffusion/flooding.o diffusion/omni_mcast.o \
+	diffusion/hash_table.o diffusion/routing_table.o diffusion/iflist.o \
+	tcp/tfrc.o tcp/tfrc-sink.o mobile/energy-model.o apps/ping.o tcp/tcp-rfc793edu.o \
+	queue/rio.o queue/semantic-rio.o tcp/tcp-sack-rh.o tcp/scoreboard-rh.o \
+	plm/loss-monitor-plm.o plm/cbr-traffic-PP.o \
+	linkstate/hdr-ls.o \
+	mpls/classifier-addr-mpls.o mpls/ldp.o mpls/mpls-module.o \
+	routing/rtmodule.o classifier/classifier-hier.o \
+	routing/addr-params.o \
+         nix/hdr_nv.o nix/classifier-nix.o \
+         nix/nixnode.o \
+         routealgo/rnode.o \
+         routealgo/bfs.o \
+         routealgo/rbitmap.o \
+         routealgo/rlookup.o \
+         routealgo/routealgo.o \
+         nix/nixvec.o \
+	nix/nixroute.o \
+	diffserv/dsred.o diffserv/dsredq.o \
+	diffserv/dsEdge.o diffserv/dsCore.o \
+	diffserv/dsPolicy.o diffserv/ew.o diffserv/dewp.o \
+	queue/red-pd.o queue/pi.o queue/vq.o queue/rem.o \
+	queue/gk.o \
+	pushback/rate-limit.o pushback/rate-limit-strategy.o \
+	pushback/ident-tree.o pushback/agg-spec.o \
+	pushback/logging-data-struct.o \
+	pushback/rate-estimator.o \
+	pushback/pushback-queue.o pushback/pushback.o \
+	common/parentnode.o trace/basetrace.o \
+	common/simulator.o asim/asim.o \
+	common/scheduler-map.o common/splay-scheduler.o \
+	linkstate/ls.o linkstate/rtProtoLS.o \
+	pgm/classifier-pgm.o pgm/pgm-agent.o pgm/pgm-sender.o \
+	pgm/pgm-receiver.o mcast/rcvbuf.o \
+	mcast/classifier-lms.o mcast/lms-agent.o mcast/lms-receiver.o \
+	mcast/lms-sender.o \
+	queue/delayer.o \
+	xcp/xcpq.o xcp/xcp.o xcp/xcp-end-sys.o \
+	wpan/p802_15_4csmaca.o wpan/p802_15_4fail.o \
+	wpan/p802_15_4hlist.o wpan/p802_15_4mac.o \
+	wpan/p802_15_4nam.o wpan/p802_15_4phy.o \
+	wpan/p802_15_4sscs.o wpan/p802_15_4timer.o \
+	wpan/p802_15_4trace.o wpan/p802_15_4transac.o \
+	apps/pbc.o \
+	mac/mac-802_16/mac-802_16.o mac/mac-802_16/packet-802_16.o mac/mac-802_16/timer-802_16.o \
+	mac/mac-802_16/traffic/BE_traffic.o mac/mac-802_16/traffic/ertPS_traffic.o mac/mac-802_16/traffic/nrtPS_traffic.o mac/mac-802_16/traffic/rtPS_traffic.o mac/mac-802_16/traffic/UGS_traffic.o \
+	@V_STLOBJ@
+
+
+# don't allow comments to follow continuation lines
+
+#  mac-csma.o mac-multihop.o\
+#	sensor-nets/landmark.o mac-simple-wireless.o \
+#	sensor-nets/tags.o sensor-nets/sensor-query.o \
+#	sensor-nets/flood-agent.o \
+
+# what was here before is now in emulate/
+OBJ_C =
+
+OBJ_COMPAT = $(OBJ_GETOPT) common/win32.o
+#XXX compat/win32x.o compat/tkConsole.o
+
+OBJ_EMULATE_CC = \
+	emulate/net-ip.o \
+	emulate/net.o \
+	emulate/tap.o \
+	emulate/ether.o \
+	emulate/internet.o \
+	emulate/ping_responder.o \
+	emulate/arp.o \
+	emulate/icmp.o \
+	emulate/net-pcap.o \
+	emulate/nat.o  \
+	emulate/iptap.o \
+	emulate/tcptap.o
+
+OBJ_EMULATE_C = \
+	emulate/inet.o
+
+OBJ_GEN = $(GEN_DIR)version.o $(GEN_DIR)ns_tcl.o $(GEN_DIR)ptypes.o
+
+SRC =	$(OBJ_C:.o=.c) $(OBJ_CC:.o=.cc) \
+	$(OBJ_EMULATE_C:.o=.c) $(OBJ_EMULATE_CC:.o=.cc) \
+	common/tclAppInit.cc common/tkAppInit.cc 
+
+OBJ =	$(OBJ_C) $(OBJ_CC) $(OBJ_GEN) $(OBJ_COMPAT)
+
+CLEANFILES = ns nse nsx ns.dyn $(OBJ) $(OBJ_EMULATE_CC) \
+	$(OBJ_EMULATE_C) common/tclAppInit.o \
+	common/tkAppInit.o nstk \
+	$(GEN_DIR)* $(NS).core core core.$(NS) core.$(NSX) core.$(NSE) \
+	common/ptypes2tcl common/ptypes2tcl.o 
+
+SUBDIRS=\
+	indep-utils/cmu-scen-gen/setdest \
+	indep-utils/webtrace-conv/dec \
+	indep-utils/webtrace-conv/epa \
+	indep-utils/webtrace-conv/nlanr \
+	indep-utils/webtrace-conv/ucb
+
+BUILD_NSE = @build_nse@
+
+all: $(NS) $(BUILD_NSE) $(NSTK) all-recursive Makefile
+
+
+all-recursive:
+	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) all; ) done
+
+
+
+
+ifeq ($(NSLIB),libns.dll)
+
+# This is for cygwin
+
+NS_CPPFLAGS = -DNSLIBNAME=\"$(NSLIB)\" 
+NS_LIBS =  @DL_LIBS@
+
+$(NSLIB): $(OBJ) common/tclAppInit.o 
+	$(LINK) -shared $(LDFLAGS) \
+		$(LDOUT)$@  \
+		-Wl,--export-all-symbols \
+		-Wl,--enable-auto-import \
+		-Wl,--out-implib=$@.a \
+		-Wl,--whole-archive $^ \
+		-Wl,--no-whole-archive @V_IMPORT_LIBS@ 
+
+$(NS): $(NSLIB) common/main-modular.cc 
+	$(LINK) $(NS_CPPFLAGS) $(LDFLAGS) $(LDOUT)$@ common/main-modular.cc $(NS_LIBS)
+
+else 
+
+# default for all systems but cygwin
+
+$(NS): $(OBJ) common/tclAppInit.o common/main-monolithic.o
+	$(LINK) $(LDFLAGS) $(LDOUT)$@ $^ $(LIB)
+
+endif 
+
+
+
+Makefile: Makefile.in
+	@echo "Makefile.in is newer than Makefile."
+	@echo "You need to re-run configure."
+	false
+
+$(NSE): $(OBJ) common/tclAppInit.o common/main-monolithic.o $(OBJ_EMULATE_CC) $(OBJ_EMULATE_C)
+	$(LINK) $(LDFLAGS) $(LDOUT)$@ $^ $(LIB) 
+
+$(NSTK): $(OBJ) common/tkAppInit.o 
+	$(LINK) $(LDFLAGS) $(LDOUT)$@ $^ $(LIB)
+
+ns.dyn: $(OBJ) common/tclAppInit.o common/main-monolithic.o 
+	$(LINK) $(LDFLAGS) -o $@ $^ $(LIB)
+
+PURIFY	= purify -cache-dir=/tmp
+ns-pure: $(OBJ) common/tclAppInit.o common/main-monolithic.o 
+	$(PURIFY) $(LINK) $(LDFLAGS) -o $@ $^ $(LIB)
+
+NS_TCL_LIB = \
+	tcl/lib/ns-compat.tcl \
+	tcl/lib/ns-default.tcl \
+	tcl/lib/ns-errmodel.tcl \
+	tcl/lib/ns-lib.tcl \
+	tcl/lib/ns-link.tcl \
+	tcl/lib/ns-mobilenode.tcl \
+	tcl/lib/ns-sat.tcl \
+	tcl/lib/ns-cmutrace.tcl \
+	tcl/lib/ns-node.tcl \
+	tcl/lib/ns-rtmodule.tcl \
+	tcl/lib/ns-hiernode.tcl \
+	tcl/lib/ns-packet.tcl \
+	tcl/lib/ns-queue.tcl \
+	tcl/lib/ns-source.tcl \
+	tcl/lib/ns-nam.tcl \
+	tcl/lib/ns-trace.tcl \
+	tcl/lib/ns-agent.tcl \
+	tcl/lib/ns-random.tcl \
+	tcl/lib/ns-namsupp.tcl \
+	tcl/lib/ns-address.tcl \
+	tcl/lib/ns-intserv.tcl \
+	tcl/lib/ns-autoconf.tcl \
+	tcl/rtp/session-rtp.tcl \
+	tcl/lib/ns-mip.tcl \
+	tcl/rtglib/dynamics.tcl \
+	tcl/rtglib/route-proto.tcl \
+	tcl/rtglib/algo-route-proto.tcl \
+	tcl/rtglib/ns-rtProtoLS.tcl \
+        tcl/interface/ns-iface.tcl \
+	tcl/mcast/BST.tcl \
+        tcl/mcast/ns-mcast.tcl \
+        tcl/mcast/McastProto.tcl \
+        tcl/mcast/DM.tcl \
+	tcl/mcast/srm.tcl \
+	tcl/mcast/srm-adaptive.tcl \
+	tcl/mcast/srm-ssm.tcl \
+	tcl/mcast/timer.tcl \
+	tcl/mcast/McastMonitor.tcl \
+	tcl/mobility/dsdv.tcl \
+	tcl/mobility/dsr.tcl \
+        tcl/ctr-mcast/CtrMcast.tcl \
+        tcl/ctr-mcast/CtrMcastComp.tcl \
+        tcl/ctr-mcast/CtrRPComp.tcl \
+	tcl/rlm/rlm.tcl \
+	tcl/rlm/rlm-ns.tcl \
+	tcl/session/session.tcl \
+	tcl/lib/ns-route.tcl \
+	tcl/emulate/ns-emulate.tcl \
+	tcl/lan/vlan.tcl \
+	tcl/lan/abslan.tcl \
+	tcl/lan/ns-ll.tcl \
+	tcl/lan/ns-mac.tcl \
+	tcl/webcache/http-agent.tcl \
+	tcl/webcache/http-server.tcl \
+	tcl/webcache/http-cache.tcl \
+	tcl/webcache/http-mcache.tcl \
+	tcl/webcache/webtraf.tcl \
+	tcl/webcache/empweb.tcl \
+	tcl/webcache/empftp.tcl \
+	tcl/plm/plm.tcl \
+	tcl/plm/plm-ns.tcl \
+	tcl/plm/plm-topo.tcl \
+	tcl/mpls/ns-mpls-classifier.tcl \
+	tcl/mpls/ns-mpls-ldpagent.tcl \
+	tcl/mpls/ns-mpls-node.tcl \
+	tcl/mpls/ns-mpls-simulator.tcl \
+	tcl/lib/ns-pushback.tcl \
+	tcl/lib/ns-srcrt.tcl \
+	tcl/mcast/ns-lms.tcl \
+	tcl/lib/ns-qsnode.tcl \
+	@V_NS_TCL_LIB_STL@
+
+$(GEN_DIR)ns_tcl.cc: $(NS_TCL_LIB)
+	$(TCLSH) bin/tcl-expand.tcl tcl/lib/ns-lib.tcl @V_NS_TCL_LIB_STL@ | $(TCL2C) et_ns_lib > $@
+
+$(GEN_DIR)version.c: VERSION
+	$(RM) $@
+	$(TCLSH) bin/string2c.tcl version_string < VERSION > $@
+
+$(GEN_DIR)ptypes.cc: common/ptypes2tcl common/packet.h
+	./common/ptypes2tcl > $@
+
+common/ptypes2tcl: common/ptypes2tcl.o
+	$(LINK) $(LDFLAGS) $(LDOUT)$@ common/ptypes2tcl.o
+
+common/ptypes2tcl.o: common/ptypes2tcl.cc common/packet.h
+
+dirs:
+	for d in $(DESTDIR)$(MANDEST)/man1; do \
+		if [ ! -d $$d ]; then \
+			mkdir -p $$d ;\
+		fi;\
+	done
+
+
+install: dirs force install-ns install-man
+
+install-ns: force
+	$(INSTALL) -m 755 ns $(DESTDIR)$(BINDEST)
+
+install-man: force
+	$(INSTALL) -m 644 ns.1 $(DESTDIR)$(MANDEST)/man1
+
+install-recursive: force
+	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) install; ) done
+
+clean:
+	$(RM) $(CLEANFILES)
+
+AUTOCONF_GEN = tcl/lib/ns-autoconf.tcl
+distclean: distclean-recursive
+	$(RM) $(CLEANFILES) Makefile config.cache config.log config.status \
+	    autoconf.h gnuc.h os-proto.h $(AUTOCONF_GEN); \
+	$(MV) .configure .configure- ;\
+	echo "Moved .configure to .configure-"
+
+distclean-recursive:
+	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) clean; $(RM) Makefile; ) done
+
+tags:	force
+	ctags -wtd *.cc *.h webcache/*.cc webcache/*.h dsdv/*.cc dsdv/*.h \
+	dsr/*.cc dsr/*.h webcache/*.cc webcache/*.h lib/*.cc lib/*.h \
+	../Tcl/*.cc ../Tcl/*.h 
+
+TAGS:	force
+	etags *.cc *.h webcache/*.cc webcache/*.h dsdv/*.cc dsdv/*.h \
+	dsr/*.cc dsr/*.h webcache/*.cc webcache/*.h lib/*.cc lib/*.h \
+	../Tcl/*.cc ../Tcl/*.h
+
+tcl/lib/TAGS:	force
+	( \
+		cd tcl/lib; \
+		$(TCLSH) ../../bin/tcl-expand.tcl ns-lib.tcl | grep '^### tcl-expand.tcl: begin' | awk '{print $$5}' >.tcl_files; \
+		etags --lang=none -r '/^[ \t]*proc[ \t]+\([^ \t]+\)/\1/' `cat .tcl_files`; \
+		etags --append --lang=none -r '/^\([A-Z][^ \t]+\)[ \t]+\(instproc\|proc\)[ \t]+\([^ \t]+\)[ \t]+/\1::\3/' `cat .tcl_files`; \
+	)
+
+depend: $(SRC)
+	$(MKDEP) $(CFLAGS) $(INCLUDES) -- $(SRC) 2>&1 > /dev/null
+
+srctar:
+	@cwd=`pwd` ; dir=`basename $$cwd` ; \
+	    name=ns-`cat VERSION | tr A-Z a-z` ; \
+	    tar=ns-src-`cat VERSION`.tar.gz ; \
+	    list="" ; \
+	    for i in `cat FILES` ; do list="$$list $$name/$$i" ; done; \
+	    echo \
+	    "(rm -f $$tar; cd .. ; ln -s $$dir $$name)" ; \
+	     (rm -f $$tar; cd .. ; ln -s $$dir $$name) ; \
+	    echo \
+	    "(cd .. ; tar cfhz $$tar [lots of files])" ; \
+	     (cd .. ; tar cfhz - $$list) > $$tar ; \
+	    echo \
+	    "rm ../$$name; chmod 444 $$tar" ;  \
+	     rm ../$$name; chmod 444 $$tar
+
+force:
+
+test:	force
+	./validate
+
+# Create makefile.vc for Win32 development by replacing:
+# "# !include ..." 	-> 	"!include ..."
+makefile.vc:	Makefile.in
+	$(PERL) bin/gen-vcmake.pl < Makefile.in > makefile.vc
+#	$(PERL) -pe 's/^# (\!include)/\!include/o' < Makefile.in > makefile.vc
diff -u -r -N ns-2.34.original/common/mobilenode.cc ns-2.34/common/mobilenode.cc
--- ns-2.34.original/common/mobilenode.cc	2009-06-15 01:35:44.000000000 +0800
+++ ns-2.34/common/mobilenode.cc	2012-08-08 14:52:49.952625000 +0800
@@ -1,608 +1,617 @@
-/*-*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- 
- *
- * Copyright (c) 1997 Regents of the University of California.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the Computer Systems
- *	Engineering Group at Lawrence Berkeley Laboratory.
- * 4. Neither the name of the University nor of the Laboratory may be used
- *    to endorse or promote products derived from this software without
- *    specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * $Header: /cvsroot/nsnam/ns-2/common/mobilenode.cc,v 1.36 2006/02/22 13:21:52 mahrenho Exp $
- *
- * Code in this file will be changed in the near future. From now on it 
- * should be treated as for backward compatibility only, although it is in
- * active use by many other code in ns. - Aug 29, 2000
- */
-
-/* 
- * CMU-Monarch project's Mobility extensions ported by Padma Haldar, 
- * 11/98.
- */
-
-
-#include <math.h>
-#include <stdlib.h>
-
-#include "connector.h"
-#include "delay.h"
-#include "packet.h"
-#include "random.h"
-#include "trace.h"
-#include "address.h"
-
-#include "arp.h"
-#include "topography.h"
-#include "ll.h"
-#include "mac.h"
-#include "propagation.h"
-#include "mobilenode.h"
-#include "phy.h"
-#include "wired-phy.h"
-#include "god.h"
-
-// XXX Must supply the first parameter in the macro otherwise msvc
-// is unhappy. 
-static LIST_HEAD(_dummy_MobileNodeList, MobileNode) nodehead = { 0 };
-
-static class MobileNodeClass : public TclClass {
-public:
-        MobileNodeClass() : TclClass("Node/MobileNode") {}
-        TclObject* create(int, const char*const*) {
-                return (new MobileNode);
-        }
-} class_mobilenode;
-
-/*
- *  PositionHandler()
- *
- *  Updates the position of a mobile node every N seconds, where N is
- *  based upon the speed of the mobile and the resolution of the topography.
- *
- */
-void
-PositionHandler::handle(Event*)
-{
-	Scheduler& s = Scheduler::instance();
-
-#if 0
-	fprintf(stderr, "*** POSITION HANDLER for node %d (time: %f) ***\n",
-		node->address(), s.clock());
-#endif
-	/*
-	 * Update current location
-	 */
-	node->update_position();
-
-	/*
-	 * Choose a new random speed and direction
-	 */
-#ifdef DEBUG
-        fprintf(stderr, "%d - %s: calling random_destination()\n",
-                node->address_, __PRETTY_FUNCTION__);
-#endif
-	node->random_destination();
-
-	s.schedule(&node->pos_handle_, &node->pos_intr_,
-		   node->position_update_interval_);
-}
-
-
-/* ======================================================================
-   Mobile Node
-   ====================================================================== */
-
-MobileNode::MobileNode(void) : 
-	pos_handle_(this)
-{
-	X_ = Y_ = Z_ = speed_ = 0.0;
-	dX_ = dY_ = dZ_ = 0.0;
-	destX_ = destY_ = 0.0;
-
-	random_motion_ = 0;
-	base_stn_ = -1;
-	T_ = 0;
-
-	log_target_ = 0;
-	next_ = 0;
-	radius_ = 0;
-
-	position_update_interval_ = MN_POSITION_UPDATE_INTERVAL;
-	position_update_time_ = 0.0;
-	
-
-	LIST_INSERT_HEAD(&nodehead, this, link_);	// node list
-	LIST_INIT(&ifhead_);				// interface list
-	bind("X_", &X_);
-	bind("Y_", &Y_);
-	bind("Z_", &Z_);
-	bind("speed_", &speed_);
-	
-}
-
-int
-MobileNode::command(int argc, const char*const* argv)
-{
-	Tcl& tcl = Tcl::instance();
-	if(argc == 2) {
-		if(strcmp(argv[1], "start") == 0) {
-		        start();
-			return TCL_OK;
-		} else if(strcmp(argv[1], "log-movement") == 0) {
-#ifdef DEBUG
-                        fprintf(stderr,
-                                "%d - %s: calling update_position()\n",
-                                address_, __PRETTY_FUNCTION__);
-#endif
-		        update_position();
-		        log_movement();
-			return TCL_OK;
-		} else if(strcmp(argv[1], "log-energy") == 0) {
-			log_energy(1);
-			return TCL_OK;
-		} else if(strcmp(argv[1], "powersaving") == 0) {
-			energy_model()->powersavingflag() = 1;
-			energy_model()->start_powersaving();
-			return TCL_OK;
-		} else if(strcmp(argv[1], "adaptivefidelity") == 0) {
-			energy_model()->adaptivefidelity() = 1;
-			energy_model()->powersavingflag() = 1;
-			energy_model()->start_powersaving();
-			return TCL_OK;
-		} else if (strcmp(argv[1], "energy") == 0) {
-			Tcl& tcl = Tcl::instance();
-			tcl.resultf("%f", energy_model()->energy());
-			return TCL_OK;
-		} else if (strcmp(argv[1], "adjustenergy") == 0) {
-			// assume every 10 sec schedule and 1.15 W 
-			// idle energy consumption. needs to be
-			// parameterized.
-			idle_energy_patch(10, 1.15);
-			energy_model()->total_sndtime() = 0;
-			energy_model()->total_rcvtime() = 0;
-			energy_model()->total_sleeptime() = 0;
-			return TCL_OK;
-		} else if (strcmp(argv[1], "on") == 0) {
-			energy_model()->node_on() = true;
-			tcl.evalf("%s set netif_(0)", name_);
-			const char *str = tcl.result();
-			tcl.evalf("%s NodeOn", str);
-			God::instance()->ComputeRoute();
-			return TCL_OK;
-		} else if (strcmp(argv[1], "off") == 0) {
-			energy_model()->node_on() = false;
-			tcl.evalf("%s set netif_(0)", name_);
-			const char *str = tcl.result();
-			tcl.evalf("%s NodeOff", str);
-			tcl.evalf("%s set ragent_", name_);
-			str = tcl.result();
-			tcl.evalf("%s reset-state", str);
-			God::instance()->ComputeRoute();
-		     	return TCL_OK;
-		} else if (strcmp(argv[1], "shutdown") == 0) {
-			// set node state
-			//Phy *p;
-			energy_model()->node_on() = false;
-			
-			//p = ifhead().lh_first;
-			//if (p) ((WirelessPhy *)p)->node_off();
-			return TCL_OK;
-		} else if (strcmp(argv[1], "startup") == 0) {
-			energy_model()->node_on() = true;
-			return TCL_OK;
-		}
-	
-	} else if(argc == 3) {
-		if(strcmp(argv[1], "addif") == 0) {
-			WiredPhy* phyp = (WiredPhy*)TclObject::lookup(argv[2]);
-			if(phyp == 0)
-				return TCL_ERROR;
-			phyp->insertnode(&ifhead_);
-			phyp->setnode(this);
-			return TCL_OK;
-		} else if (strcmp(argv[1], "setsleeptime") == 0) {
-			energy_model()->afe()->set_sleeptime(atof(argv[2]));
-			energy_model()->afe()->set_sleepseed(atof(argv[2]));
-			return TCL_OK;
-		} else if (strcmp(argv[1], "setenergy") == 0) {
-			energy_model()->setenergy(atof(argv[2]));
-			return TCL_OK;
-		} else if (strcmp(argv[1], "settalive") == 0) {
-			energy_model()->max_inroute_time() = atof(argv[2]);
-			return TCL_OK;
-		} else if (strcmp(argv[1], "maxttl") == 0) {
-			energy_model()->maxttl() = atoi(argv[2]);
-			return TCL_OK;
-		} else if(strcmp(argv[1], "radius") == 0) {
-                        radius_ = strtod(argv[2],NULL);
-                        return TCL_OK;
-                } else if(strcmp(argv[1], "random-motion") == 0) {
-			random_motion_ = atoi(argv[2]);
-			return TCL_OK;
-		} else if(strcmp(argv[1], "addif") == 0) {
-			WirelessPhy *n = (WirelessPhy*)
-				TclObject::lookup(argv[2]);
-			if(n == 0)
-				return TCL_ERROR;
-			n->insertnode(&ifhead_);
-			n->setnode(this);
-			return TCL_OK;
-		} else if(strcmp(argv[1], "topography") == 0) {
-			T_ = (Topography*) TclObject::lookup(argv[2]);
-			if (T_ == 0)
-				return TCL_ERROR;
-			return TCL_OK;
-		} else if(strcmp(argv[1], "log-target") == 0) {
-			log_target_ = (Trace*) TclObject::lookup(argv[2]);
-			if (log_target_ == 0)
-				return TCL_ERROR;
-			return TCL_OK;
-		} else if (strcmp(argv[1],"base-station") == 0) {
-			base_stn_ = atoi(argv[2]);
-			if(base_stn_ == -1)
-				return TCL_ERROR;
-			return TCL_OK;
-		} 
-	} else if (argc == 4) {
-		if (strcmp(argv[1], "idleenergy") == 0) {
-			idle_energy_patch(atof(argv[2]),atof(argv[3]));
-			return TCL_OK;
-		}
-	} else if (argc == 5) {
-		if (strcmp(argv[1], "setdest") == 0) { 
-			/* <mobilenode> setdest <X> <Y> <speed> */
-#ifdef DEBUG
-			fprintf(stderr, "%d - %s: calling set_destination()\n",
-				address_, __FUNCTION__);
-#endif
-  
-			if (set_destination(atof(argv[2]), atof(argv[3]), 
-					    atof(argv[4])) < 0)
-				return TCL_ERROR;
-			return TCL_OK;
-		}
-	}
-	return Node::command(argc, argv);
-}
-
-
-/* ======================================================================
-   Other class functions
-   ====================================================================== */
-void
-MobileNode::dump(void)
-{
-	Phy *n;
-	fprintf(stdout, "Index: %d\n", address_);
-	fprintf(stdout, "Network Interface List\n");
- 	for(n = ifhead_.lh_first; n; n = n->nextnode() )
-		n->dump();	
-	fprintf(stdout, "--------------------------------------------------\n");
-}
-
-/* ======================================================================
-   Position Functions
-   ====================================================================== */
-void 
-MobileNode::start()
-{
-	Scheduler& s = Scheduler::instance();
-
-	if(random_motion_ == 0) {
-		log_movement();
-		return;
-	}
-
-	assert(initialized());
-
-	random_position();
-#ifdef DEBUG
-        fprintf(stderr, "%d - %s: calling random_destination()\n",
-                address_, __PRETTY_FUNCTION__);
-#endif
-	random_destination();
-	s.schedule(&pos_handle_, &pos_intr_, position_update_interval_);
-}
-
-void 
-MobileNode::log_movement()
-{
-        if (!log_target_) 
-		return;
-
-	Scheduler& s = Scheduler::instance();
-	sprintf(log_target_->pt_->buffer(),
-		"M %.5f %d (%.2f, %.2f, %.2f), (%.2f, %.2f), %.2f",
-		s.clock(), address_, X_, Y_, Z_, destX_, destY_, speed_);
-	log_target_->pt_->dump();
-}
-
-
-void
-MobileNode::log_energy(int flag)
-{
-	if (!log_target_) 
-		return;
-	Scheduler &s = Scheduler::instance();
-	if (flag) {
-		sprintf(log_target_->pt_->buffer(),"N -t %f -n %d -e %f", s.clock(),
-			address_, energy_model_->energy()); 
-	} else {
-		sprintf(log_target_->pt_->buffer(),"N -t %f -n %d -e 0 ", s.clock(),
-			address_); 
-	}
-	log_target_->pt_->dump();
-}
-
-//void
-//MobileNode::logrttime(double t)
-//{
-//	last_rt_time_ = (int)t;
-//}
-
-void
-MobileNode::bound_position()
-{
-	double minX;
-	double maxX;
-	double minY;
-	double maxY;
-	int recheck = 1;
-
-	assert(T_ != 0);
-
-	minX = T_->lowerX();
-	maxX = T_->upperX();
-	minY = T_->lowerY();
-	maxY = T_->upperY();
-
-	while (recheck) {
-		recheck = 0;
-		if (X_ < minX) {
-			X_ = minX + (minX - X_);
-			recheck = 1;
-		}
-		if (X_ > maxX) {
-			X_ = maxX - (X_ - maxX);
-			recheck = 1;
-		}
-		if (Y_ < minY) {
-			Y_ = minY + (minY - Y_);
-			recheck = 1;
-		}
-		if (Y_ > maxY) {
-			Y_ = maxY- (Y_ - maxY);
-			recheck = 1;
-		}
-		if (recheck) {
-			fprintf(stderr, "Adjust position of node %d\n",address_);
-		}
-	}
-}
-
-int
-MobileNode::set_destination(double x, double y, double s)
-{
-	assert(initialized());
-
-	if(x >= T_->upperX() || x <= T_->lowerX())
-		return -1;
-	if(y >= T_->upperY() || y <= T_->lowerY())
-		return -1;
-	
-	update_position();	// figure out where we are now
-	
-	destX_ = x;
-	destY_ = y;
-	speed_ = s;
-	
-	dX_ = destX_ - X_;
-	dY_ = destY_ - Y_;
-	dZ_ = 0.0;		// this isn't used, since flying isn't allowed
-
-	double len;
-	
-	if (destX_ != X_ || destY_ != Y_) {
-		// normalize dx, dy to unit len
-		len = sqrt( (dX_ * dX_) + (dY_ * dY_) );
-		dX_ /= len;
-		dY_ /= len;
-	}
-  
-	position_update_time_ = Scheduler::instance().clock();
-
-#ifdef DEBUG
-	fprintf(stderr, "%d - %s: calling log_movement()\n", 
-		address_, __FUNCTION__);
-#endif
-	log_movement();
-
-	/* update gridkeeper */
-	if (GridKeeper::instance()){
-		GridKeeper* gp =  GridKeeper::instance();
-		gp-> new_moves(this);
-	}                     
-
-	if (namChan_ != 0) {
-		
-		double v = speed_ * sqrt( (dX_ * dX_) + (dY_ * dY_)); 
-		
-		sprintf(nwrk_,     
-			"n -t %f -s %d -x %f -y %f -U %f -V %f -T %f",
-			Scheduler::instance().clock(),
-			nodeid_,
-			X_, Y_,
-			speed_ * dX_, speed_ * dY_,
-			( v != 0) ? len / v : 0. );   
-		namdump();         
-	}
-	return 0;
-}
-
-
-
-void 
-MobileNode::update_position()
-{
-	double now = Scheduler::instance().clock();
-	double interval = now - position_update_time_;
-	double oldX = X_;
-	//double oldY = Y_;
-
-	if ((interval == 0.0)&&(position_update_time_!=0))
-		return;         // ^^^ for list-based imprvmnt 
-
-
-	// CHECK, IF THE SPEED IS 0, THEN SKIP, but usually it's not 0
-	X_ += dX_ * (speed_ * interval);
-	Y_ += dY_ * (speed_ * interval);
-
-	if ((dX_ > 0 && X_ > destX_) || (dX_ < 0 && X_ < destX_))
-	  X_ = destX_;		// correct overshoot (slow? XXX)
-	if ((dY_ > 0 && Y_ > destY_) || (dY_ < 0 && Y_ < destY_))
-	  Y_ = destY_;		// correct overshoot (slow? XXX)
-	
-	/* list based improvement */
-	if(oldX != X_)// || oldY != Y_)
-		T_->updateNodesList(this, oldX);//, oldY);
-	// COMMENTED BY -VAL- // bound_position();
-
-	// COMMENTED BY -VAL- // Z_ = T_->height(X_, Y_);
-
-#if 0
-	fprintf(stderr, "Node: %d, X: %6.2f, Y: %6.2f, Z: %6.2f, time: %f\n",
-		address_, X_, Y_, Z_, now);
-#endif
-	position_update_time_ = now;
-}
-
-
-void
-MobileNode::random_position()
-{
-	if (T_ == 0) {
-		fprintf(stderr, "No TOPOLOGY assigned\n");
-		exit(1);
-	}
-
-	X_ = Random::uniform() * T_->upperX();
-	Y_ = Random::uniform() * T_->upperY();
-	Z_ = T_->height(X_, Y_);
-
-	position_update_time_ = 0.0;
-}
-
-void
-MobileNode::random_destination()
-{
-	if (T_ == 0) {
-		fprintf(stderr, "No TOPOLOGY assigned\n");
-		exit(1);
-	}
-
-	random_speed();
-#ifdef DEBUG
-        fprintf(stderr, "%d - %s: calling set_destination()\n",
-                address_, __FUNCTION__);
-#endif
-	(void) set_destination(Random::uniform() * T_->upperX(),
-                               Random::uniform() * T_->upperY(),
-                               speed_);
-}
-
-void
-MobileNode::random_direction()
-{
-	/* this code isn't used anymore -dam 1/22/98 */
-	double len;
-
-	dX_ = (double) Random::random();
-	dY_ = (double) Random::random();
-
-	len = sqrt( (dX_ * dX_) + (dY_ * dY_) );
-
-	dX_ /= len;
-	dY_ /= len;
-	dZ_ = 0.0;				// we're not flying...
-
-	/*
-	 * Determine the sign of each component of the
-	 * direction vector.
-	 */
-	if (X_ > (T_->upperX() - 2*T_->resol())) {
-		if (dX_ > 0) 
-			dX_ = -dX_;
-	} else if (X_ < (T_->lowerX() + 2*T_->resol())) {
-		if (dX_ < 0) 
-			dX_ = -dX_;
-	} else if (Random::uniform() <= 0.5) {
-		dX_ = -dX_;
-	}
-
-	if (Y_ > (T_->upperY() - 2*T_->resol())) {
-		if (dY_ > 0) 
-			dY_ = -dY_;
-	} else if (Y_ < (T_->lowerY() + 2*T_->resol())) {
-		if (dY_ < 0) 
-			dY_ = -dY_;
-	} else if(Random::uniform() <= 0.5) {
-		dY_ = -dY_;
-	}
-#if 0
-	fprintf(stderr, "Location: (%f, %f), Direction: (%f, %f)\n",
-		X_, Y_, dX_, dY_);
-#endif
-}
-
-void
-MobileNode::random_speed()
-{
-	speed_ = Random::uniform() * MAX_SPEED;
-}
-
-double
-MobileNode::distance(MobileNode *m)
-{
-	update_position();		// update my position
-	m->update_position();		// update m's position
-
-        double Xpos = (X_ - m->X_) * (X_ - m->X_);
-        double Ypos = (Y_ - m->Y_) * (Y_ - m->Y_);
-	double Zpos = (Z_ - m->Z_) * (Z_ - m->Z_);
-
-        return sqrt(Xpos + Ypos + Zpos);
-}
-
-double
-MobileNode::propdelay(MobileNode *m)
-{
-	return distance(m) / SPEED_OF_LIGHT;
-}
-
-void 
-MobileNode::idle_energy_patch(float /*total*/, float /*P_idle*/)
-{
-}
+/*-*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- 
+ *
+ * Copyright (c) 1997 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $Header: /cvsroot/nsnam/ns-2/common/mobilenode.cc,v 1.36 2006/02/22 13:21:52 mahrenho Exp $
+ *
+ * Code in this file will be changed in the near future. From now on it 
+ * should be treated as for backward compatibility only, although it is in
+ * active use by many other code in ns. - Aug 29, 2000
+ */
+
+/* 
+ * CMU-Monarch project's Mobility extensions ported by Padma Haldar, 
+ * 11/98.
+ */
+
+
+#include <math.h>
+#include <stdlib.h>
+
+#include "connector.h"
+#include "delay.h"
+#include "packet.h"
+#include "random.h"
+#include "trace.h"
+#include "address.h"
+
+#include "arp.h"
+#include "topography.h"
+#include "ll.h"
+#include "mac.h"
+#include "propagation.h"
+#include "mobilenode.h"
+#include "phy.h"
+#include "wired-phy.h"
+#include "god.h"
+#include "../mac/mac-802_16/geographic.h"
+
+// XXX Must supply the first parameter in the macro otherwise msvc
+// is unhappy. 
+static LIST_HEAD(_dummy_MobileNodeList, MobileNode) nodehead = { 0 };
+
+static class MobileNodeClass : public TclClass {
+public:
+        MobileNodeClass() : TclClass("Node/MobileNode") {}
+        TclObject* create(int, const char*const*) {
+                return (new MobileNode);
+        }
+} class_mobilenode;
+
+/*
+ *  PositionHandler()
+ *
+ *  Updates the position of a mobile node every N seconds, where N is
+ *  based upon the speed of the mobile and the resolution of the topography.
+ *
+ */
+void
+PositionHandler::handle(Event*)
+{
+	Scheduler& s = Scheduler::instance();
+
+#if 0
+	fprintf(stderr, "*** POSITION HANDLER for node %d (time: %f) ***\n",
+		node->address(), s.clock());
+#endif
+	/*
+	 * Update current location
+	 */
+	node->update_position();
+
+	/*
+	 * Choose a new random speed and direction
+	 */
+#ifdef DEBUG
+        fprintf(stderr, "%d - %s: calling random_destination()\n",
+                node->address_, __PRETTY_FUNCTION__);
+#endif
+	node->random_destination();
+
+	s.schedule(&node->pos_handle_, &node->pos_intr_,
+		   node->position_update_interval_);
+}
+
+
+/* ======================================================================
+   Mobile Node
+   ====================================================================== */
+
+MobileNode::MobileNode(void) : 
+	pos_handle_(this)
+{
+	X_ = Y_ = Z_ = speed_ = 0.0;
+	dX_ = dY_ = dZ_ = 0.0;
+	destX_ = destY_ = 0.0;
+
+	random_motion_ = 0;
+	base_stn_ = -1;
+	T_ = 0;
+
+	log_target_ = 0;
+	next_ = 0;
+	radius_ = 0;
+
+	position_update_interval_ = MN_POSITION_UPDATE_INTERVAL;
+	position_update_time_ = 0.0;
+	
+
+	LIST_INSERT_HEAD(&nodehead, this, link_);	// node list
+	LIST_INIT(&ifhead_);				// interface list
+	bind("X_", &X_);
+	bind("Y_", &Y_);
+	bind("Z_", &Z_);
+	bind("speed_", &speed_);
+	update_position();
+	
+}
+
+int
+MobileNode::command(int argc, const char*const* argv)
+{
+	Tcl& tcl = Tcl::instance();
+	if(argc == 2) {
+		if(strcmp(argv[1], "start") == 0) {
+		        start();
+			return TCL_OK;
+		} else if(strcmp(argv[1], "log-movement") == 0) {
+#ifdef DEBUG
+                        fprintf(stderr,
+                                "%d - %s: calling update_position()\n",
+                                address_, __PRETTY_FUNCTION__);
+#endif
+		        update_position();
+		        log_movement();
+			return TCL_OK;
+		} else if(strcmp(argv[1], "log-energy") == 0) {
+			log_energy(1);
+			return TCL_OK;
+		} else if(strcmp(argv[1], "powersaving") == 0) {
+			energy_model()->powersavingflag() = 1;
+			energy_model()->start_powersaving();
+			return TCL_OK;
+		} else if(strcmp(argv[1], "adaptivefidelity") == 0) {
+			energy_model()->adaptivefidelity() = 1;
+			energy_model()->powersavingflag() = 1;
+			energy_model()->start_powersaving();
+			return TCL_OK;
+		} else if (strcmp(argv[1], "energy") == 0) {
+			Tcl& tcl = Tcl::instance();
+			tcl.resultf("%f", energy_model()->energy());
+			return TCL_OK;
+		} else if (strcmp(argv[1], "adjustenergy") == 0) {
+			// assume every 10 sec schedule and 1.15 W 
+			// idle energy consumption. needs to be
+			// parameterized.
+			idle_energy_patch(10, 1.15);
+			energy_model()->total_sndtime() = 0;
+			energy_model()->total_rcvtime() = 0;
+			energy_model()->total_sleeptime() = 0;
+			return TCL_OK;
+		} else if (strcmp(argv[1], "on") == 0) {
+			energy_model()->node_on() = true;
+			tcl.evalf("%s set netif_(0)", name_);
+			const char *str = tcl.result();
+			tcl.evalf("%s NodeOn", str);
+			God::instance()->ComputeRoute();
+			return TCL_OK;
+		} else if (strcmp(argv[1], "off") == 0) {
+			energy_model()->node_on() = false;
+			tcl.evalf("%s set netif_(0)", name_);
+			const char *str = tcl.result();
+			tcl.evalf("%s NodeOff", str);
+			tcl.evalf("%s set ragent_", name_);
+			str = tcl.result();
+			tcl.evalf("%s reset-state", str);
+			God::instance()->ComputeRoute();
+		     	return TCL_OK;
+		} else if (strcmp(argv[1], "shutdown") == 0) {
+			// set node state
+			//Phy *p;
+			energy_model()->node_on() = false;
+			
+			//p = ifhead().lh_first;
+			//if (p) ((WirelessPhy *)p)->node_off();
+			return TCL_OK;
+		} else if (strcmp(argv[1], "startup") == 0) {
+			energy_model()->node_on() = true;
+			return TCL_OK;
+		}
+	
+	} else if(argc == 3) {
+		if(strcmp(argv[1], "addif") == 0) {
+			WiredPhy* phyp = (WiredPhy*)TclObject::lookup(argv[2]);
+			if(phyp == 0)
+				return TCL_ERROR;
+			phyp->insertnode(&ifhead_);
+			phyp->setnode(this);
+			return TCL_OK;
+		} else if (strcmp(argv[1], "setsleeptime") == 0) {
+			energy_model()->afe()->set_sleeptime(atof(argv[2]));
+			energy_model()->afe()->set_sleepseed(atof(argv[2]));
+			return TCL_OK;
+		} else if (strcmp(argv[1], "setenergy") == 0) {
+			energy_model()->setenergy(atof(argv[2]));
+			return TCL_OK;
+		} else if (strcmp(argv[1], "settalive") == 0) {
+			energy_model()->max_inroute_time() = atof(argv[2]);
+			return TCL_OK;
+		} else if (strcmp(argv[1], "maxttl") == 0) {
+			energy_model()->maxttl() = atoi(argv[2]);
+			return TCL_OK;
+		} else if(strcmp(argv[1], "radius") == 0) {
+                        radius_ = strtod(argv[2],NULL);
+                        return TCL_OK;
+                } else if(strcmp(argv[1], "random-motion") == 0) {
+			random_motion_ = atoi(argv[2]);
+			return TCL_OK;
+		} else if(strcmp(argv[1], "addif") == 0) {
+			WirelessPhy *n = (WirelessPhy*)
+				TclObject::lookup(argv[2]);
+			if(n == 0)
+				return TCL_ERROR;
+			n->insertnode(&ifhead_);
+			n->setnode(this);
+			return TCL_OK;
+		} else if(strcmp(argv[1], "topography") == 0) {
+			T_ = (Topography*) TclObject::lookup(argv[2]);
+			if (T_ == 0)
+				return TCL_ERROR;
+			return TCL_OK;
+		} else if(strcmp(argv[1], "log-target") == 0) {
+			log_target_ = (Trace*) TclObject::lookup(argv[2]);
+			if (log_target_ == 0)
+				return TCL_ERROR;
+			return TCL_OK;
+		} else if (strcmp(argv[1],"base-station") == 0) {
+			base_stn_ = atoi(argv[2]);
+			if(base_stn_ == -1)
+				return TCL_ERROR;
+			return TCL_OK;
+		} 
+	} else if (argc == 4) {
+		if (strcmp(argv[1], "idleenergy") == 0) {
+			idle_energy_patch(atof(argv[2]),atof(argv[3]));
+			return TCL_OK;
+		}
+	} else if (argc == 5) {
+		if (strcmp(argv[1], "setdest") == 0) { 
+			/* <mobilenode> setdest <X> <Y> <speed> */
+#ifdef DEBUG
+			fprintf(stderr, "%d - %s: calling set_destination()\n",
+				address_, __FUNCTION__);
+#endif
+  
+			if (set_destination(atof(argv[2]), atof(argv[3]), 
+					    atof(argv[4])) < 0)
+				return TCL_ERROR;
+			return TCL_OK;
+		}
+	}
+	return Node::command(argc, argv);
+}
+
+
+/* ======================================================================
+   Other class functions
+   ====================================================================== */
+void
+MobileNode::dump(void)
+{
+	Phy *n;
+	fprintf(stdout, "Index: %d\n", address_);
+	fprintf(stdout, "Network Interface List\n");
+ 	for(n = ifhead_.lh_first; n; n = n->nextnode() )
+		n->dump();	
+	fprintf(stdout, "--------------------------------------------------\n");
+}
+
+/* ======================================================================
+   Position Functions
+   ====================================================================== */
+void 
+MobileNode::start()
+{
+	Scheduler& s = Scheduler::instance();
+
+	if(random_motion_ == 0) {
+		log_movement();
+		return;
+	}
+
+	assert(initialized());
+
+	random_position();
+#ifdef DEBUG
+        fprintf(stderr, "%d - %s: calling random_destination()\n",
+                address_, __PRETTY_FUNCTION__);
+#endif
+	random_destination();
+	s.schedule(&pos_handle_, &pos_intr_, position_update_interval_);
+}
+
+void 
+MobileNode::log_movement()
+{
+        if (!log_target_) 
+		return;
+
+	Scheduler& s = Scheduler::instance();
+	sprintf(log_target_->pt_->buffer(),
+		"M %.5f %d (%.2f, %.2f, %.2f), (%.2f, %.2f), %.2f",
+		s.clock(), address_, X_, Y_, Z_, destX_, destY_, speed_);
+	log_target_->pt_->dump();
+}
+
+
+void
+MobileNode::log_energy(int flag)
+{
+	if (!log_target_) 
+		return;
+	Scheduler &s = Scheduler::instance();
+	if (flag) {
+		sprintf(log_target_->pt_->buffer(),"N -t %f -n %d -e %f", s.clock(),
+			address_, energy_model_->energy()); 
+	} else {
+		sprintf(log_target_->pt_->buffer(),"N -t %f -n %d -e 0 ", s.clock(),
+			address_); 
+	}
+	log_target_->pt_->dump();
+}
+
+//void
+//MobileNode::logrttime(double t)
+//{
+//	last_rt_time_ = (int)t;
+//}
+
+void
+MobileNode::bound_position()
+{
+	double minX;
+	double maxX;
+	double minY;
+	double maxY;
+	int recheck = 1;
+
+	assert(T_ != 0);
+
+	minX = T_->lowerX();
+	maxX = T_->upperX();
+	minY = T_->lowerY();
+	maxY = T_->upperY();
+
+	while (recheck) {
+		recheck = 0;
+		if (X_ < minX) {
+			X_ = minX + (minX - X_);
+			recheck = 1;
+		}
+		if (X_ > maxX) {
+			X_ = maxX - (X_ - maxX);
+			recheck = 1;
+		}
+		if (Y_ < minY) {
+			Y_ = minY + (minY - Y_);
+			recheck = 1;
+		}
+		if (Y_ > maxY) {
+			Y_ = maxY- (Y_ - maxY);
+			recheck = 1;
+		}
+		if (recheck) {
+			fprintf(stderr, "Adjust position of node %d\n",address_);
+		}
+	}
+}
+
+int
+MobileNode::set_destination(double x, double y, double s)
+{
+	assert(initialized());
+
+	if(x >= T_->upperX() || x <= T_->lowerX())
+		return -1;
+	if(y >= T_->upperY() || y <= T_->lowerY())
+		return -1;
+	
+	update_position();	// figure out where we are now
+	
+	destX_ = x;
+	destY_ = y;
+	speed_ = s;
+	
+	dX_ = destX_ - X_;
+	dY_ = destY_ - Y_;
+	dZ_ = 0.0;		// this isn't used, since flying isn't allowed
+
+	double len;
+	
+	if (destX_ != X_ || destY_ != Y_) {
+		// normalize dx, dy to unit len
+		len = sqrt( (dX_ * dX_) + (dY_ * dY_) );
+		dX_ /= len;
+		dY_ /= len;
+	}
+  
+	position_update_time_ = Scheduler::instance().clock();
+
+#ifdef DEBUG
+	fprintf(stderr, "%d - %s: calling log_movement()\n", 
+		address_, __FUNCTION__);
+#endif
+	log_movement();
+
+	/* update gridkeeper */
+	if (GridKeeper::instance()){
+		GridKeeper* gp =  GridKeeper::instance();
+		gp-> new_moves(this);
+	}                     
+
+	if (namChan_ != 0) {
+		
+		double v = speed_ * sqrt( (dX_ * dX_) + (dY_ * dY_)); 
+		
+		sprintf(nwrk_,     
+			"n -t %f -s %d -x %f -y %f -U %f -V %f -T %f",
+			Scheduler::instance().clock(),
+			nodeid_,
+			X_, Y_,
+			speed_ * dX_, speed_ * dY_,
+			( v != 0) ? len / v : 0. );   
+		namdump();         
+	}
+	return 0;
+}
+
+
+TOMAC *CalMod=new TOMAC;
+void 
+MobileNode::update_position()
+{
+	double now = Scheduler::instance().clock();
+	double interval = now - position_update_time_;
+	double oldX = X_;
+	//double oldY = Y_;
+
+	if ((interval == 0.0)&&(position_update_time_!=0))
+		return;         // ^^^ for list-based imprvmnt 
+
+
+	// CHECK, IF THE SPEED IS 0, THEN SKIP, but usually it's not 0
+	X_ += dX_ * (speed_ * interval);
+	Y_ += dY_ * (speed_ * interval);
+
+	if ((dX_ > 0 && X_ > destX_) || (dX_ < 0 && X_ < destX_))
+	  X_ = destX_;		// correct overshoot (slow? XXX)
+	if ((dY_ > 0 && Y_ > destY_) || (dY_ < 0 && Y_ < destY_))
+	  Y_ = destY_;		// correct overshoot (slow? XXX)
+	
+	/* list based improvement */
+	if(oldX != X_)// || oldY != Y_)
+		T_->updateNodesList(this, oldX);//, oldY);
+	// COMMENTED BY -VAL- // bound_position();
+
+	// COMMENTED BY -VAL- // Z_ = T_->height(X_, Y_);
+	if(CalMod->check(nodeid())==2)	goto Jump_;
+	else if(CalMod->check(nodeid())==0)
+	{	 
+		CalMod->enque(nodeid(),X_,Y_);
+		CalMod->unlock(nodeid());			
+	} 		
+Jump_:
+
+#if 0
+	fprintf(stderr, "Node: %d, X: %6.2f, Y: %6.2f, Z: %6.2f, time: %f\n",
+		address_, X_, Y_, Z_, now);
+#endif
+	position_update_time_ = now;
+}
+
+
+void
+MobileNode::random_position()
+{
+	if (T_ == 0) {
+		fprintf(stderr, "No TOPOLOGY assigned\n");
+		exit(1);
+	}
+
+	X_ = Random::uniform() * T_->upperX();
+	Y_ = Random::uniform() * T_->upperY();
+	Z_ = T_->height(X_, Y_);
+
+	position_update_time_ = 0.0;
+}
+
+void
+MobileNode::random_destination()
+{
+	if (T_ == 0) {
+		fprintf(stderr, "No TOPOLOGY assigned\n");
+		exit(1);
+	}
+
+	random_speed();
+#ifdef DEBUG
+        fprintf(stderr, "%d - %s: calling set_destination()\n",
+                address_, __FUNCTION__);
+#endif
+	(void) set_destination(Random::uniform() * T_->upperX(),
+                               Random::uniform() * T_->upperY(),
+                               speed_);
+}
+
+void
+MobileNode::random_direction()
+{
+	/* this code isn't used anymore -dam 1/22/98 */
+	double len;
+
+	dX_ = (double) Random::random();
+	dY_ = (double) Random::random();
+
+	len = sqrt( (dX_ * dX_) + (dY_ * dY_) );
+
+	dX_ /= len;
+	dY_ /= len;
+	dZ_ = 0.0;				// we're not flying...
+
+	/*
+	 * Determine the sign of each component of the
+	 * direction vector.
+	 */
+	if (X_ > (T_->upperX() - 2*T_->resol())) {
+		if (dX_ > 0) 
+			dX_ = -dX_;
+	} else if (X_ < (T_->lowerX() + 2*T_->resol())) {
+		if (dX_ < 0) 
+			dX_ = -dX_;
+	} else if (Random::uniform() <= 0.5) {
+		dX_ = -dX_;
+	}
+
+	if (Y_ > (T_->upperY() - 2*T_->resol())) {
+		if (dY_ > 0) 
+			dY_ = -dY_;
+	} else if (Y_ < (T_->lowerY() + 2*T_->resol())) {
+		if (dY_ < 0) 
+			dY_ = -dY_;
+	} else if(Random::uniform() <= 0.5) {
+		dY_ = -dY_;
+	}
+#if 0
+	fprintf(stderr, "Location: (%f, %f), Direction: (%f, %f)\n",
+		X_, Y_, dX_, dY_);
+#endif
+}
+
+void
+MobileNode::random_speed()
+{
+	speed_ = Random::uniform() * MAX_SPEED;
+}
+
+double
+MobileNode::distance(MobileNode *m)
+{
+	update_position();		// update my position
+	m->update_position();		// update m's position
+
+        double Xpos = (X_ - m->X_) * (X_ - m->X_);
+        double Ypos = (Y_ - m->Y_) * (Y_ - m->Y_);
+	double Zpos = (Z_ - m->Z_) * (Z_ - m->Z_);
+
+        return sqrt(Xpos + Ypos + Zpos);
+}
+
+double
+MobileNode::propdelay(MobileNode *m)
+{
+	return distance(m) / SPEED_OF_LIGHT;
+}
+
+void 
+MobileNode::idle_energy_patch(float /*total*/, float /*P_idle*/)
+{
+}
diff -u -r -N ns-2.34.original/common/packet.h ns-2.34/common/packet.h
--- ns-2.34.original/common/packet.h	2009-06-15 01:35:44.000000000 +0800
+++ ns-2.34/common/packet.h	2012-08-08 15:34:51.999500000 +0800
@@ -1,767 +1,807 @@
-/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
-/*
- * Copyright (c) 1997 Regents of the University of California.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the Computer Systems
- *	Engineering Group at Lawrence Berkeley Laboratory.
- * 4. Neither the name of the University nor of the Laboratory may be used
- *    to endorse or promote products derived from this software without
- *    specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * @(#) $Header: /cvsroot/nsnam/ns-2/common/packet.h,v 1.103 2009/01/15 06:23:49 tom_henderson Exp $ (LBL)
- */
-
-#ifndef ns_packet_h
-#define ns_packet_h
-
-#include <string.h>
-#include <assert.h>
-
-#include "config.h"
-#include "scheduler.h"
-#include "object.h"
-#include "lib/bsd-list.h"
-#include "packet-stamp.h"
-#include "ns-process.h"
-
-// Used by wireless routing code to attach routing agent
-#define RT_PORT		255	/* port that all route msgs are sent to */
-
-#define HDR_CMN(p)      (hdr_cmn::access(p))
-#define HDR_ARP(p)      (hdr_arp::access(p))
-#define HDR_MAC(p)      (hdr_mac::access(p))
-#define HDR_MAC802_11(p) ((hdr_mac802_11 *)hdr_mac::access(p))
-#define HDR_MAC_TDMA(p) ((hdr_mac_tdma *)hdr_mac::access(p))
-#define HDR_SMAC(p)     ((hdr_smac *)hdr_mac::access(p))
-#define HDR_LL(p)       (hdr_ll::access(p))
-#define HDR_HDLC(p)     ((hdr_hdlc *)hdr_ll::access(p))
-#define HDR_IP(p)       (hdr_ip::access(p))
-#define HDR_RTP(p)      (hdr_rtp::access(p))
-#define HDR_TCP(p)      (hdr_tcp::access(p))
-#define HDR_SCTP(p)     (hdr_sctp::access(p))
-#define HDR_SR(p)       (hdr_sr::access(p))
-#define HDR_TFRC(p)     (hdr_tfrc::access(p))
-#define HDR_TORA(p)     (hdr_tora::access(p))
-#define HDR_IMEP(p)     (hdr_imep::access(p))
-#define HDR_CDIFF(p)    (hdr_cdiff::access(p))  /* chalermak's diffusion*/
-//#define HDR_DIFF(p)     (hdr_diff::access(p))  /* SCADD's diffusion ported into ns */
-#define HDR_LMS(p)		(hdr_lms::access(p))
-
-/* --------------------------------------------------------------------*/
-
-/*
- * modified ns-2.33, adding support for dynamic libraries
- * 
- * packet_t is changed from enum to unsigned int in order to allow
- * dynamic definition of  new packet types within dynamic libraries.
- * Pre-defined packet types are implemented as static const.
- * 
- */
-
-typedef unsigned int packet_t;
-
-static const packet_t PT_TCP = 0;
-static const packet_t PT_UDP = 1;
-static const packet_t PT_CBR = 2;
-static const packet_t PT_AUDIO = 3;
-static const packet_t PT_VIDEO = 4;
-static const packet_t PT_ACK = 5;
-static const packet_t PT_START = 6;
-static const packet_t PT_STOP = 7;
-static const packet_t PT_PRUNE = 8;
-static const packet_t PT_GRAFT = 9;
-static const packet_t PT_GRAFTACK = 10;
-static const packet_t PT_JOIN = 11;
-static const packet_t PT_ASSERT = 12;
-static const packet_t PT_MESSAGE = 13;
-static const packet_t PT_RTCP = 14;
-static const packet_t PT_RTP = 15;
-static const packet_t PT_RTPROTO_DV = 16;
-static const packet_t PT_CtrMcast_Encap = 17;
-static const packet_t PT_CtrMcast_Decap = 18;
-static const packet_t PT_SRM = 19;
-        /* simple signalling messages */
-static const packet_t PT_REQUEST = 20;
-static const packet_t PT_ACCEPT = 21;
-static const packet_t PT_CONFIRM = 22;
-static const packet_t PT_TEARDOWN = 23;
-static const packet_t PT_LIVE = 24;   // packet from live network
-static const packet_t PT_REJECT = 25;
-
-static const packet_t PT_TELNET = 26; // not needed: telnet use TCP
-static const packet_t PT_FTP = 27;
-static const packet_t PT_PARETO = 28;
-static const packet_t PT_EXP = 29;
-static const packet_t PT_INVAL = 30;
-static const packet_t PT_HTTP = 31;
-
-        /* new encapsulator */
-static const packet_t PT_ENCAPSULATED = 32;
-static const packet_t PT_MFTP = 33;
-
-        /* CMU/Monarch's extnsions */
-static const packet_t PT_ARP = 34;
-static const packet_t PT_MAC = 35;
-static const packet_t PT_TORA = 36;
-static const packet_t PT_DSR = 37;
-static const packet_t PT_AODV = 38;
-static const packet_t PT_IMEP = 39;
-        
-        // RAP packets
-static const packet_t PT_RAP_DATA = 40;
-static const packet_t PT_RAP_ACK = 41;
-  
-static const packet_t PT_TFRC = 42;
-static const packet_t PT_TFRC_ACK = 43;
-static const packet_t PT_PING = 44;
-        
-static const packet_t PT_PBC = 45;
-        // Diffusion packets - Chalermek
-static const packet_t PT_DIFF = 46;
-        
-        // LinkState routing update packets
-static const packet_t PT_RTPROTO_LS = 47;
-        
-        // MPLS LDP header
-static const packet_t PT_LDP = 48;
-        
-        // GAF packet
-static const packet_t PT_GAF = 49;
-        
-        // ReadAudio traffic
-static const packet_t PT_REALAUDIO = 50;
-        
-        // Pushback Messages
-static const packet_t PT_PUSHBACK = 51;
-  
-  #ifdef HAVE_STL
-        // Pragmatic General Multicast
-static const packet_t PT_PGM = 52;
-  #endif //STL
-        // LMS packets
-static const packet_t PT_LMS = 53;
-static const packet_t PT_LMS_SETUP = 54;
-
-static const packet_t PT_SCTP = 55;
-static const packet_t PT_SCTP_APP1 = 56;
-
-        // SMAC packet
-static const packet_t PT_SMAC = 57;
-        // XCP packet
-static const packet_t PT_XCP = 58;
-
-        // HDLC packet
-static const packet_t PT_HDLC = 59;
-
-        // Bell Labs Traffic Trace Type (PackMime OL)
-static const packet_t PT_BLTRACE = 60;
-
-	// AOMDV packet
-static const packet_t PT_AOMDV = 61;
-
-        // insert new packet types here
-static packet_t       PT_NTYPE = 62; // This MUST be the LAST one
-
-enum packetClass
-{
-	UNCLASSIFIED,
-	ROUTING,
-	DATApkt
-  };
-
-
-/*
- * ns-2.33 adding support for dynamic libraries
- * 
- * The PacketClassifier class is needed to make
- * p_info::data_packet(packet_t) work also with dynamically defined
- * packet types.
- * 
- */
-class PacketClassifier
-{
-	public:
-		PacketClassifier(): next_(0){}
-		virtual ~PacketClassifier() {}
-		void setNext(PacketClassifier *next){next_ = next;}
-		PacketClassifier *getNext(){return next_;}
-		packetClass classify(packet_t type) 
-		{
-		        packetClass c = getClass(type);
-		        if(c == UNCLASSIFIED && next_)
-		                c = next_->classify(type);
-		        return c;
-		}
-
-	protected:
-		//return 0 if the packet is unknown
-		virtual packetClass getClass(packet_t type) = 0;        
-		PacketClassifier *next_;
-};
-
-class p_info {
-public:
-	p_info()
-	{
-		initName();
-	}
-	const char* name(packet_t p) const { 
-		if ( p <= p_info::nPkt_ ) return name_[p];
-		return 0;
-	}
-	static bool data_packet(packet_t type) {
-		return ( (type) == PT_TCP || \
-		         (type) == PT_TELNET || \
-		         (type) == PT_CBR || \
-		         (type) == PT_AUDIO || \
-		         (type) == PT_VIDEO || \
-		         (type) == PT_ACK || \
-		         (type) == PT_SCTP || \
-		         (type) == PT_SCTP_APP1 || \
-		         (type) == PT_HDLC \
-		        );
-	}
-	static packetClass classify(packet_t type) {		
-		if (type == PT_DSR || 
-		    type == PT_MESSAGE || 
-		    type == PT_TORA || 
-		    type == PT_AODV)
-			return ROUTING;		
-		if (type == PT_TCP || 
-		    type == PT_TELNET || 
-		    type == PT_CBR || 
-		    type == PT_AUDIO || 
-		    type == PT_VIDEO || 
-		    type == PT_ACK || 
-		    type == PT_SCTP || 
-		    type == PT_SCTP_APP1 || 
-		    type == PT_HDLC)
-			return DATApkt;
-		if (pc_)
-			return pc_->classify(type);
-		return UNCLASSIFIED;
-	}
-	static void addPacketClassifier(PacketClassifier *pc)
-	{
-		if(!pc)
-		        return;
-		pc->setNext(pc_);
-		pc_ = pc;
-	}       
-	static void initName()
-	{
-		if(nPkt_ >= PT_NTYPE+1)
-		        return;
-		char **nameNew = new char*[PT_NTYPE+1];
-		for(unsigned int i = (unsigned int)PT_SMAC+1; i < nPkt_; i++)
-		{
-		        nameNew[i] = name_[i];
-		}
-		if(!nPkt_)
-		        delete [] name_;
-		name_ = nameNew;
-		nPkt_ = PT_NTYPE+1;
-		
-
-		name_[PT_TCP]= "tcp";
-		name_[PT_UDP]= "udp";
-		name_[PT_CBR]= "cbr";
-		name_[PT_AUDIO]= "audio";
-		name_[PT_VIDEO]= "video";
-		name_[PT_ACK]= "ack";
-		name_[PT_START]= "start";
-		name_[PT_STOP]= "stop";
-		name_[PT_PRUNE]= "prune";
-		name_[PT_GRAFT]= "graft";
-		name_[PT_GRAFTACK]= "graftAck";
-		name_[PT_JOIN]= "join";
-		name_[PT_ASSERT]= "assert";
-		name_[PT_MESSAGE]= "message";
-		name_[PT_RTCP]= "rtcp";
-		name_[PT_RTP]= "rtp";
-		name_[PT_RTPROTO_DV]= "rtProtoDV";
-		name_[PT_CtrMcast_Encap]= "CtrMcast_Encap";
-		name_[PT_CtrMcast_Decap]= "CtrMcast_Decap";
-		name_[PT_SRM]= "SRM";
-	
-		name_[PT_REQUEST]= "sa_req";	
-		name_[PT_ACCEPT]= "sa_accept";
-		name_[PT_CONFIRM]= "sa_conf";
-		name_[PT_TEARDOWN]= "sa_teardown";
-		name_[PT_LIVE]= "live"; 
-		name_[PT_REJECT]= "sa_reject";
-	
-		name_[PT_TELNET]= "telnet";
-		name_[PT_FTP]= "ftp";
-		name_[PT_PARETO]= "pareto";
-		name_[PT_EXP]= "exp";
-		name_[PT_INVAL]= "httpInval";
-		name_[PT_HTTP]= "http";
-		name_[PT_ENCAPSULATED]= "encap";
-		name_[PT_MFTP]= "mftp";
-		name_[PT_ARP]= "ARP";
-		name_[PT_MAC]= "MAC";
-		name_[PT_TORA]= "TORA";
-		name_[PT_DSR]= "DSR";
-		name_[PT_AODV]= "AODV";
-		name_[PT_IMEP]= "IMEP";
-
-		name_[PT_RAP_DATA] = "rap_data";
-		name_[PT_RAP_ACK] = "rap_ack";
-
- 		name_[PT_TFRC]= "tcpFriend";
-		name_[PT_TFRC_ACK]= "tcpFriendCtl";
-		name_[PT_PING]="ping";
-	
-		name_[PT_PBC] = "PBC";
-
-	 	/* For diffusion : Chalermek */
- 		name_[PT_DIFF] = "diffusion";
-
-		// Link state routing updates
-		name_[PT_RTPROTO_LS] = "rtProtoLS";
-
-		// MPLS LDP packets
-		name_[PT_LDP] = "LDP";
-
-		// for GAF
-                name_[PT_GAF] = "gaf";      
-
-		// RealAudio packets
-		name_[PT_REALAUDIO] = "ra";
-
-		//pushback 
-		name_[PT_PUSHBACK] = "pushback";
-
-#ifdef HAVE_STL
-		// for PGM
-		name_[PT_PGM] = "PGM";
-#endif //STL
-
-		// LMS entries
-		name_[PT_LMS]="LMS";
-		name_[PT_LMS_SETUP]="LMS_SETUP";
-
-		name_[PT_SCTP]= "sctp";
- 		name_[PT_SCTP_APP1] = "sctp_app1";
-		
-		// smac
-		name_[PT_SMAC]="smac";
-
-		// HDLC
-		name_[PT_HDLC]="HDLC";
-
-		// XCP
-		name_[PT_XCP]="xcp";
-
-		// Bell Labs (PackMime OL)
-		name_[PT_BLTRACE]="BellLabsTrace";
-		
-		// AOMDV patch
-		name_[PT_AOMDV]= "AOMDV";
-
-		name_[PT_NTYPE]= "undefined";
-	}
-	static int addPacket(char *name);
-	static packet_t getType(const char *name)
-	{
-		for(unsigned int i = 0; i < nPkt_; i++)
-		{
-		        if(strcmp(name, name_[i]) == 0)
-		                return i;
-		}
-		return PT_NTYPE;
-
-	}
-private:
-	static char** name_;
-	static unsigned int nPkt_;
-	static PacketClassifier *pc_;
-};
-extern p_info packet_info; /* map PT_* to string name */
-//extern char* p_info::name_[];
-
-#define DATA_PACKET(type) ( (type) == PT_TCP || \
-                            (type) == PT_TELNET || \
-                            (type) == PT_CBR || \
-                            (type) == PT_AUDIO || \
-                            (type) == PT_VIDEO || \
-                            (type) == PT_ACK || \
-                            (type) == PT_SCTP || \
-                            (type) == PT_SCTP_APP1 \
-                            )
-
-//#define OFFSET(type, field)	((long) &((type *)0)->field)
-#define OFFSET(type, field) ( (char *)&( ((type *)256)->field )  - (char *)256)
-
-class PacketData : public AppData {
-public:
-	PacketData(int sz) : AppData(PACKET_DATA) {
-		datalen_ = sz;
-		if (datalen_ > 0)
-			data_ = new unsigned char[datalen_];
-		else
-			data_ = NULL;
-	}
-	PacketData(PacketData& d) : AppData(d) {
-		datalen_ = d.datalen_;
-		if (datalen_ > 0) {
-			data_ = new unsigned char[datalen_];
-			memcpy(data_, d.data_, datalen_);
-		} else
-			data_ = NULL;
-	}
-	virtual ~PacketData() { 
-		if (data_ != NULL) 
-			delete []data_; 
-	}
-	unsigned char* data() { return data_; }
-
-	virtual int size() const { return datalen_; }
-	virtual AppData* copy() { return new PacketData(*this); }
-private:
-	unsigned char* data_;
-	int datalen_;
-};
-
-//Monarch ext
-typedef void (*FailureCallback)(Packet *,void *);
-
-class Packet : public Event {
-private:
-	unsigned char* bits_;	// header bits
-//	unsigned char* data_;	// variable size buffer for 'data'
-//  	unsigned int datalen_;	// length of variable size buffer
-	AppData* data_;		// variable size buffer for 'data'
-	static void init(Packet*);     // initialize pkt hdr 
-	bool fflag_;
-protected:
-	static Packet* free_;	// packet free list
-	int	ref_count_;	// free the pkt until count to 0
-public:
-	Packet* next_;		// for queues and the free list
-	static int hdrlen_;
-
-	Packet() : bits_(0), data_(0), ref_count_(0), next_(0) { }
-	inline unsigned char* const bits() { return (bits_); }
-	inline Packet* copy() const;
-	inline Packet* refcopy() { ++ref_count_; return this; }
-	inline int& ref_count() { return (ref_count_); }
-	static inline Packet* alloc();
-	static inline Packet* alloc(int);
-	inline void allocdata(int);
-	// dirty hack for diffusion data
-	inline void initdata() { data_  = 0;}
-	static inline void free(Packet*);
-	inline unsigned char* access(int off) const {
-		if (off < 0)
-			abort();
-		return (&bits_[off]);
-	}
-	// This is used for backward compatibility, i.e., assuming user data
-	// is PacketData and return its pointer.
-	inline unsigned char* accessdata() const { 
-		if (data_ == 0)
-			return 0;
-		assert(data_->type() == PACKET_DATA);
-		return (((PacketData*)data_)->data()); 
-	}
-	// This is used to access application-specific data, not limited 
-	// to PacketData.
-	inline AppData* userdata() const {
-		return data_;
-	}
-	inline void setdata(AppData* d) { 
-		if (data_ != NULL)
-			delete data_;
-		data_ = d; 
-	}
-	inline int datalen() const { return data_ ? data_->size() : 0; }
-
-	// Monarch extn
-
-	static void dump_header(Packet *p, int offset, int length);
-
-	// the pkt stamp carries all info about how/where the pkt
-        // was sent needed for a receiver to determine if it correctly
-        // receives the pkt
-        PacketStamp	txinfo_;  
-
-	/*
-         * According to cmu code:
-	 * This flag is set by the MAC layer on an incoming packet
-         * and is cleared by the link layer.  It is an ugly hack, but
-         * there's really no other way because NS always calls
-         * the recv() function of an object.
-	 * 
-         */
-        u_int8_t        incoming;
-
-	//monarch extns end;
-};
-
-/* 
- * static constant associations between interface special (negative) 
- * values and their c-string representations that are used from tcl
- */
-class iface_literal {
-public:
-	enum iface_constant { 
-		UNKN_IFACE= -1, /* 
-				 * iface value for locally originated packets 
-				 */
-		ANY_IFACE= -2   /* 
-				 * hashnode with iif == ANY_IFACE_   
-				 * matches any pkt iface (imported from TCL);
-				 * this value should be different from 
-				 * hdr_cmn::UNKN_IFACE (packet.h)
-				 */ 
-	};
-	iface_literal(const iface_constant i, const char * const n) : 
-		value_(i), name_(n) {}
-	inline int value() const { return value_; }
-	inline const char * const name() const { return name_; }
-private:
-	const iface_constant value_;
-	/* strings used in TCL to access those special values */
-	const char * const name_; 
-};
-
-static const iface_literal UNKN_IFACE(iface_literal::UNKN_IFACE, "?");
-static const iface_literal ANY_IFACE(iface_literal::ANY_IFACE, "*");
-
-/*
- * Note that NS_AF_* doesn't necessarily correspond with
- * the constants used in your system (because many
- * systems don't have NONE or ILINK).
- */
-enum ns_af_enum { NS_AF_NONE, NS_AF_ILINK, NS_AF_INET };
-
-enum ModulationScheme {BPSK = 0, QPSK = 1, QAM16 = 2, QAM64 = 3};
-
-struct hdr_cmn {
-	enum dir_t { DOWN= -1, NONE= 0, UP= 1 };
-	packet_t ptype_;	// packet type (see above)
-	int	size_;		// simulated packet size
-	int	uid_;		// unique id
-	int	error_;		// error flag
-	int     errbitcnt_;     // # of corrupted bits jahn
-	int     fecsize_;
-	double	ts_;		// timestamp: for q-delay measurement
-	int	iface_;		// receiving interface (label)
-	dir_t	direction_;	// direction: 0=none, 1=up, -1=down
-	// source routing 
-        char src_rt_valid;
-	double ts_arr_; // Required by Marker of JOBS 
-
-	//Monarch extn begins
-	nsaddr_t prev_hop_;     // IP addr of forwarding hop
-	nsaddr_t next_hop_;	// next hop for this packet
-	int      addr_type_;    // type of next_hop_ addr
-	nsaddr_t last_hop_;     // for tracing on multi-user channels
-	
-	// AOMDV patch
-	int aomdv_salvage_count_;
-	
-        // called if pkt can't obtain media or isn't ack'd. not called if
-        // droped by a queue
-        FailureCallback xmit_failure_; 
-        void *xmit_failure_data_;
-
-        /*
-         * MONARCH wants to know if the MAC layer is passing this back because
-         * it could not get the RTS through or because it did not receive
-         * an ACK.
-         */
-        int     xmit_reason_;
-#define XMIT_REASON_RTS 0x01
-#define XMIT_REASON_ACK 0x02
-
-        // filled in by GOD on first transmission, used for trace analysis
-        int num_forwards_;	// how many times this pkt was forwarded
-        int opt_num_forwards_;   // optimal #forwards
-	// Monarch extn ends;
-
-	// tx time for this packet in sec
-	double txtime_;
-	inline double& txtime() { return(txtime_); }
-
-	static int offset_;	// offset for this header
-	inline static int& offset() { return offset_; }
-	inline static hdr_cmn* access(const Packet* p) {
-		return (hdr_cmn*) p->access(offset_);
-	}
-	
-        /* per-field member functions */
-	inline packet_t& ptype() { return (ptype_); }
-	inline int& size() { return (size_); }
-	inline int& uid() { return (uid_); }
-	inline int& error() { return error_; }
-	inline int& errbitcnt() {return errbitcnt_; }
-	inline int& fecsize() {return fecsize_; }
-	inline double& timestamp() { return (ts_); }
-	inline int& iface() { return (iface_); }
-	inline dir_t& direction() { return (direction_); }
-	// monarch_begin
-	inline nsaddr_t& next_hop() { return (next_hop_); }
-	inline int& addr_type() { return (addr_type_); }
-	inline int& num_forwards() { return (num_forwards_); }
-	inline int& opt_num_forwards() { return (opt_num_forwards_); }
-        //monarch_end
-
-	ModulationScheme mod_scheme_;
-	inline ModulationScheme& mod_scheme() { return (mod_scheme_); }
-};
-
-
-class PacketHeaderClass : public TclClass {
-protected:
-	PacketHeaderClass(const char* classname, int hdrsize);
-	virtual int method(int argc, const char*const* argv);
-	void field_offset(const char* fieldname, int offset);
-	inline void bind_offset(int* off) { offset_ = off; }
-	inline void offset(int* off) {offset_= off;}
-	int hdrlen_;		// # of bytes for this header
-	int* offset_;		// offset for this header
-public:
-	virtual void bind();
-	virtual void export_offsets();
-	TclObject* create(int argc, const char*const* argv);
-};
-
-
-inline void Packet::init(Packet* p)
-{
-	bzero(p->bits_, hdrlen_);
-}
-
-inline Packet* Packet::alloc()
-{
-	Packet* p = free_;
-	if (p != 0) {
-		assert(p->fflag_ == FALSE);
-		free_ = p->next_;
-		assert(p->data_ == 0);
-		p->uid_ = 0;
-		p->time_ = 0;
-	} else {
-		p = new Packet;
-		p->bits_ = new unsigned char[hdrlen_];
-		if (p == 0 || p->bits_ == 0)
-			abort();
-	}
-	init(p); // Initialize bits_[]
-	(HDR_CMN(p))->next_hop_ = -2; // -1 reserved for IP_BROADCAST
-	(HDR_CMN(p))->last_hop_ = -2; // -1 reserved for IP_BROADCAST
-	p->fflag_ = TRUE;
-	(HDR_CMN(p))->direction() = hdr_cmn::DOWN;
-	/* setting all direction of pkts to be downward as default; 
-	   until channel changes it to +1 (upward) */
-	p->next_ = 0;
-	return (p);
-}
-
-/* 
- * Allocate an n byte data buffer to an existing packet 
- * 
- * To set application-specific AppData, use Packet::setdata()
- */
-inline void Packet::allocdata(int n)
-{
-	assert(data_ == 0);
-	data_ = new PacketData(n);
-	if (data_ == 0)
-		abort();
-}
-
-/* allocate a packet with an n byte data buffer */
-inline Packet* Packet::alloc(int n)
-{
-	Packet* p = alloc();
-	if (n > 0) 
-		p->allocdata(n);
-	return (p);
-}
-
-
-inline void Packet::free(Packet* p)
-{
-	if (p->fflag_) {
-		if (p->ref_count_ == 0) {
-			/*
-			 * A packet's uid may be < 0 (out of a event queue), or
-			 * == 0 (newed but never gets into the event queue.
-			 */
-			assert(p->uid_ <= 0);
-			// Delete user data because we won't need it any more.
-			if (p->data_ != 0) {
-				delete p->data_;
-				p->data_ = 0;
-			}
-			init(p);
-			p->next_ = free_;
-			free_ = p;
-			p->fflag_ = FALSE;
-		} else {
-			--p->ref_count_;
-		}
-	}
-}
-
-inline Packet* Packet::copy() const
-{
-	
-	Packet* p = alloc();
-	memcpy(p->bits(), bits_, hdrlen_);
-	if (data_) 
-		p->data_ = data_->copy();
-	p->txinfo_.init(&txinfo_);
- 
-	return (p);
-}
-
-inline void
-Packet::dump_header(Packet *p, int offset, int length)
-{
-        assert(offset + length <= p->hdrlen_);
-        struct hdr_cmn *ch = HDR_CMN(p);
-
-        fprintf(stderr, "\nPacket ID: %d\n", ch->uid());
-
-        for(int i = 0; i < length ; i+=16) {
-                fprintf(stderr, "%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
-                        p->bits_[offset + i],     p->bits_[offset + i + 1],
-                        p->bits_[offset + i + 2], p->bits_[offset + i + 3],
-                        p->bits_[offset + i + 4], p->bits_[offset + i + 5],
-                        p->bits_[offset + i + 6], p->bits_[offset + i + 7],
-                        p->bits_[offset + i + 8], p->bits_[offset + i + 9],
-                        p->bits_[offset + i + 10], p->bits_[offset + i + 11],
-                        p->bits_[offset + i + 12], p->bits_[offset + i + 13],
-                        p->bits_[offset + i + 14], p->bits_[offset + i + 15]);
-        }
-}
-
-#endif
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/*
+ * Copyright (c) 1997 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the Computer Systems
+ *	Engineering Group at Lawrence Berkeley Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * @(#) $Header: /cvsroot/nsnam/ns-2/common/packet.h,v 1.103 2009/01/15 06:23:49 tom_henderson Exp $ (LBL)
+ */
+
+#ifndef ns_packet_h
+#define ns_packet_h
+
+#include <string.h>
+#include <assert.h>
+
+#include "config.h"
+#include "scheduler.h"
+#include "object.h"
+#include "lib/bsd-list.h"
+#include "packet-stamp.h"
+#include "ns-process.h"
+
+// Used by wireless routing code to attach routing agent
+#define RT_PORT		255	/* port that all route msgs are sent to */
+
+#define HDR_CMN(p)      (hdr_cmn::access(p))
+#define HDR_ARP(p)      (hdr_arp::access(p))
+#define HDR_MAC(p)      (hdr_mac::access(p))
+#define HDR_MAC802_11(p) ((hdr_mac802_11 *)hdr_mac::access(p))
+#define HDR_MAC802_16(p) ((hdr_mac802_16 *)hdr_mac802_16::access(p))
+#define SUBHDR_Pack(p) ((subhdr_pack*)subhdr_pack::access(p))
+#define SUBHDR_Frag(p) ((subhdr_frag*)subhdr_frag::access(p))
+#define HDR_MAC_TDMA(p) ((hdr_mac_tdma *)hdr_mac::access(p))
+#define HDR_SMAC(p)     ((hdr_smac *)hdr_mac::access(p))
+#define HDR_LL(p)       (hdr_ll::access(p))
+#define HDR_HDLC(p)     ((hdr_hdlc *)hdr_ll::access(p))
+#define HDR_IP(p)       (hdr_ip::access(p))
+#define HDR_RTP(p)      (hdr_rtp::access(p))
+#define HDR_TCP(p)      (hdr_tcp::access(p))
+#define HDR_SCTP(p)     (hdr_sctp::access(p))
+#define HDR_SR(p)       (hdr_sr::access(p))
+#define HDR_TFRC(p)     (hdr_tfrc::access(p))
+#define HDR_TORA(p)     (hdr_tora::access(p))
+#define HDR_IMEP(p)     (hdr_imep::access(p))
+#define HDR_CDIFF(p)    (hdr_cdiff::access(p))  /* chalermak's diffusion*/
+//#define HDR_DIFF(p)     (hdr_diff::access(p))  /* SCADD's diffusion ported into ns */
+#define HDR_LMS(p)		(hdr_lms::access(p))
+
+/* --------------------------------------------------------------------*/
+
+/*
+ * modified ns-2.33, adding support for dynamic libraries
+ * 
+ * packet_t is changed from enum to unsigned int in order to allow
+ * dynamic definition of  new packet types within dynamic libraries.
+ * Pre-defined packet types are implemented as static const.
+ * 
+ */
+
+typedef unsigned int packet_t;
+
+static const packet_t PT_TCP = 0;
+static const packet_t PT_UDP = 1;
+static const packet_t PT_CBR = 2;
+static const packet_t PT_AUDIO = 3;
+static const packet_t PT_VIDEO = 4;
+static const packet_t PT_ACK = 5;
+static const packet_t PT_START = 6;
+static const packet_t PT_STOP = 7;
+static const packet_t PT_PRUNE = 8;
+static const packet_t PT_GRAFT = 9;
+static const packet_t PT_GRAFTACK = 10;
+static const packet_t PT_JOIN = 11;
+static const packet_t PT_ASSERT = 12;
+static const packet_t PT_MESSAGE = 13;
+static const packet_t PT_RTCP = 14;
+static const packet_t PT_RTP = 15;
+static const packet_t PT_RTPROTO_DV = 16;
+static const packet_t PT_CtrMcast_Encap = 17;
+static const packet_t PT_CtrMcast_Decap = 18;
+static const packet_t PT_SRM = 19;
+        /* simple signalling messages */
+static const packet_t PT_REQUEST = 20;
+static const packet_t PT_ACCEPT = 21;
+static const packet_t PT_CONFIRM = 22;
+static const packet_t PT_TEARDOWN = 23;
+static const packet_t PT_LIVE = 24;   // packet from live network
+static const packet_t PT_REJECT = 25;
+
+static const packet_t PT_TELNET = 26; // not needed: telnet use TCP
+static const packet_t PT_FTP = 27;
+static const packet_t PT_PARETO = 28;
+static const packet_t PT_EXP = 29;
+static const packet_t PT_INVAL = 30;
+static const packet_t PT_HTTP = 31;
+
+        /* new encapsulator */
+static const packet_t PT_ENCAPSULATED = 32;
+static const packet_t PT_MFTP = 33;
+
+        /* CMU/Monarch's extnsions */
+static const packet_t PT_ARP = 34;
+static const packet_t PT_MAC = 35;
+static const packet_t PT_TORA = 36;
+static const packet_t PT_DSR = 37;
+static const packet_t PT_AODV = 38;
+static const packet_t PT_IMEP = 39;
+        
+        // RAP packets
+static const packet_t PT_RAP_DATA = 40;
+static const packet_t PT_RAP_ACK = 41;
+  
+static const packet_t PT_TFRC = 42;
+static const packet_t PT_TFRC_ACK = 43;
+static const packet_t PT_PING = 44;
+        
+static const packet_t PT_PBC = 45;
+        // Diffusion packets - Chalermek
+static const packet_t PT_DIFF = 46;
+        
+        // LinkState routing update packets
+static const packet_t PT_RTPROTO_LS = 47;
+        
+        // MPLS LDP header
+static const packet_t PT_LDP = 48;
+        
+        // GAF packet
+static const packet_t PT_GAF = 49;
+        
+        // ReadAudio traffic
+static const packet_t PT_REALAUDIO = 50;
+        
+        // Pushback Messages
+static const packet_t PT_PUSHBACK = 51;
+  
+  #ifdef HAVE_STL
+        // Pragmatic General Multicast
+static const packet_t PT_PGM = 52;
+  #endif //STL
+        // LMS packets
+static const packet_t PT_LMS = 53;
+static const packet_t PT_LMS_SETUP = 54;
+
+static const packet_t PT_SCTP = 55;
+static const packet_t PT_SCTP_APP1 = 56;
+
+        // SMAC packet
+static const packet_t PT_SMAC = 57;
+        // XCP packet
+static const packet_t PT_XCP = 58;
+
+        // HDLC packet
+static const packet_t PT_HDLC = 59;
+
+        // Bell Labs Traffic Trace Type (PackMime OL)
+static const packet_t PT_BLTRACE = 60;
+
+	// AOMDV packet
+static const packet_t PT_AOMDV = 61;
+
+/*IEEE 802.16 packet*/	
+static const packet_t PT_UGS = 62;
+static const packet_t PT_rtPS = 63;
+static const packet_t PT_ertPS = 64;
+static const packet_t PT_nrtPS = 65;
+static const packet_t PT_BE = 66;
+static const packet_t PT_BWREQ = 67;
+static const packet_t PT_UCD = 68;
+static const packet_t PT_DCD = 69;
+static const packet_t PT_DLMAP = 70;
+static const packet_t PT_ULMAP = 71;
+static const packet_t PT_RNGREQ = 72;
+static const packet_t PT_RNGRSP = 73;
+static const packet_t PT_DSAREQ = 74;
+static const packet_t PT_DSARSP = 75;
+static const packet_t PT_DSAACK = 76;
+static const packet_t PT_DSXRVD = 77;
+
+        // insert new packet types here
+static packet_t       PT_NTYPE = 78; // This MUST be the LAST one
+
+enum packetClass
+{
+	UNCLASSIFIED,
+	ROUTING,
+	DATApkt
+  };
+
+
+/*
+ * ns-2.33 adding support for dynamic libraries
+ * 
+ * The PacketClassifier class is needed to make
+ * p_info::data_packet(packet_t) work also with dynamically defined
+ * packet types.
+ * 
+ */
+class PacketClassifier
+{
+	public:
+		PacketClassifier(): next_(0){}
+		virtual ~PacketClassifier() {}
+		void setNext(PacketClassifier *next){next_ = next;}
+		PacketClassifier *getNext(){return next_;}
+		packetClass classify(packet_t type) 
+		{
+		        packetClass c = getClass(type);
+		        if(c == UNCLASSIFIED && next_)
+		                c = next_->classify(type);
+		        return c;
+		}
+
+	protected:
+		//return 0 if the packet is unknown
+		virtual packetClass getClass(packet_t type) = 0;        
+		PacketClassifier *next_;
+};
+
+class p_info {
+public:
+	p_info()
+	{
+		initName();
+	}
+	const char* name(packet_t p) const { 
+		if ( p <= p_info::nPkt_ ) return name_[p];
+		return 0;
+	}
+	static bool data_packet(packet_t type) {
+		return ( (type) == PT_TCP || \
+		         (type) == PT_TELNET || \
+		         (type) == PT_CBR || \
+		         (type) == PT_AUDIO || \
+		         (type) == PT_VIDEO || \
+		         (type) == PT_ACK || \
+		         (type) == PT_SCTP || \
+		         (type) == PT_SCTP_APP1 || \
+		         (type) == PT_HDLC \
+		        );
+	}
+	static packetClass classify(packet_t type) {		
+		if (type == PT_DSR || 
+		    type == PT_MESSAGE || 
+		    type == PT_TORA || 
+		    type == PT_AODV)
+			return ROUTING;		
+		if (type == PT_TCP || 
+		    type == PT_TELNET || 
+		    type == PT_CBR || 
+		    type == PT_AUDIO || 
+		    type == PT_VIDEO || 
+		    type == PT_ACK || 
+		    type == PT_SCTP || 
+		    type == PT_SCTP_APP1 || 
+		    type == PT_HDLC)
+			return DATApkt;
+		if (pc_)
+			return pc_->classify(type);
+		return UNCLASSIFIED;
+	}
+	static void addPacketClassifier(PacketClassifier *pc)
+	{
+		if(!pc)
+		        return;
+		pc->setNext(pc_);
+		pc_ = pc;
+	}       
+	static void initName()
+	{
+		if(nPkt_ >= PT_NTYPE+1)
+		        return;
+		char **nameNew = new char*[PT_NTYPE+1];
+		for(unsigned int i = (unsigned int)PT_SMAC+1; i < nPkt_; i++)
+		{
+		        nameNew[i] = name_[i];
+		}
+		if(!nPkt_)
+		        delete [] name_;
+		name_ = nameNew;
+		nPkt_ = PT_NTYPE+1;
+		
+
+		name_[PT_TCP]= "tcp";
+		name_[PT_UDP]= "udp";
+		name_[PT_CBR]= "cbr";
+		name_[PT_AUDIO]= "audio";
+		name_[PT_VIDEO]= "video";
+		name_[PT_ACK]= "ack";
+		name_[PT_START]= "start";
+		name_[PT_STOP]= "stop";
+		name_[PT_PRUNE]= "prune";
+		name_[PT_GRAFT]= "graft";
+		name_[PT_GRAFTACK]= "graftAck";
+		name_[PT_JOIN]= "join";
+		name_[PT_ASSERT]= "assert";
+		name_[PT_MESSAGE]= "message";
+		name_[PT_RTCP]= "rtcp";
+		name_[PT_RTP]= "rtp";
+		name_[PT_RTPROTO_DV]= "rtProtoDV";
+		name_[PT_CtrMcast_Encap]= "CtrMcast_Encap";
+		name_[PT_CtrMcast_Decap]= "CtrMcast_Decap";
+		name_[PT_SRM]= "SRM";
+	
+		name_[PT_REQUEST]= "sa_req";	
+		name_[PT_ACCEPT]= "sa_accept";
+		name_[PT_CONFIRM]= "sa_conf";
+		name_[PT_TEARDOWN]= "sa_teardown";
+		name_[PT_LIVE]= "live"; 
+		name_[PT_REJECT]= "sa_reject";
+	
+		name_[PT_TELNET]= "telnet";
+		name_[PT_FTP]= "ftp";
+		name_[PT_PARETO]= "pareto";
+		name_[PT_EXP]= "exp";
+		name_[PT_INVAL]= "httpInval";
+		name_[PT_HTTP]= "http";
+		name_[PT_ENCAPSULATED]= "encap";
+		name_[PT_MFTP]= "mftp";
+		name_[PT_ARP]= "ARP";
+		name_[PT_MAC]= "MAC";
+		name_[PT_TORA]= "TORA";
+		name_[PT_DSR]= "DSR";
+		name_[PT_AODV]= "AODV";
+		name_[PT_IMEP]= "IMEP";
+
+		name_[PT_RAP_DATA] = "rap_data";
+		name_[PT_RAP_ACK] = "rap_ack";
+
+ 		name_[PT_TFRC]= "tcpFriend";
+		name_[PT_TFRC_ACK]= "tcpFriendCtl";
+		name_[PT_PING]="ping";
+	
+		name_[PT_PBC] = "PBC";
+
+	 	/* For diffusion : Chalermek */
+ 		name_[PT_DIFF] = "diffusion";
+
+		// Link state routing updates
+		name_[PT_RTPROTO_LS] = "rtProtoLS";
+
+		// MPLS LDP packets
+		name_[PT_LDP] = "LDP";
+
+		// for GAF
+                name_[PT_GAF] = "gaf";      
+
+		// RealAudio packets
+		name_[PT_REALAUDIO] = "ra";
+
+		//pushback 
+		name_[PT_PUSHBACK] = "pushback";
+
+#ifdef HAVE_STL
+		// for PGM
+		name_[PT_PGM] = "PGM";
+#endif //STL
+
+		// LMS entries
+		name_[PT_LMS]="LMS";
+		name_[PT_LMS_SETUP]="LMS_SETUP";
+
+		name_[PT_SCTP]= "sctp";
+ 		name_[PT_SCTP_APP1] = "sctp_app1";
+		
+		// smac
+		name_[PT_SMAC]="smac";
+
+		// HDLC
+		name_[PT_HDLC]="HDLC";
+
+		// XCP
+		name_[PT_XCP]="xcp";
+
+		// Bell Labs (PackMime OL)
+		name_[PT_BLTRACE]="BellLabsTrace";
+		
+		// AOMDV patch
+		name_[PT_AOMDV]= "AOMDV";
+		/*IEEE 802.16 packet*/
+		name_[PT_UGS]="UGS";
+		name_[PT_rtPS]="rtPS";
+		name_[PT_ertPS]="ertPS";
+		name_[PT_nrtPS]="nrtPS";
+		name_[PT_BE]="BE";
+		name_[PT_BWREQ]="BWREQ";
+		name_[PT_UCD]="UCD";
+		name_[PT_DCD]="DCD";
+		name_[PT_DLMAP]="DLMAP";
+		name_[PT_ULMAP]="ULMAP";
+		name_[PT_RNGREQ]="RNGREQ";
+		name_[PT_RNGRSP]="RNGRSP";
+		name_[PT_DSAREQ]="DSAREQ";
+		name_[PT_DSARSP]="DSARSP";
+		name_[PT_DSAACK]="DSAACK";
+		name_[PT_DSXRVD]="DSXRVD";
+
+		name_[PT_NTYPE]= "undefined";
+	}
+	static int addPacket(char *name);
+	static packet_t getType(const char *name)
+	{
+		for(unsigned int i = 0; i < nPkt_; i++)
+		{
+		        if(strcmp(name, name_[i]) == 0)
+		                return i;
+		}
+		return PT_NTYPE;
+
+	}
+private:
+	static char** name_;
+	static unsigned int nPkt_;
+	static PacketClassifier *pc_;
+};
+extern p_info packet_info; /* map PT_* to string name */
+//extern char* p_info::name_[];
+
+#define DATA_PACKET(type) ( (type) == PT_TCP || \
+                            (type) == PT_TELNET || \
+                            (type) == PT_CBR || \
+                            (type) == PT_AUDIO || \
+                            (type) == PT_VIDEO || \
+                            (type) == PT_ACK || \
+                            (type) == PT_SCTP || \
+                            (type) == PT_SCTP_APP1 \
+                            )
+
+//#define OFFSET(type, field)	((long) &((type *)0)->field)
+#define OFFSET(type, field) ( (char *)&( ((type *)256)->field )  - (char *)256)
+
+class PacketData : public AppData {
+public:
+	PacketData(int sz) : AppData(PACKET_DATA) {
+		datalen_ = sz;
+		if (datalen_ > 0)
+			data_ = new unsigned char[datalen_];
+		else
+			data_ = NULL;
+	}
+	PacketData(PacketData& d) : AppData(d) {
+		datalen_ = d.datalen_;
+		if (datalen_ > 0) {
+			data_ = new unsigned char[datalen_];
+			memcpy(data_, d.data_, datalen_);
+		} else
+			data_ = NULL;
+	}
+	virtual ~PacketData() { 
+		if (data_ != NULL) 
+			delete []data_; 
+	}
+	unsigned char* data() { return data_; }
+
+	virtual int size() const { return datalen_; }
+	virtual AppData* copy() { return new PacketData(*this); }
+private:
+	unsigned char* data_;
+	int datalen_;
+};
+
+//Monarch ext
+typedef void (*FailureCallback)(Packet *,void *);
+
+class Packet : public Event {
+private:
+	unsigned char* bits_;	// header bits
+//	unsigned char* data_;	// variable size buffer for 'data'
+//  	unsigned int datalen_;	// length of variable size buffer
+	AppData* data_;		// variable size buffer for 'data'
+	static void init(Packet*);     // initialize pkt hdr 
+	bool fflag_;
+protected:
+	static Packet* free_;	// packet free list
+	int	ref_count_;	// free the pkt until count to 0
+public:
+	Packet* next_;		// for queues and the free list
+	static int hdrlen_;
+	int type_;
+	int len_;
+	//int destIP;
+	Packet() : bits_(0), data_(0), ref_count_(0), next_(0) { }
+	inline unsigned char* const bits() { return (bits_); }
+	inline Packet* copy() const;
+	inline Packet* refcopy() { ++ref_count_; return this; }
+	inline int& ref_count() { return (ref_count_); }
+	static inline Packet* alloc();
+	static inline Packet* alloc(int);
+	inline void allocdata(int);
+	// dirty hack for diffusion data
+	inline void initdata() { data_  = 0;}
+	static inline void free(Packet*);
+	inline unsigned char* access(int off) const {
+		if (off < 0)
+			abort();
+		return (&bits_[off]);
+	}
+	// This is used for backward compatibility, i.e., assuming user data
+	// is PacketData and return its pointer.
+	inline unsigned char* accessdata() const { 
+		if (data_ == 0)
+			return 0;
+		assert(data_->type() == PACKET_DATA);
+		return (((PacketData*)data_)->data()); 
+	}
+	// This is used to access application-specific data, not limited 
+	// to PacketData.
+	inline AppData* userdata() const {
+		return data_;
+	}
+	inline void setdata(AppData* d) { 
+		if (data_ != NULL)
+			delete data_;
+		data_ = d; 
+	}
+	inline int datalen() const { return data_ ? data_->size() : 0; }
+
+	// Monarch extn
+
+	static void dump_header(Packet *p, int offset, int length);
+
+	// the pkt stamp carries all info about how/where the pkt
+        // was sent needed for a receiver to determine if it correctly
+        // receives the pkt
+        PacketStamp	txinfo_;  
+
+	/*
+         * According to cmu code:
+	 * This flag is set by the MAC layer on an incoming packet
+         * and is cleared by the link layer.  It is an ugly hack, but
+         * there's really no other way because NS always calls
+         * the recv() function of an object.
+	 * 
+         */
+        u_int8_t        incoming;
+
+	//monarch extns end;
+};
+
+/* 
+ * static constant associations between interface special (negative) 
+ * values and their c-string representations that are used from tcl
+ */
+class iface_literal {
+public:
+	enum iface_constant { 
+		UNKN_IFACE= -1, /* 
+				 * iface value for locally originated packets 
+				 */
+		ANY_IFACE= -2   /* 
+				 * hashnode with iif == ANY_IFACE_   
+				 * matches any pkt iface (imported from TCL);
+				 * this value should be different from 
+				 * hdr_cmn::UNKN_IFACE (packet.h)
+				 */ 
+	};
+	iface_literal(const iface_constant i, const char * const n) : 
+		value_(i), name_(n) {}
+	inline int value() const { return value_; }
+	inline const char * const name() const { return name_; }
+private:
+	const iface_constant value_;
+	/* strings used in TCL to access those special values */
+	const char * const name_; 
+};
+
+static const iface_literal UNKN_IFACE(iface_literal::UNKN_IFACE, "?");
+static const iface_literal ANY_IFACE(iface_literal::ANY_IFACE, "*");
+
+/*
+ * Note that NS_AF_* doesn't necessarily correspond with
+ * the constants used in your system (because many
+ * systems don't have NONE or ILINK).
+ */
+enum ns_af_enum { NS_AF_NONE, NS_AF_ILINK, NS_AF_INET };
+
+enum ModulationScheme {BPSK = 0, QPSK = 1, QAM16 = 2, QAM64 = 3};
+
+struct hdr_cmn {
+	enum dir_t { DOWN= -1, NONE= 0, UP= 1 };
+	packet_t ptype_;	// packet type (see above)
+	int	size_;		// simulated packet size
+	int	uid_;		// unique id
+	int	error_;		// error flag
+	int     errbitcnt_;     // # of corrupted bits jahn
+	int     fecsize_;
+	double	ts_;		// timestamp: for q-delay measurement
+	int	iface_;		// receiving interface (label)
+	dir_t	direction_;	// direction: 0=none, 1=up, -1=down
+	// source routing 
+        char src_rt_valid;
+	double ts_arr_; // Required by Marker of JOBS 
+
+	//Monarch extn begins
+	nsaddr_t prev_hop_;     // IP addr of forwarding hop
+	nsaddr_t next_hop_;	// next hop for this packet
+	int      addr_type_;    // type of next_hop_ addr
+	nsaddr_t last_hop_;     // for tracing on multi-user channels
+	
+	// AOMDV patch
+	int aomdv_salvage_count_;
+	
+        // called if pkt can't obtain media or isn't ack'd. not called if
+        // droped by a queue
+        FailureCallback xmit_failure_; 
+        void *xmit_failure_data_;
+
+        /*
+         * MONARCH wants to know if the MAC layer is passing this back because
+         * it could not get the RTS through or because it did not receive
+         * an ACK.
+         */
+        int     xmit_reason_;
+#define XMIT_REASON_RTS 0x01
+#define XMIT_REASON_ACK 0x02
+
+        // filled in by GOD on first transmission, used for trace analysis
+        int num_forwards_;	// how many times this pkt was forwarded
+        int opt_num_forwards_;   // optimal #forwards
+	// Monarch extn ends;
+
+	// tx time for this packet in sec
+	double txtime_;
+	inline double& txtime() { return(txtime_); }
+
+	static int offset_;	// offset for this header
+	inline static int& offset() { return offset_; }
+	inline static hdr_cmn* access(const Packet* p) {
+		return (hdr_cmn*) p->access(offset_);
+	}
+	
+        /* per-field member functions */
+	inline packet_t& ptype() { return (ptype_); }
+	inline int& size() { return (size_); }
+	inline int& uid() { return (uid_); }
+	inline int& error() { return error_; }
+	inline int& errbitcnt() {return errbitcnt_; }
+	inline int& fecsize() {return fecsize_; }
+	inline double& timestamp() { return (ts_); }
+	inline int& iface() { return (iface_); }
+	inline dir_t& direction() { return (direction_); }
+	// monarch_begin
+	inline nsaddr_t& next_hop() { return (next_hop_); }
+	inline int& addr_type() { return (addr_type_); }
+	inline int& num_forwards() { return (num_forwards_); }
+	inline int& opt_num_forwards() { return (opt_num_forwards_); }
+        //monarch_end
+
+	ModulationScheme mod_scheme_;
+	inline ModulationScheme& mod_scheme() { return (mod_scheme_); }
+};
+
+
+class PacketHeaderClass : public TclClass {
+protected:
+	PacketHeaderClass(const char* classname, int hdrsize);
+	virtual int method(int argc, const char*const* argv);
+	void field_offset(const char* fieldname, int offset);
+	inline void bind_offset(int* off) { offset_ = off; }
+	inline void offset(int* off) {offset_= off;}
+	int hdrlen_;		// # of bytes for this header
+	int* offset_;		// offset for this header
+public:
+	virtual void bind();
+	virtual void export_offsets();
+	TclObject* create(int argc, const char*const* argv);
+};
+
+
+inline void Packet::init(Packet* p)
+{
+	bzero(p->bits_, hdrlen_);
+}
+
+inline Packet* Packet::alloc()
+{
+	Packet* p = free_;
+	if (p != 0) {
+		assert(p->fflag_ == FALSE);
+		free_ = p->next_;
+		assert(p->data_ == 0);
+		p->uid_ = 0;
+		p->time_ = 0;
+	} else {
+		p = new Packet;
+		p->bits_ = new unsigned char[hdrlen_];
+		if (p == 0 || p->bits_ == 0)
+			abort();
+	}
+	init(p); // Initialize bits_[]
+	(HDR_CMN(p))->next_hop_ = -2; // -1 reserved for IP_BROADCAST
+	(HDR_CMN(p))->last_hop_ = -2; // -1 reserved for IP_BROADCAST
+	p->fflag_ = TRUE;
+	(HDR_CMN(p))->direction() = hdr_cmn::DOWN;
+	/* setting all direction of pkts to be downward as default; 
+	   until channel changes it to +1 (upward) */
+	p->next_ = 0;
+	return (p);
+}
+
+/* 
+ * Allocate an n byte data buffer to an existing packet 
+ * 
+ * To set application-specific AppData, use Packet::setdata()
+ */
+inline void Packet::allocdata(int n)
+{
+	assert(data_ == 0);
+	data_ = new PacketData(n);
+	if (data_ == 0)
+		abort();
+}
+
+/* allocate a packet with an n byte data buffer */
+inline Packet* Packet::alloc(int n)
+{
+	Packet* p = alloc();
+	if (n > 0) 
+		p->allocdata(n);
+	return (p);
+}
+
+
+inline void Packet::free(Packet* p)
+{
+	if (p->fflag_) {
+		if (p->ref_count_ == 0) {
+			/*
+			 * A packet's uid may be < 0 (out of a event queue), or
+			 * == 0 (newed but never gets into the event queue.
+			 */
+			assert(p->uid_ <= 0);
+			// Delete user data because we won't need it any more.
+			if (p->data_ != 0) {
+				delete p->data_;
+				p->data_ = 0;
+			}
+			init(p);
+			p->next_ = free_;
+			free_ = p;
+			p->fflag_ = FALSE;
+		} else {
+			--p->ref_count_;
+		}
+	}
+}
+
+inline Packet* Packet::copy() const
+{
+	
+	Packet* p = alloc();
+	memcpy(p->bits(), bits_, hdrlen_);
+	if (data_) 
+		p->data_ = data_->copy();
+	p->txinfo_.init(&txinfo_);
+ 
+	return (p);
+}
+
+inline void
+Packet::dump_header(Packet *p, int offset, int length)
+{
+        assert(offset + length <= p->hdrlen_);
+        struct hdr_cmn *ch = HDR_CMN(p);
+
+        fprintf(stderr, "\nPacket ID: %d\n", ch->uid());
+
+        for(int i = 0; i < length ; i+=16) {
+                fprintf(stderr, "%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
+                        p->bits_[offset + i],     p->bits_[offset + i + 1],
+                        p->bits_[offset + i + 2], p->bits_[offset + i + 3],
+                        p->bits_[offset + i + 4], p->bits_[offset + i + 5],
+                        p->bits_[offset + i + 6], p->bits_[offset + i + 7],
+                        p->bits_[offset + i + 8], p->bits_[offset + i + 9],
+                        p->bits_[offset + i + 10], p->bits_[offset + i + 11],
+                        p->bits_[offset + i + 12], p->bits_[offset + i + 13],
+                        p->bits_[offset + i + 14], p->bits_[offset + i + 15]);
+        }
+}
+
+#endif
diff -u -r -N ns-2.34.original/mac/mac-802_16/distance.h ns-2.34/mac/mac-802_16/distance.h
--- ns-2.34.original/mac/mac-802_16/distance.h	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/mac/mac-802_16/distance.h	2007-12-14 09:27:16.000000000 +0800
@@ -0,0 +1,48 @@
+#ifndef ns_distance_h
+#define ns_distance_h
+
+#include "stdio.h"
+#include <stdlib.h>
+
+
+int convert(FILE *out,int id,int x,int y);
+int writeFile(FILE *out, double value);
+char* transform(int tmp);
+
+int convert(FILE *out,int id,int x,int y){
+	fputs(transform(id),out);
+	putc(' ',out);
+	fputs(transform(x),out);	
+	fputs(transform(y),out);	
+	//writeFile(out,x);	
+	//writeFile(out,y);
+    putc('\n',out);
+	
+	return 0;
+}
+char* transform(int tmp){
+	char *a="";
+	sprintf(a, "%d", tmp);
+	return a;
+}
+/*int writeFile(FILE *o, double value){
+	char *string;
+	int dec, sign;
+	int ndig = 10;
+	string = ecvt(value, ndig, &dec, &sign);
+	
+	if(sign==1) fputs("-",o);
+	if(dec==0)putc('0',o);
+	for(int i=0; string[i]!='\0';i++){
+       if(dec==i){ 
+				fputs(".",o);
+				putc(string[i],o);
+		}
+       else putc(string[i],o);
+	}	
+	fputs(" ",o);
+	
+	return 0;
+
+}*/
+#endif
\ No newline at end of file
diff -u -r -N ns-2.34.original/mac/mac-802_16/geographic.h ns-2.34/mac/mac-802_16/geographic.h
--- ns-2.34.original/mac/mac-802_16/geographic.h	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/mac/mac-802_16/geographic.h	2007-12-14 09:27:16.000000000 +0800
@@ -0,0 +1,74 @@
+#ifndef ns_geographic_h
+#define ns_geographic_h
+#include "mac-802_16.h"
+
+
+class Mod{
+	public: 
+		Mod() : x(-1), y(-1), distance(-1), mod(-1), id(-1), enable(-1), next_(0){}
+		double x;
+		double y;
+		double distance;
+		double mod;
+		int id;	
+		int enable;
+		Mod *next_;		
+		ModulCodingType ToMod(double bs_x,double bs_y) {
+			distance = pow(x-bs_x,2)+pow(y-bs_y,2);
+			distance = sqrt(distance);
+			printf("SS_X: %f   SS_Y: %f     \nBS_X: %f   BS_Y: %f     distance:%f ",x,y,bs_x,bs_y,distance);
+			if (distance/1000 < 10) {
+			  	printf(" 64 QAM\n");
+				if(distance/1000) return QAM64_34;				  
+				return QAM64_23;
+			} else if (distance/1000<15) {
+				printf(" 16 QAM\n");
+				if(distance/1000) return QAM16_34;				  
+				return QAM16_12;				   		   
+			} else {
+				printf(" QPSK\n");
+				if(distance/1000) return QPSK_34;				  
+				return QPSK_12;	  
+			}		
+		}
+};
+
+class TOMAC {
+	private:					
+		Mod* head_;
+		Mod* tail_;
+	public:
+		TOMAC() : head_(0), tail_(0){}
+		int check(int id_) {			
+			for (Mod* tmp = head_; tmp != 0; tmp = tmp->next_) {
+				if (tmp->id == id_)
+					return (tmp->enable == 1)? 2:1;
+			}
+			return 0;
+		}
+		void unlock(int id_) {
+			for (Mod* tmp = head_; tmp != 0; tmp = tmp->next_)
+				if (tmp->id == id_) tmp->enable = 1;	
+		}
+		void enque(int id_, double X, double Y) {
+			Mod* p = new Mod;
+			p->id = id_;
+			p->x = X;
+			p->y = Y;
+			if (!tail_) head_= tail_= p;
+			else {
+				tail_->next_= p;
+				tail_= p;				
+			}
+			tail_->next_ = 0;				
+		}	
+		Mod* search(int id_) {
+			for (Mod* tmp = head_; tmp != 0; tmp = tmp->next_) {
+				if (tmp->id == id_)
+					return tmp;
+			}
+			return 0;		
+		}
+};
+
+#endif
\ No newline at end of file
diff -u -r -N ns-2.34.original/mac/mac-802_16/mac-802_16.cc ns-2.34/mac/mac-802_16/mac-802_16.cc
--- ns-2.34.original/mac/mac-802_16/mac-802_16.cc	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/mac/mac-802_16/mac-802_16.cc	2007-12-14 09:27:16.000000000 +0800
@@ -0,0 +1,2222 @@
+/**************************************************************************************
+* *Copyright (c) 2006 Regents of the University of Chang Gung 						*
+* *All rights reserved.													*
+ *																*
+ * Redistribution and use in source and binary forms, with or without						*
+ * modification, are permitted provided that the following conditions					*
+ * are met: 															*
+ * 1. Redistributions of source code must retain the above copyright						*
+ *    notice, this list of conditions and the following disclaimer.						*
+ * 2. Redistributions in binary form must reproduce the above copyright					*
+ *    notice, this list of conditions and the following disclaimer in the						*
+ *    documentation and/or other materials provided with the distribution.					*
+ * 3. All advertising materials mentioning features or use of this software					*
+ *    must display the following acknowledgement:									*
+ *	This product includes software developed by the Computer Systems					*
+ *	Engineering Group at Lawrence Berkeley Laboratory.							*
+ * 4. Neither the name of the University nor of the Laboratory may be used					*
+ *    to endorse or promote products derived from this software without					*
+ *    specific prior written permission.										*
+ *5. If you have any problem about these codes, 									*
+       please mail to antibanish@gmail.com or b9229008@stmail.cgu.edu.tw                    			*
+**************************************************************************************/
+#include "delay.h"
+#include "connector.h"
+#include "packet.h"
+#include "random.h"
+#include "mobilenode.h"
+
+#include "arp.h" 
+#include "ll.h"
+#include "mac.h"
+#include "mac-802_16.h"
+#include "cmu-trace.h"
+#include "rtp.h"   
+#include "agent.h"
+#include "basetrace.h"
+#include "geographic.h"
+
+#define BsID 0
+#define MaxProfileNum 6
+#define PDUSIZE 100
+#define DlSymbolNum 36
+#define UlSymbolNum 12
+#define DlSubchanNum 60
+#define UlSubchanNum 92
+
+extern TOMAC *CalMod;
+
+int BasicCID_Counter = 0x0001; //0x0001 ~ 0x1000
+int PrimaryCID_Counter = 0x001; //0x1001 ~ 0x2000
+int TransportCID_Counter = 0x2001; //0x2001 ~ 0xFFFE
+int FrameNumber_Counter = 0;
+int DCD_Counter = 0;
+int UCD_Counter = 0;
+int ServiceFlowID_Counter0 = 0;
+int ServiceFlowID_Counter1 = 0;
+int ServiceFlowID_Counter2 = 0;
+int ServiceFlowID_Counter3 = 0;
+int ServiceFlowID_Counter4 = 0;
+int ServiceFlowID_Counter5 = 0;
+int ServiceFlowID_Counter6 = 0;
+int ServiceFlowID_Counter7 = 0;
+int ServiceFlowID_Counter8 = 0;
+int ServiceFlowID_Counter9 = 0;
+int UlMapIeNum, DlMapIeNum;
+int DlSymbolMap[DlSymbolNum][DlSubchanNum];
+int UlSymbolMap[UlSymbolNum][UlSubchanNum];
+double FrameLength = 0.005, SymbolLength = 0.00010084, TtgLength = 0.00002941, RtgLength = 0.00002941;
+double AllocationStartTime;
+int DlAvailSymbol, UlAvailSymbol;
+BsSsInfo *BsSsInfo_head;
+BsSsInfo *BsSsInfo_tail;
+BsServiceFlow *BsSF_head;
+BsServiceFlow *BsSF_tail;
+UplinkBurstProfile *UlBurstProfile_head;
+UplinkBurstProfile *UlBurstProfile_tail;
+DownlinkBurstProfile *DlBurstProfile_head;
+DownlinkBurstProfile *DlBurstProfile_tail;
+UlMapIe *UlMapIe_head;
+UlMapIe *UlMapIe_tail;
+DlMapIe *DlMapIe_head;
+DlMapIe *DlMapIe_tail;
+
+Mac802_16::Mac802_16() :Mac(),frameTimer(this),preambleTimer(this),downlinkTimer(this),uplinkTimer(this),ulmapTimer(this),dlmapTimer(this)
+{
+	NodeID = index_;
+	if (NodeID == BsID) {
+		TransactionID_Counter = 0x8000; //0x8000 ~ 0xFFFFF
+		BsSsInfo_head = NULL;
+		BsSsInfo_tail = NULL;
+		BsSF_head = NULL;
+		BsSF_tail = NULL;
+		UlBurstProfile_head = NULL;
+		UlBurstProfile_tail = NULL;
+		DlBurstProfile_head = NULL;
+		DlBurstProfile_tail = NULL;
+		UlMapIe_head = NULL;
+		UlMapIe_tail = NULL;
+		DlMapIe_head = NULL;
+		DlMapIe_tail = NULL;
+		DlAvailSymbol = DlSymbolNum*DlSubchanNum;
+		UlAvailSymbol = UlSymbolNum*UlSubchanNum;
+		frameTimer.start(0);
+		DlMapIeNum = 0;
+		UlMapIeNum = 0;
+	} else {
+		TransactionID_Counter = 0x0000;	//0x0000 ~ 0x7FFFF
+		SsSF_head = NULL;
+		SsSF_tail = NULL;
+		RangingStatus = false;
+	}
+}  
+
+void 
+Mac802_16::recv(Packet* p, Handler* h)
+{
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	struct hdr_mac *mac = HDR_MAC(p);
+	struct hdr_mac802_16 *mac16 = HDR_MAC802_16(p);	
+	UcdMsg *ucd = (UcdMsg*) p->accessdata();
+	DcdMsg *dcd = (DcdMsg*) p->accessdata();
+	RngReqMsg *rngreq = (RngReqMsg*) p->accessdata();
+	RngRspMsg *rngrsp = (RngRspMsg*) p->accessdata();
+	DsaReqMsg *dsareq = (DsaReqMsg*) p->accessdata();
+	DsaRspMsg *dsarsp = (DsaRspMsg*) p->accessdata();
+	DsaAckMsg *dsaack = (DsaAckMsg*) p->accessdata();
+	
+	if (hdr_cmn::access(p)->direction() == hdr_cmn::UP) {
+		if (NodeID == BsID) {
+			if (hdr->ptype() == PT_UGS) {			
+				if (BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)) {
+					/*if (hdr->next_hop() != BsID) {	
+						if (!BsSearchServiceFlow(BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)->MacAddr, hdr->next_hop(), PT_UGS, DL, -1, -1))
+							sendDSAREQ(NULL, BsCreateServiceFlow(p, DL));
+						BsSearchServiceFlow(BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)->MacAddr, hdr->next_hop(), PT_UGS, DL, -1, -1)->SduQueue.enque(p);
+					} else*/
+						uptarget_->recv(p, this);
+					//printf("bs  recv UGS pkt from ss%d\n",BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)->MacAddr);
+				}
+			} else if (hdr->ptype() == PT_ertPS) {	
+				if (BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)) {
+					/*if (hdr->next_hop() != BsID) {	
+						if (!BsSearchServiceFlow(BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)->MacAddr, hdr->next_hop(), PT_ertPS, DL, -1, -1))
+							sendDSAREQ(NULL, BsCreateServiceFlow(p, DL));
+						BsSearchServiceFlow(BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)->MacAddr, hdr->next_hop(), PT_ertPS, DL, -1, -1)->SduQueue.enque(p);
+					} else*/
+						uptarget_->recv(p, this);
+					//printf("bs  recv ertPS pkt from ss%d\n",BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)->MacAddr);
+				}				
+			} else if (hdr->ptype() == PT_rtPS) { 		
+				if (BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)) {
+					/*if (hdr->next_hop() != BsID) {	
+						if (!BsSearchServiceFlow(BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)->MacAddr, hdr->next_hop(), PT_rtPS, DL, -1, -1))
+							sendDSAREQ(NULL, BsCreateServiceFlow(p, DL));
+						BsSearchServiceFlow(BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)->MacAddr, hdr->next_hop(), PT_rtPS, DL, -1, -1)->SduQueue.enque(p);
+					} else*/
+						uptarget_->recv(p, this);
+					//printf("bs  recv rtPS pkt from ss%d\n",BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)->MacAddr);
+				}					
+			} else if (hdr->ptype() == PT_nrtPS) {	
+				if (BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)) {
+					/*if (hdr->next_hop() != BsID) {	
+						if (!BsSearchServiceFlow(BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)->MacAddr, hdr->next_hop(), PT_nrtPS, DL, -1, -1))
+							sendDSAREQ(NULL, BsCreateServiceFlow(p, DL));
+						BsSearchServiceFlow(BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)->MacAddr, hdr->next_hop(), PT_nrtPS, DL, -1, -1)->SduQueue.enque(p);
+					} else*/
+						uptarget_->recv(p, this);
+					//printf("bs  recv nrtPS pkt from ss%d\n",BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)->MacAddr);
+				}					
+			} else if (hdr->ptype() == PT_BE) {
+				if (BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)) {
+					/*if (hdr->next_hop() != BsID) {	
+						if (!BsSearchServiceFlow(BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)->MacAddr, hdr->next_hop(), PT_BE, DL, -1, -1))
+							sendDSAREQ(NULL, BsCreateServiceFlow(p, DL));
+						BsSearchServiceFlow(BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)->MacAddr, hdr->next_hop(), PT_BE, DL, -1, -1)->SduQueue.enque(p);
+					} else*/
+						uptarget_->recv(p, this);	
+					//printf("bs  recv BE pkt from ss%d\n",BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, -1, mac16->generic_hdr.CID)->MacAddr);
+				}
+			} else if (hdr->ptype() == PT_ACK) {
+				if (mac->macDA() == NodeID)
+					uptarget_->recv(p, this);
+			} else if (hdr->ptype() == PT_BWREQ) {		
+				//printf("bs  recv BW-REQ from ss%d\n",mac->macSA());
+				BsSearchSsInfo(-1, mac16->bwreq_hdr.CID)->UplinkBandwidth += mac16->bwreq_hdr.BR;
+				mac_log(p);
+			} else if (hdr->ptype() == PT_RNGREQ) {
+				//printf("bs  recv RNG-REQ from ss%d \n", mac->macSA());
+				mac_log(p->copy());	
+				if (!BsSearchSsInfo(rngreq->SS_MAC_Address, -1))					
+					sendRNGRSP(BsCreateSsInfo(p));
+			} else if (hdr->ptype() == PT_DSAREQ) {
+				if (dsareq->Transaction_ID <= 0x7FFF) {
+					packet_t ptype;	
+					switch (dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value) {
+						case 0x06: ptype = PT_UGS; break;
+						case 0x05: ptype = PT_ertPS; break;
+						case 0x04: ptype = PT_rtPS; break;
+						case 0x03: ptype = PT_nrtPS; break;
+						case 0x02: ptype = PT_BE; break;
+					}		
+					if (BsSearchSsInfo(-1, mac16->generic_hdr.CID) && !BsSearchServiceFlow(dsareq->Service_Flow_Parameters.Source_MAC_Address.Value, dsareq->Service_Flow_Parameters.Destination_MAC_Address.Value, ptype, UL, -1, -1)) {
+						//printf("bs  recv DSA-REQ from ss%d\n", BsSearchSsInfo(-1, mac16->generic_hdr.CID)->MacAddr);
+						mac_log(p->copy());
+						sendDSXRVD(p->copy());
+						sendDSARSP(NULL, BsCreateServiceFlow(p->copy(), UL));
+					}
+				}				
+			} else if (hdr->ptype() == PT_DSARSP) {			
+				if (dsarsp->Transaction_ID >= 0x8000)
+					if (BsSearchSsInfo(-1, mac16->generic_hdr.CID)) {					
+						mac_log(p->copy());
+						if (dsarsp->Confirmation_Code == 0x00)
+							BsSearchServiceFlow(-1, -1, PT_NTYPE, DL, dsarsp->Transaction_ID, -1)->Status = Active;
+						sendDSAACK(p);
+					}			
+			} else if (hdr->ptype() == PT_DSAACK) {	
+				if (dsaack->Transaction_ID <= 0x7FFF) {
+					if (BsSearchServiceFlow(-1, -1, PT_NTYPE, UL, dsaack->Transaction_ID, -1)) {
+						//printf("bs  recv DSA-ACK from ss%d\n",mac->macSA());
+						mac_log(p);
+					} 
+				}		
+			} else {		
+				sendUp(p);
+				return;		
+			}
+			return;
+		} else {
+			if (hdr->ptype() == PT_UGS) {
+				if (SsSearchServiceFlow(-1, PT_NTYPE, DL, -1, mac16->generic_hdr.CID)) {
+					uptarget_->recv(p, this);
+					//printf("ss%d recv UGS pkt\n",NodeID);
+				}
+			} else if (hdr->ptype() == PT_ertPS) {
+				if (SsSearchServiceFlow(-1, PT_NTYPE, DL, -1, mac16->generic_hdr.CID)) {
+					uptarget_->recv(p, this);
+					//printf("ss%d recv ertPS pkt\n",NodeID);
+				}
+			} else if (hdr->ptype() == PT_rtPS) { 
+				if (SsSearchServiceFlow(-1, PT_NTYPE, DL, -1, mac16->generic_hdr.CID)) {
+					uptarget_->recv(p, this);
+					//printf("ss%d recv rtPS pkt\n",NodeID);
+				}
+			} else if (hdr->ptype() == PT_nrtPS) {
+				if (SsSearchServiceFlow(-1, PT_NTYPE, DL, -1, mac16->generic_hdr.CID)) {
+					uptarget_->recv(p, this);
+					//printf("ss%d recv nrtPS pkt\n",NodeID);
+				}
+			} else if (hdr->ptype() == PT_BE) {
+				if (SsSearchServiceFlow(-1, PT_NTYPE, DL, -1, mac16->generic_hdr.CID)) {
+					uptarget_->recv(p, this);
+					//printf("ss%d recv BE pkt\n",NodeID);
+				}
+			} else if (hdr->ptype() == PT_ACK) {
+				if (mac->macDA() == NodeID)
+					uptarget_->recv(p, this);
+			} else if (hdr->ptype() == PT_UCD) {
+				//printf("ss%d recv UCD\n",NodeID);
+				if (UcdConfigChangeCount != ucd->Config_Change_Count) {
+					UcdConfigChangeCount = ucd->Config_Change_Count;
+					UplinkBurstProfile *tmp = UlBurstProfile_head;
+					while (tmp) {
+						int FEC_Code;
+						switch (ModulCoding) {
+							case QPSK_12: FEC_Code = 0; break;
+							case QPSK_34: FEC_Code = 1; break;
+							case QAM16_12: FEC_Code = 2; break;
+							case QAM16_34: FEC_Code = 3; break;
+							case QAM64_23: FEC_Code = 4; break;
+							case QAM64_34: FEC_Code = 5; break;
+						}
+						if (tmp->FEC_Code_and_modulation_type.Value == FEC_Code) {
+							UplinkBurstProfileTable.UIUC = tmp->UIUC;
+							UplinkBurstProfileTable.FEC_Code_and_modulation_type.Value = tmp->FEC_Code_and_modulation_type.Value;
+						}
+						tmp = tmp->next;
+					}
+				}
+				mac_log(p);				
+			} else if (hdr->ptype() == PT_DCD) {
+				//printf("ss%d recv DCD\n",NodeID);
+				if (DcdConfigChangeCount != dcd->Config_Change_Count) {
+					DcdConfigChangeCount = dcd->Config_Change_Count;
+					DownlinkBurstProfile *tmp = DlBurstProfile_head;
+					while (tmp) {
+						int FEC_Code;
+						ModulCoding = CalMod->search(NodeID)->ToMod(CalMod->search(0)->x,CalMod->search(0)->y);
+						switch (ModulCoding) {
+							case QPSK_12: FEC_Code = 0; break;
+							case QPSK_34: FEC_Code = 1; break;
+							case QAM16_12: FEC_Code = 2; break;
+							case QAM16_34: FEC_Code = 3; break;
+							case QAM64_23: FEC_Code = 4; break;
+							case QAM64_34: FEC_Code = 5; break;
+						}
+						if (tmp->FEC_Code_type.Value == FEC_Code) {
+							DownlinkBurstProfileTable.DIUC = tmp->DIUC;
+							DownlinkBurstProfileTable.FEC_Code_type.Value = tmp->FEC_Code_type.Value;
+						}
+						tmp = tmp->next;
+					}
+				}
+				mac_log(p);				
+			} else if (hdr->ptype() == PT_BWREQ) {		
+				Packet::free(p);				
+			} else if (hdr->ptype() == PT_RNGREQ) {			
+				Packet::free(p);
+			} else if (hdr->ptype() == PT_DLMAP) {			
+				mac_log(p);			
+			} else if (hdr->ptype() == PT_ULMAP) {			
+				ulmapTimer.start(AllocationStartTime - Scheduler::instance().clock());
+				mac_log(p);				
+			} else if (hdr->ptype() == PT_RNGRSP) {				
+				if ((int)rngrsp->SS_MAC_Address == NodeID) {
+					//printf("ss%d recv RNG-RSP basic=%d primary=%d\n",NodeID,rngrsp->Basic_CID,rngrsp->Primary_Management_CID);					
+					if (rngrsp->Ranging_Status == 0x03) {
+						RangingStatus = true;
+						BasicCID = rngrsp->Basic_CID;
+						PrimaryCID = rngrsp->Primary_Management_CID;	
+					} 
+					mac_log(p);
+				}			
+			} else if (hdr->ptype() == PT_DSAREQ) {		
+				if (dsareq->Transaction_ID >= 0x8000) {
+					packet_t ptype;	
+					switch (dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value) {
+						case 0x06: ptype = PT_UGS; break;
+						case 0x05: ptype = PT_ertPS; break;
+						case 0x04: ptype = PT_rtPS; break;
+						case 0x03: ptype = PT_nrtPS; break;
+						case 0x02: ptype = PT_BE; break;
+					}		
+					if (mac16->generic_hdr.CID == PrimaryCID) {
+						//printf("ss%d recv DSA-REQ\n",NodeID);
+						mac_log(p->copy());
+						if (!SsSearchServiceFlow(dsareq->Service_Flow_Parameters.Destination_MAC_Address.Value, ptype, DL, -1, -1))
+							sendDSARSP(SsCreateServiceFlow(p, DL), NULL);
+					}		
+				}			
+			} else if (hdr->ptype() == PT_DSXRVD) {			
+				if (mac16->generic_hdr.CID == PrimaryCID)				
+					mac_log(p);			
+			} else if (hdr->ptype() == PT_DSARSP) {				
+				if (dsarsp->Transaction_ID <= 0x7FFF) {
+					if (mac16->generic_hdr.CID == PrimaryCID) {					
+						mac_log(p->copy());
+						if (dsarsp->Confirmation_Code == 0x00) {
+							SsSearchServiceFlow(-1, PT_NTYPE, UL, dsarsp->Transaction_ID, -1)->Status = Active;
+							SsSearchServiceFlow(-1, PT_NTYPE, UL, dsarsp->Transaction_ID, -1)->TransportCID = dsarsp->Service_Flow_Parameters.CID.Value;
+							SsSearchServiceFlow(-1, PT_NTYPE, UL, dsarsp->Transaction_ID, -1)->SFID = dsarsp->Service_Flow_Parameters.SFID.Value;
+						}
+						sendDSAACK(p);
+					}
+				}			
+			} else if (hdr->ptype() == PT_DSAACK) {			
+				if (dsaack->Transaction_ID >= 0x8000)
+					if (mac16->generic_hdr.CID == PrimaryCID)
+						mac_log(p);
+			} else {	
+				sendUp(p);
+				return;			
+			}
+			return;
+		}
+	} else {
+		callback_ = h;
+		if (NodeID == BsID) {					
+			if (hdr->ptype() == PT_UGS) {
+				if (!BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_UGS, DL, -1, -1))
+					BsCreateServiceFlow(p, DL);
+				if (BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_UGS, DL, -1, -1)->SduQueue.length() == 0)
+					BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_UGS, DL, -1, -1)->QueueTime = Scheduler::instance().clock();	
+				BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_UGS, DL, -1, -1)->SduQueue.enque(p);
+			} else if (hdr->ptype() == PT_ertPS) {
+				if (!BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_ertPS, DL, -1, -1))
+					BsCreateServiceFlow(p, DL);
+				if (BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_ertPS, DL, -1, -1)->SduQueue.length() == 0)
+					BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_ertPS, DL, -1, -1)->QueueTime = Scheduler::instance().clock();	
+				BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_ertPS, DL, -1, -1)->SduQueue.enque(p);
+			} else if (hdr->ptype() == PT_rtPS) { 
+				if (!BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_rtPS, DL, -1, -1))
+					BsCreateServiceFlow(p, DL);
+				if (BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_rtPS, DL, -1, -1)->SduQueue.length() == 0)
+					BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_rtPS, DL, -1, -1)->QueueTime = Scheduler::instance().clock();	
+				BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_rtPS, DL, -1, -1)->SduQueue.enque(p);
+			} else if (hdr->ptype() == PT_nrtPS) {
+				if (!BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_nrtPS, DL, -1, -1))
+					BsCreateServiceFlow(p, DL);
+				if (BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_nrtPS, DL, -1, -1)->SduQueue.length() == 0)
+					BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_nrtPS, DL, -1, -1)->QueueTime = Scheduler::instance().clock();	
+				BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_nrtPS, DL, -1, -1)->SduQueue.enque(p);
+			} else if (hdr->ptype() == PT_BE) {	
+				if (!BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_BE, DL, -1, -1))
+					BsCreateServiceFlow(p, DL);
+				if (BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_BE, DL, -1, -1)->SduQueue.length() == 0)
+					BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_BE, DL, -1, -1)->QueueTime = Scheduler::instance().clock();	
+				BsSearchServiceFlow(mac->macSA(), mac->macDA(), PT_BE, DL, -1, -1)->SduQueue.enque(p);
+			} else {
+				mac->set(MF_DATA, NodeID);
+				state(MAC_SEND);
+				sendDown(p);
+				return;
+			}
+			resume (NULL);	
+			if (BsSearchServiceFlow(mac->macSA(), mac->macDA(), hdr->ptype(), DL, -1, -1)->Status == Provisioned) {
+				sendDSAREQ(NULL, BsSearchServiceFlow(mac->macSA(), mac->macDA(), hdr->ptype(), DL, -1, -1));
+				BsSearchServiceFlow(mac->macSA(), mac->macDA(), hdr->ptype(), DL, -1, -1)->Status = Admitted;
+			}
+		} else {
+			if (hdr->ptype() == PT_UGS) {
+				if (!SsSearchServiceFlow(mac->macDA(), PT_UGS, UL, -1, -1))
+					SsCreateServiceFlow(p, UL);
+				if (SsSearchServiceFlow(mac->macDA(), PT_UGS, UL, -1, -1)->SduQueue.length() == 0)
+					SsSearchServiceFlow(mac->macDA(), PT_UGS, UL, -1, -1)->QueueTime = Scheduler::instance().clock();	
+				SsSearchServiceFlow(mac->macDA(), PT_UGS, UL, -1, -1)->SduQueue.enque(p);
+			} else if (hdr->ptype() == PT_ertPS) {
+				if (!SsSearchServiceFlow(mac->macDA(), PT_ertPS, UL, -1, -1))
+					SsCreateServiceFlow(p, UL);
+				if (SsSearchServiceFlow(mac->macDA(), PT_ertPS, UL, -1, -1)->SduQueue.length() == 0)
+					SsSearchServiceFlow(mac->macDA(), PT_ertPS, UL, -1, -1)->QueueTime = Scheduler::instance().clock();
+				SsSearchServiceFlow(mac->macDA(), PT_ertPS, UL, -1, -1)->SduQueue.enque(p);
+			} else if (hdr->ptype() == PT_rtPS) { 
+				if (!SsSearchServiceFlow(mac->macDA(), PT_rtPS, UL, -1, -1))
+					SsCreateServiceFlow(p, UL);
+				if (SsSearchServiceFlow(mac->macDA(), PT_rtPS, UL, -1, -1)->SduQueue.length() == 0)
+					SsSearchServiceFlow(mac->macDA(), PT_rtPS, UL, -1, -1)->QueueTime = Scheduler::instance().clock();
+				SsSearchServiceFlow(mac->macDA(), PT_rtPS, UL, -1, -1)->SduQueue.enque(p);
+			} else if (hdr->ptype() == PT_nrtPS) {
+				if (!SsSearchServiceFlow(mac->macDA(), PT_nrtPS, UL, -1, -1))
+					SsCreateServiceFlow(p, UL);
+				if (SsSearchServiceFlow(mac->macDA(), PT_nrtPS, UL, -1, -1)->SduQueue.length() == 0)
+					SsSearchServiceFlow(mac->macDA(), PT_nrtPS, UL, -1, -1)->QueueTime = Scheduler::instance().clock();
+				SsSearchServiceFlow(mac->macDA(), PT_nrtPS, UL, -1, -1)->SduQueue.enque(p);
+			} else if (hdr->ptype() == PT_BE) {	
+				if (!SsSearchServiceFlow(mac->macDA(), PT_BE, UL, -1, -1))
+					SsCreateServiceFlow(p, UL);
+				if (SsSearchServiceFlow(mac->macDA(), PT_BE, UL, -1, -1)->SduQueue.length() == 0)
+					SsSearchServiceFlow(mac->macDA(), PT_BE, UL, -1, -1)->QueueTime = Scheduler::instance().clock();
+				SsSearchServiceFlow(mac->macDA(), PT_BE, UL, -1, -1)->SduQueue.enque(p);
+			} else {
+				mac->set(MF_DATA, NodeID);
+				state(MAC_SEND);
+				sendDown(p);
+				return;
+			}
+			resume (NULL);
+			if (RangingStatus && SsSearchServiceFlow(mac->macDA(), hdr->ptype(), UL, -1, -1)->Status == Provisioned) {
+				sendDSAREQ(SsSearchServiceFlow(mac->macDA(), hdr->ptype(), UL, -1, -1), NULL);
+				SsSearchServiceFlow(mac->macDA(), hdr->ptype(), UL, -1, -1)->Status = Admitted;
+			}
+		}
+	}
+}
+
+void 
+Mac802_16::sendUCD()
+{
+	printf("bs  send UCD\n");
+	Packet *p = Packet::alloc();
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	struct hdr_mac *mac = HDR_MAC(p); 
+	struct hdr_mac802_16 *mac16 = HDR_MAC802_16(p);
+	p->allocdata (sizeof (struct UcdMsg));	
+	
+	mac->macDA() = -1;
+	mac->macSA() = NodeID;
+	mac->set(MF_DATA, NodeID);
+	state(MAC_SEND);
+	
+	hdr->uid() = 0;
+    hdr->ptype() = PT_UCD;
+    hdr->size() = sizeof(GenericHdr) + sizeof(UcdMsg) + MaxProfileNum*sizeof(UplinkBurstProfile)/2;
+    hdr->iface() = -2;
+    hdr->error() = 0; 
+	hdr->txtime() = 2*SymbolLength;
+	
+	mac16->generic_hdr.HT = 0;
+	mac16->generic_hdr.EC = 1;
+	mac16->generic_hdr.Type = 1;
+	mac16->generic_hdr.CI = 1; 
+	mac16->generic_hdr.EKS = 1;
+	mac16->generic_hdr.LEN = 3;
+	mac16->generic_hdr.CID = 0xFFFF;
+	mac16->generic_hdr.HCS = 0;
+	
+	UcdMsg *ucd = (UcdMsg*) p->accessdata();
+	ucd->Management_Message_Type = 0x00;
+	ucd->Config_Change_Count = 0x01;
+	ucd->Rng_Backoff_Start = 0x00;
+	ucd->Rng_Backoff_End = 0x0F;
+	ucd->Req_Backoff_Start = 0x00;
+	ucd->Req_Backoff_End = 0x0F;
+	for (int i = 0; i < MaxProfileNum; i++) {
+		UplinkBurstProfile *tmp = new UplinkBurstProfile;
+		tmp->Type = 0x01;
+		tmp->Length = sizeof(UplinkBurstProfile);
+		tmp->UIUC = i+1;
+		tmp->FEC_Code_and_modulation_type.Value = i;
+		if (UlBurstProfile_head == NULL) {
+			UlBurstProfile_head = UlBurstProfile_tail = tmp;
+			tmp->next = NULL;
+		} else {
+			UlBurstProfile_tail->next = tmp;
+			UlBurstProfile_tail = tmp;
+			tmp->next = NULL;
+		}
+	}
+	/*Number of UL-MAPs to receive before contention-based reservation is attempted again for the same connection.*/
+	ucd->Contention_based_reservation_timeout.Value = 0x00;
+	/*Size (in units of PS) of PHY payload that SS may use to format and transmit a bandwidth request message in a contention request opportunity.
+	    The value includes all PHY overhead as well as allowance for the MAC data the message may hold.*/
+	ucd->Bandwidth_request_opportunity_size.Value = 0x00;
+	/*Size (in units of PS) of PHY bursts that an SS may use to transmit a RNG-REQ message in a contention ranging request opportunity.
+	    The value includes all PHY overhead as well as the maximum SS/BS round trip propagation delay.*/
+	ucd->Ranging_request_opportunity_size.Value = 0x00;
+	
+	downtarget_->recv(p,this);
+	return;
+}
+
+void 
+Mac802_16::sendDCD()
+{
+	printf("bs  send DCD\n");
+	Packet *p = Packet::alloc();
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	struct hdr_mac *mac = HDR_MAC(p); 
+	struct hdr_mac802_16 *mac16 = HDR_MAC802_16(p);
+	p->allocdata (sizeof (struct DcdMsg));	
+	
+	mac->macDA() = -1;
+	mac->macSA() = NodeID;
+	mac->set(MF_DATA, NodeID);
+	state(MAC_SEND);
+	
+	hdr->uid() = 0;
+    hdr->ptype() = PT_DCD;
+    hdr->size() = sizeof(GenericHdr) + sizeof(DcdMsg) + MaxProfileNum*sizeof(DownlinkBurstProfile)/2;
+    hdr->iface() = -2;
+    hdr->error() = 0; 
+	hdr->txtime() = 2*SymbolLength;
+	
+	mac16->generic_hdr.HT = 0;
+	mac16->generic_hdr.EC = 1;
+	mac16->generic_hdr.Type = 1;
+	mac16->generic_hdr.CI = 1; 
+	mac16->generic_hdr.EKS = 1;
+	mac16->generic_hdr.LEN = 3;
+	mac16->generic_hdr.CID = 0xFFFF;
+	mac16->generic_hdr.HCS = 0;
+	
+	DcdMsg *dcd = (DcdMsg*) p->accessdata();
+	dcd->Management_Message_Type = 0x00;
+	dcd->Config_Change_Count = 0x01;
+
+	for (int i = 0; i < MaxProfileNum; i++) {
+		DownlinkBurstProfile *tmp = new DownlinkBurstProfile;
+		tmp->DIUC = i+1;
+		tmp->FEC_Code_type.Value = i;
+		if (DlBurstProfile_head == NULL) {
+			DlBurstProfile_head = DlBurstProfile_tail = tmp;
+			tmp->next = NULL;
+		} else {
+			DlBurstProfile_tail->next = tmp;
+			DlBurstProfile_tail = tmp;
+			tmp->next = NULL;
+		}
+	}
+	/*Base Station ID.*/
+	dcd->BS_ID.Value = NodeID;
+	/*See 11.1.3.*/
+	dcd->MAC_version.Value = 0x04;
+	
+	downtarget_->recv(p,this);
+	return;
+}
+
+void
+Mac802_16::sendDLMAP()
+{
+	printf("bs  send DL-MAP\n");
+	Packet *p = Packet::alloc();
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	struct hdr_mac *mac = HDR_MAC(p); 
+	struct hdr_mac802_16 *mac16 = HDR_MAC802_16(p);
+	p->allocdata (sizeof (struct DlMapMsg));
+	
+	mac->macDA() = -1;
+	mac->macSA() = NodeID;
+	mac->set(MF_DATA, NodeID);
+	state(MAC_SEND);
+	
+	hdr->uid() = 0;
+	hdr->ptype() = PT_DLMAP;
+	hdr->size() = sizeof(GenericHdr) + sizeof(DlMapMsg) + DlMapIeNum*sizeof(DlMapIe)/2;
+	hdr->iface() = -2;
+	hdr->error() = 0; 
+	hdr->txtime() =  2*SymbolLength;
+	
+	mac16->generic_hdr.HT = 0;
+	mac16->generic_hdr.EC = 1;
+	mac16->generic_hdr.Type = 1;
+	mac16->generic_hdr.CI = 1; 
+	mac16->generic_hdr.EKS = 1;
+	mac16->generic_hdr.LEN = 3;
+	mac16->generic_hdr.CID = 0xFFFF;
+	mac16->generic_hdr.HCS = 0;
+	
+	DlMapMsg *dlmap = (DlMapMsg*) p->accessdata();
+	dlmap->Management_Message_Type = 2;
+	dlmap->DCD_Count = DCD_Counter;
+	dlmap->BS_ID = BsID;
+	dlmap->No_OFDMA_Symbols = DlSymbolNum;
+	dlmap->Frame_duration_code = 0x04;
+	dlmap->Frame_number = FrameNumber_Counter;
+	
+	downtarget_->recv(p,this);
+	return;
+}
+
+void
+Mac802_16::sendULMAP()
+{
+	printf("bs  send UL-MAP\n");
+	Packet *p = Packet::alloc();
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	struct hdr_mac *mac = HDR_MAC(p); 
+	struct hdr_mac802_16 *mac16 = HDR_MAC802_16(p);
+	p->allocdata (sizeof (struct UlMapMsg));
+	
+	mac->macDA() = -1;
+	mac->macSA() = NodeID;
+	mac->set(MF_DATA, NodeID);
+	state(MAC_SEND);
+	
+	hdr->uid() = 0;
+	hdr->ptype() = PT_ULMAP;
+	hdr->size() = sizeof(GenericHdr) + sizeof(UlMapMsg) + UlMapIeNum*sizeof(UlMapIe)/2;
+	hdr->iface() = -2;
+	hdr->error() = 0; 
+	hdr->txtime() = 2*SymbolLength;
+	
+	mac16->generic_hdr.HT = 0;
+	mac16->generic_hdr.EC = 1;
+	mac16->generic_hdr.Type = 1;
+	mac16->generic_hdr.CI = 1; 
+	mac16->generic_hdr.EKS = 1;
+	mac16->generic_hdr.LEN = 3;
+	mac16->generic_hdr.CID = 0xFFFF;
+	mac16->generic_hdr.HCS = 0;
+	
+	UlMapMsg *ulmap = (UlMapMsg*) p->accessdata();
+	ulmap->Management_Message_Type = 0x03;
+	ulmap->UCD_Count = UCD_Counter;
+	ulmap->Allocation_Start_Time = (u_int32_t)Scheduler::instance().clock();
+	AllocationStartTime = Scheduler::instance().clock() //Current time
+							+ SymbolLength //Preamble interval
+							+ DlSymbolNum*SymbolLength //Downlink interval
+							+ TtgLength; //TTG interval
+
+	downtarget_->recv(p,this);
+	return;
+}
+
+void 
+Mac802_16::sendRNGREQ(UlMapIe *IE)
+{ 
+	printf("ss%d send RNG-REQ\n", NodeID);
+	Packet *p = Packet::alloc();
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	struct hdr_mac *mac = HDR_MAC(p); 
+	struct hdr_mac802_16 *mac16 = HDR_MAC802_16(p);
+	p->allocdata (sizeof (struct RngReqMsg));
+	
+	//ModulCoding = CalMod->search(NodeID)->ToMod(CalMod->search(0)->x,CalMod->search(0)->y);
+	mac->macDA() = BsID;
+	mac->macSA() = NodeID;
+	mac->set(MF_DATA, NodeID);
+	state(MAC_SEND);
+	
+	hdr->uid() = 0;
+    hdr->ptype() = PT_RNGREQ;
+    hdr->size() = sizeof(GenericHdr) + sizeof(RngReqMsg);
+    hdr->iface() = -2;
+    hdr->error() = 0; 
+	hdr->txtime() = txtime(hdr->size());
+	
+	mac16->generic_hdr.HT = 0;
+	mac16->generic_hdr.EC = 1;
+	mac16->generic_hdr.Type = 1;
+	mac16->generic_hdr.CI = 1; 
+	mac16->generic_hdr.EKS = 1;
+	mac16->generic_hdr.LEN = 3;
+	mac16->generic_hdr.CID = 0x0000;
+	mac16->generic_hdr.HCS = 0;
+
+	RngReqMsg *rngreq = (RngReqMsg*) p->accessdata();
+	rngreq->Management_Message_Type = 0x04;
+	rngreq->Requested_Downlink_Burst_Profile = DownlinkBurstProfileTable.DIUC;
+	rngreq->SS_MAC_Address = NodeID;
+	rngreq->Ranging_Anomalies = 0;
+	rngreq->AAS_broadcast_capability = 0;
+	
+	uplinkTimer.start(IE->OFDMA_Symbol_offset*SymbolLength, p);
+	return;
+}
+
+void 
+Mac802_16::sendBWREQ(UlMapIe *IE)
+{
+	printf("ss%d send BW-REQ\n", NodeID);
+	Packet *p = Packet::alloc();
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	struct hdr_mac *mac = HDR_MAC(p); 
+	struct hdr_mac802_16 *mac16 = HDR_MAC802_16(p);
+	
+	mac->macDA() = BsID;
+	mac->macSA() = NodeID;
+	mac->set(MF_DATA, NodeID);
+	state(MAC_SEND);
+	
+	hdr->uid() = 0;
+    hdr->ptype() = PT_BWREQ;
+    hdr->size() = sizeof(BwReqHdr);
+    hdr->iface() = -2;
+    hdr->error() = 0; 
+	hdr->txtime() = txtime(hdr->size());
+	
+	mac16->bwreq_hdr.HT = 1;
+	mac16->bwreq_hdr.EC = 1;
+	mac16->bwreq_hdr.Type = 1;
+	SsServiceFlow *sssf;
+
+	sssf = SsSF_head;
+	while (sssf) {
+		//ertPS Bandwidth Request
+		if (sssf->ScheduleType == 5)
+			if (Scheduler::instance().clock() - sssf->QueueTime >= (double)sssf->ToleratedJitter/1000 ) {
+				mac16->bwreq_hdr.BR += sssf->SduQueue.byteLength(); 
+				sssf->BwReqSize = sssf->SduQueue.byteLength(); 
+			}
+		//rtPS and nrtPS Bandwidth Request
+		if (sssf->ScheduleType >= 3 && sssf->ScheduleType <= 4)
+			if (Scheduler::instance().clock() - sssf->QueueTime >= (double)sssf->MaxLatency/1000 ) {
+				mac16->bwreq_hdr.BR += sssf->SduQueue.byteLength(); 
+				sssf->BwReqSize = sssf->SduQueue.byteLength(); 
+			}
+		sssf = sssf->next;
+	}
+	mac16->bwreq_hdr.CID = BasicCID;
+	mac16->bwreq_hdr.HCS = 0;
+	uplinkTimer.start(IE->OFDMA_Symbol_offset*SymbolLength, p);
+	return;
+}
+
+void
+Mac802_16::sendRNGRSP(BsSsInfo *SsInfo)
+{
+	printf("bs  send RNG-RSP to ss%d\n", SsInfo->MacAddr);
+	Packet *p = Packet::alloc();
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	struct hdr_mac *mac = HDR_MAC(p); 
+	struct hdr_mac802_16 *mac16 = HDR_MAC802_16(p);
+	p->allocdata (sizeof (struct RngRspMsg));
+	
+	mac->macDA() = SsInfo->MacAddr;
+	mac->macSA() = NodeID;
+	mac->set(MF_DATA, NodeID);
+	state(MAC_SEND);
+	
+	hdr->uid() = 0;
+    hdr->ptype() = PT_RNGRSP;
+    hdr->size() = sizeof(GenericHdr) + sizeof(RngRspMsg);	
+    hdr->iface() = -2;
+    hdr->error() = 0; 
+	hdr->txtime() = txtime(hdr->size());
+	
+	mac16->generic_hdr.HT = 0;
+	mac16->generic_hdr.EC = 1;
+	mac16->generic_hdr.Type = 1;
+	mac16->generic_hdr.CI = 1; 
+	mac16->generic_hdr.EKS = 1;
+	mac16->generic_hdr.LEN = 3;
+	mac16->generic_hdr.CID = 0x0000;
+	mac16->generic_hdr.HCS = 0;
+	
+	RngRspMsg *rngrsp = (RngRspMsg*) p->accessdata();
+	rngrsp->Timing_Adjust = 0;
+	rngrsp->Power_Level_Adjust = 0;
+	rngrsp->Offset_Frequency_Adjust = 0;
+	rngrsp->Ranging_Status = 3;
+	rngrsp->Downlink_frequency_override = 0;
+	rngrsp->Uplink_channel_ID_override = 0;
+	rngrsp->Downlink_Operational_Burst_Profile = 0;
+	rngrsp->SS_MAC_Address = SsInfo->MacAddr;
+	rngrsp->Basic_CID = SsInfo->BasicCID;
+	rngrsp->Primary_Management_CID = SsInfo->PrimaryCID;
+	rngrsp->AAS_broadcast_permission = 0;
+	
+	downtarget_->recv(p,this);
+	return;
+}
+
+void 
+Mac802_16::sendDSAREQ(SsServiceFlow *SsSF, BsServiceFlow *BsSF)
+{ 
+	Packet *p = Packet::alloc();
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	struct hdr_mac *mac = HDR_MAC(p); 
+	struct hdr_mac802_16 *mac16 = HDR_MAC802_16(p); 
+	p->allocdata (sizeof (struct DsaReqMsg));	
+		
+	if(NodeID == BsID) {
+		printf("bs  send DSA-REQ to ss%d\n", BsSF->MacAddr);
+		
+		mac->macDA() = BsSF->MacAddr;
+		mac->macSA() = NodeID;
+		mac->set(MF_DATA, NodeID);
+		state(MAC_SEND);
+	
+		hdr->uid() = 0;
+		hdr->ptype() = PT_DSAREQ;
+		hdr->size() = sizeof(GenericHdr) + sizeof(DsaReqMsg);
+		hdr->iface() = -2;
+		hdr->error() = 0; 
+		hdr->txtime() = txtime(hdr->size());
+	
+		mac16->generic_hdr.HT = 0;
+		mac16->generic_hdr.EC = 1;
+		mac16->generic_hdr.Type = 1;
+		mac16->generic_hdr.CI = 1; 
+		mac16->generic_hdr.EKS = 1;
+		mac16->generic_hdr.LEN = 3;
+		mac16->generic_hdr.CID = BsSearchSsInfo(BsSF->MacAddr, -1)->PrimaryCID;
+		mac16->generic_hdr.HCS = 0;
+		
+		DsaReqMsg *dsareq = (DsaReqMsg*) p->accessdata();	
+		dsareq->Management_Message_Type = 11;
+		dsareq->Transaction_ID = BsSF->TransactionID;
+		dsareq->Service_Flow_Parameters.CID.Value = BsSF->TransportCID;
+		dsareq->Service_Flow_Parameters.SFID.Value = BsSF->SFID;
+		dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value = BsSF->ScheduleType;
+		if (BsSF->Status == Provisioned) {
+			dsareq->Service_Flow_Parameters.QoS_Parameter_Set_Type.Value = 1;
+		} else if (BsSF->Status == Admitted) {
+			dsareq->Service_Flow_Parameters.QoS_Parameter_Set_Type.Value = 2;
+		} else if (BsSF->Status == Active) {
+			dsareq->Service_Flow_Parameters.QoS_Parameter_Set_Type.Value = 4;
+		}
+		dsareq->Service_Flow_Parameters.Traffic_Priority.Value = BsSF->TrafficPriority;
+		dsareq->Service_Flow_Parameters.Maximum_Sustained_Traffic_Rate.Value = BsSF->MaxTrafficRate;
+		dsareq->Service_Flow_Parameters.Minimum_Reserved_Traffic_Rate.Value = BsSF->MinTrafficRate;
+		dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value = BsSF->ScheduleType;
+		dsareq->Service_Flow_Parameters.Request_Transmission_Policy.Value = BsSF->ReqTxPolicy;
+		dsareq->Service_Flow_Parameters.Tolerated_Jitter.Value = BsSF->ToleratedJitter;
+		dsareq->Service_Flow_Parameters.Maximum_Latency.Value = BsSF->MaxLatency;
+		dsareq->Service_Flow_Parameters.Destination_MAC_Address.Value = BsSF->DstMacAddr;
+		dsareq->Service_Flow_Parameters.Source_MAC_Address.Value = BsSF->SrcMacAddr;
+	} else {
+		printf("ss%d send DSA-REQ\n", NodeID);
+		
+		mac->macDA() = BsID;
+		mac->macSA() = NodeID;
+		mac->set(MF_DATA, NodeID);
+		state(MAC_SEND);
+	
+		hdr->uid() = 0;
+		hdr->ptype() = PT_DSAREQ;
+		hdr->size() = sizeof(GenericHdr) + sizeof(DsaReqMsg);
+		hdr->iface() = -2;
+		hdr->error() = 0; 
+		hdr->txtime() = txtime(hdr->size());
+	
+		mac16->generic_hdr.HT = 0;
+		mac16->generic_hdr.EC = 1;
+		mac16->generic_hdr.Type = 1;
+		mac16->generic_hdr.CI = 1; 
+		mac16->generic_hdr.EKS = 1;
+		mac16->generic_hdr.LEN = 3;
+		mac16->generic_hdr.CID = PrimaryCID;
+		mac16->generic_hdr.HCS = 0;
+		
+		DsaReqMsg *dsareq = (DsaReqMsg*) p->accessdata();	
+		dsareq->Management_Message_Type = 11;
+		dsareq->Transaction_ID = SsSF->TransactionID;
+		dsareq->Service_Flow_Parameters.SFID.Value = 0;
+		if (SsSF->Status == Provisioned) {
+			dsareq->Service_Flow_Parameters.QoS_Parameter_Set_Type.Value = 1;
+		} else if (SsSF->Status == Admitted) {
+			dsareq->Service_Flow_Parameters.QoS_Parameter_Set_Type.Value = 2;
+		} else if (SsSF->Status == Active) {
+			dsareq->Service_Flow_Parameters.QoS_Parameter_Set_Type.Value = 4;
+		}
+		dsareq->Service_Flow_Parameters.Traffic_Priority.Value = SsSF->TrafficPriority;
+		dsareq->Service_Flow_Parameters.Maximum_Sustained_Traffic_Rate.Value = SsSF->MaxTrafficRate;
+		dsareq->Service_Flow_Parameters.Minimum_Reserved_Traffic_Rate.Value = SsSF->MinTrafficRate;
+		dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value = SsSF->ScheduleType;
+		dsareq->Service_Flow_Parameters.Request_Transmission_Policy.Value = SsSF->ReqTxPolicy;
+		dsareq->Service_Flow_Parameters.Tolerated_Jitter.Value = SsSF->ToleratedJitter;
+		dsareq->Service_Flow_Parameters.Maximum_Latency.Value = SsSF->MaxLatency;
+		dsareq->Service_Flow_Parameters.Destination_MAC_Address.Value = SsSF->DstMacAddr;
+		dsareq->Service_Flow_Parameters.Source_MAC_Address.Value = SsSF->SrcMacAddr;
+	}
+	if (Scheduler::instance().clock() >= AllocationStartTime && Scheduler::instance().clock() <= AllocationStartTime + UlSymbolNum*SymbolLength) {
+		downtarget_->recv(p, this);
+	} else {
+		if (NodeID == BsID) {
+			if (Scheduler::instance().clock() < AllocationStartTime)
+				downlinkTimer.start(AllocationStartTime - Scheduler::instance().clock(), p);
+			else
+				downlinkTimer.start(Scheduler::instance().clock() - AllocationStartTime, p);
+		} else {
+			if (Scheduler::instance().clock() < AllocationStartTime)
+				uplinkTimer.start(AllocationStartTime - Scheduler::instance().clock(), p);
+			else
+				uplinkTimer.start(Scheduler::instance().clock() - AllocationStartTime, p);
+		}
+	}
+	return;
+}
+
+void
+Mac802_16::sendDSARSP(SsServiceFlow *SsSF, BsServiceFlow *BsSF)
+{
+	Packet *p = Packet::alloc();
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	struct hdr_mac *mac = HDR_MAC(p); 
+	struct hdr_mac802_16 *mac16 = HDR_MAC802_16(p);
+	p->allocdata (sizeof (struct DsaRspMsg));
+	
+	if(NodeID == BsID) {
+		printf("bs  send DSA-RSP to ss%d\n", BsSF->MacAddr);
+		
+		mac->macDA() = BsSF->MacAddr;
+		mac->macSA() = NodeID;
+		mac->set(MF_DATA, NodeID);
+		state(MAC_SEND);
+	
+		hdr->uid() = 0;
+		hdr->ptype() = PT_DSARSP;
+		hdr->size() = sizeof(GenericHdr) + sizeof(DsaRspMsg);
+		hdr->iface() = -2;
+		hdr->error() = 0; 
+		hdr->txtime() = txtime(hdr->size());
+	
+		mac16->generic_hdr.HT = 0;
+		mac16->generic_hdr.EC = 1;
+		mac16->generic_hdr.Type = 1;
+		mac16->generic_hdr.CI = 1; 
+		mac16->generic_hdr.EKS = 1;
+		mac16->generic_hdr.LEN = 3;
+		mac16->generic_hdr.CID = BsSearchSsInfo(BsSF->MacAddr, -1)->PrimaryCID;
+		mac16->generic_hdr.HCS = 0;
+		
+		DsaRspMsg *dsarsp = (DsaRspMsg*) p->accessdata();
+		dsarsp->Management_Message_Type = 30;
+		dsarsp->Transaction_ID = BsSF->TransactionID;
+		dsarsp->Confirmation_Code = 0x00;	
+		dsarsp->Service_Flow_Parameters.CID.Value = BsSF->TransportCID;
+		dsarsp->Service_Flow_Parameters.SFID.Value = BsSF->SFID;
+	} else {
+		printf("ss%d send DSA-RSP\n", NodeID);
+		
+		mac->macDA() = BsID;
+		mac->macSA() = NodeID;
+		mac->set(MF_DATA, NodeID);
+		state(MAC_SEND);
+	
+		hdr->uid() = 0;
+		hdr->ptype() = PT_DSARSP;
+		hdr->size() = sizeof(GenericHdr) + sizeof(DsaRspMsg);
+		hdr->iface() = -2;
+		hdr->error() = 0; 
+		hdr->txtime() = txtime(hdr->size());
+	
+		mac16->generic_hdr.HT = 0;
+		mac16->generic_hdr.EC = 1;
+		mac16->generic_hdr.Type = 1;
+		mac16->generic_hdr.CI = 1; 
+		mac16->generic_hdr.EKS = 1;
+		mac16->generic_hdr.LEN = 3;
+		mac16->generic_hdr.CID = PrimaryCID;
+		mac16->generic_hdr.HCS = 0;
+		
+		DsaRspMsg *dsarsp = (DsaRspMsg*) p->accessdata();
+		dsarsp->Management_Message_Type = 30;
+		dsarsp->Transaction_ID = SsSF->TransactionID;
+		dsarsp->Confirmation_Code = 0x00;	
+		dsarsp->Service_Flow_Parameters.CID.Value = SsSF->TransportCID;
+		dsarsp->Service_Flow_Parameters.SFID.Value = SsSF->SFID;
+	}
+	downtarget_->recv(p,this);
+	return;
+}
+
+void 
+Mac802_16::sendDSAACK(Packet *pkt)
+{ 
+	Packet *p = Packet::alloc();
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	struct hdr_mac *mac = HDR_MAC(p); 
+	struct hdr_mac802_16 *mac16 = HDR_MAC802_16(p);
+	struct hdr_mac802_16 *mac16_tmp = HDR_MAC802_16(pkt);
+	p->allocdata (sizeof (struct DsaAckMsg));
+	
+	if (NodeID == BsID) {
+		printf("bs  send DSX-ACK to ss%d\n",BsSearchSsInfo(-1, mac16_tmp->generic_hdr.CID)->MacAddr);
+		mac->macDA() = BsSearchSsInfo(-1, mac16_tmp->generic_hdr.CID)->MacAddr;
+		mac->macSA() = NodeID;
+	} else {
+		printf("ss%d send DSX-ACK\n", NodeID);
+		mac->macDA() = NodeID;
+		mac->macSA() = BsID;
+	}
+	mac->set(MF_DATA, NodeID);
+	state(MAC_SEND);
+	
+	hdr->uid() = 0;
+	hdr->ptype() = PT_DSAACK;
+	hdr->size() = sizeof(GenericHdr) + sizeof(DsxRvdMsg);;
+	hdr->iface() = -2;
+	hdr->error() = 0; 
+	hdr->txtime() = txtime(hdr->size());
+	
+	mac16->generic_hdr.HT = 0;
+	mac16->generic_hdr.EC = 1;
+	mac16->generic_hdr.Type = 1;
+	mac16->generic_hdr.CI = 1; 
+	mac16->generic_hdr.EKS = 1;
+	mac16->generic_hdr.LEN = 3;
+	mac16->generic_hdr.CID = mac16_tmp->generic_hdr.CID;
+	mac16->generic_hdr.HCS = 0;
+	
+	DsaAckMsg *dsaack = (DsaAckMsg*) p->accessdata();
+	DsaRspMsg *dsarsp = (DsaRspMsg*) pkt->accessdata();
+	dsaack->Management_Message_Type = 16;
+	dsaack->Transaction_ID = dsarsp->Transaction_ID;
+	dsaack->Confirmation_Code = 0x00;
+
+	downtarget_->recv(p,this);
+	return;
+}
+
+void
+Mac802_16::sendDSXRVD(Packet *pkt)
+{
+	Packet *p = Packet::alloc();
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	struct hdr_mac *mac = HDR_MAC(p); 
+	struct hdr_mac *mac_tmp = HDR_MAC(pkt);
+	struct hdr_mac802_16 *mac16 = HDR_MAC802_16(p);
+	struct hdr_mac802_16 *mac16_tmp = HDR_MAC802_16(pkt);
+	p->allocdata (sizeof (struct DsxRvdMsg));
+	printf("bs  send DSX-RVD to ss%d\n", mac_tmp->macSA());
+	
+	mac->macDA() = mac_tmp->macSA();
+	mac->macSA() = NodeID;
+	mac->set(MF_DATA, NodeID);
+	state(MAC_SEND);
+	
+	hdr->uid() = 0;
+	hdr->ptype() = PT_DSXRVD;
+	hdr->size() = sizeof(GenericHdr) + sizeof(DsxRvdMsg);;
+	hdr->iface() = -2;
+	hdr->error() = 0; 
+	hdr->txtime() = txtime(hdr->size());
+	
+	mac16->generic_hdr.HT = 0;
+	mac16->generic_hdr.EC = 1;
+	mac16->generic_hdr.Type = 1;
+	mac16->generic_hdr.CI = 1; 
+	mac16->generic_hdr.EKS = 1;
+	mac16->generic_hdr.LEN = 3;
+	mac16->generic_hdr.CID = mac16_tmp->generic_hdr.CID;
+	mac16->generic_hdr.HCS = 0;
+	
+	DsxRvdMsg *dsxrvd = (DsxRvdMsg*) p->accessdata();
+	DsaReqMsg *dsareq = (DsaReqMsg*) pkt->accessdata();
+	dsxrvd->Management_Message_Type = 30;
+	dsxrvd->Transaction_ID = dsareq->Transaction_ID;
+	dsxrvd->Confirmation_Code = 0x00;
+	
+	downtarget_->recv(p,this); 
+	return;
+}
+
+bool
+Mac802_16::CallAdmissionControl(Packet *p)
+{
+	return true;
+}
+
+void
+Mac802_16::BandwidthManagement()
+{
+	//printf("----- %d -----\n",FrameNumber_Counter);
+	DlAvailSymbol = (DlSymbolNum-2)*DlSubchanNum;
+	UlAvailSymbol = UlSymbolNum*UlSubchanNum;
+	//printf("[1] Dl %d Ul %d\n",DlAvailSymbol,UlAvailSymbol);
+	int OFDMA_Symbol_offset = 0;
+	int Subchannel_offset = 0;
+	int BytePerSuchan = 0;
+	int UIUC = 0;
+	int DIUC = 0;
+	UlMapIe *ulmapie = NULL;
+	DlMapIe *dlmapie = NULL;
+	BsServiceFlow *bssf;
+	BsSsInfo *ssinfo;
+	ModulCodingType modulcoding = QPSK_12;
+	DlMapIeNum = 0;
+	UlMapIeNum = 0;
+	
+	//Create Data Grant IE
+	bssf = BsSF_head;
+	while (bssf) {
+		if (bssf->Direction == DL && bssf->ScheduleType == 6)
+			BsSearchSsInfo(bssf->MacAddr, -1)->DownlinkBandwidth += bssf->MaxTrafficRate/8/200;
+		if (bssf->Direction == DL && bssf->ScheduleType == 5)	
+			if (Scheduler::instance().clock() - bssf->QueueTime >= (double)bssf->ToleratedJitter/1000 ) {
+				BsSearchSsInfo(bssf->MacAddr, -1)->DownlinkBandwidth += bssf->SduQueue.byteLength();
+				bssf->BwReqSize = bssf->SduQueue.byteLength();
+			}
+		if (bssf->Direction == DL && bssf->ScheduleType >= 3 && bssf->ScheduleType <= 4)
+			if (Scheduler::instance().clock() - bssf->QueueTime >= (double)bssf->MaxLatency/1000 ) {
+				BsSearchSsInfo(bssf->MacAddr, -1)->DownlinkBandwidth += bssf->SduQueue.byteLength(); 
+				bssf->BwReqSize = bssf->SduQueue.byteLength();
+			}
+		if (bssf->Direction == DL && bssf->ScheduleType == 2)
+			if (Scheduler::instance().clock() - bssf->QueueTime >= (double)bssf->MaxLatency/1000) {
+				BsSearchSsInfo(bssf->MacAddr, -1)->DownlinkBandwidth += bssf->MaxTrafficRate/8/200;
+				bssf->BwReqSize = bssf->MaxTrafficRate/8/200;
+			}
+		bssf = bssf->next;
+	}
+	
+	OFDMA_Symbol_offset = 2;
+	modulcoding = QPSK_12;
+	BytePerSuchan = 6;
+	DIUC = 1;
+	ssinfo = BsSsInfo_head;
+	while (ssinfo) {
+		if (ssinfo->ModulCoding == modulcoding && ssinfo->DownlinkBandwidth != 0 && DlAvailSymbol != 0){
+			dlmapie = CreateDlMapIe();
+			dlmapie->CID = ssinfo->BasicCID;
+			dlmapie->DIUC = DIUC;			
+			dlmapie->No_OFDMA_Symbols = ssinfo->DownlinkBandwidth/BytePerSuchan/DlSubchanNum/2;
+			if ((double)ssinfo->DownlinkBandwidth/BytePerSuchan/DlSubchanNum/2 - dlmapie->No_OFDMA_Symbols > 0)
+				dlmapie->No_OFDMA_Symbols += 1;
+			dlmapie->No_Subchannels = DlSubchanNum;
+			if (DlAvailSymbol < dlmapie->No_OFDMA_Symbols*dlmapie->No_Subchannels*2)
+				dlmapie->No_OFDMA_Symbols = DlAvailSymbol/DlSubchanNum/2;
+			if (dlmapie->No_OFDMA_Symbols == 0)
+				dlmapie->No_OFDMA_Symbols = 1;
+			DlAvailSymbol -= dlmapie->No_OFDMA_Symbols*dlmapie->No_Subchannels*2;
+			dlmapie->OFDMA_Symbol_offset = OFDMA_Symbol_offset;
+			dlmapie->Subchannel_offset = 0;
+			dlmapie->Boosting = 0;
+			dlmapie->Repetition_Coding_Indication = 0;
+			OFDMA_Symbol_offset += dlmapie->No_OFDMA_Symbols;
+			DlMapIeNum++;		
+		}
+		ssinfo = ssinfo->next;
+		if (!ssinfo) {
+			switch (modulcoding) {
+				case QPSK_12: ssinfo = BsSsInfo_head; modulcoding = QPSK_34; BytePerSuchan = 9; DIUC = 2; break;
+				case QPSK_34: ssinfo = BsSsInfo_head; modulcoding = QAM16_12; BytePerSuchan = 12; DIUC = 3; break;
+				case QAM16_12:ssinfo = BsSsInfo_head; modulcoding = QAM16_34; BytePerSuchan = 18; DIUC = 4; break;
+				case QAM16_34:ssinfo = BsSsInfo_head; modulcoding = QAM64_23; BytePerSuchan = 24; DIUC = 5; break;
+				case QAM64_23:ssinfo = BsSsInfo_head; modulcoding = QAM64_34; BytePerSuchan = 27; DIUC = 6; break;
+				case QAM64_34:break;	
+			}
+		}
+	}
+	
+	//Create Initial Ranging IE
+	Subchannel_offset = 0;
+	ulmapie = CreateUlMapIe();
+	ulmapie->CID = 0xFFFF;
+	ulmapie->UIUC = 0xC;
+	ulmapie->No_OFDMA_Symbols = UlSymbolNum;
+	ulmapie->No_Subchannels = 0x01;
+	ulmapie->Ranging_Method = 0x00;
+	ulmapie->OFDMA_Symbol_offset = 0x00;
+	ulmapie->Subchannel_offset = 0x00;
+	UlAvailSymbol -= ulmapie->No_OFDMA_Symbols;
+	Subchannel_offset += ulmapie->No_Subchannels;
+	UlMapIeNum++;
+	
+	//Create BW Request IE
+	OFDMA_Symbol_offset = 0;
+	bssf = BsSF_head;
+	while (bssf) {
+		if (bssf->Direction == UL && bssf->ScheduleType >= 3 && bssf->ScheduleType <= 5) {
+			if (!BsSearchSsInfo(bssf->MacAddr, -1)->PollingStatus && Scheduler::instance().clock() - bssf->LastPollingTime >= (double)bssf->PollingInterval/1000) {
+				bssf->LastPollingTime = Scheduler::instance().clock();
+				BsSearchSsInfo(bssf->MacAddr, -1)->PollingStatus = true;
+				ulmapie = CreateUlMapIe();
+				ulmapie->CID = BsSearchSsInfo(bssf->MacAddr, -1)->BasicCID;
+				ulmapie->UIUC = 0xC;
+				ulmapie->No_OFDMA_Symbols = 0x02;
+				ulmapie->No_Subchannels = 0x01;	
+				ulmapie->Ranging_Method = 0x00;
+				UlAvailSymbol -= ulmapie->No_OFDMA_Symbols;
+				if (OFDMA_Symbol_offset < UlSymbolNum) {
+					ulmapie->OFDMA_Symbol_offset = OFDMA_Symbol_offset;
+					ulmapie->Subchannel_offset = Subchannel_offset;
+					OFDMA_Symbol_offset += ulmapie->No_OFDMA_Symbols;
+				} else {
+					ulmapie->OFDMA_Symbol_offset = 0x00;	
+					ulmapie->Subchannel_offset = ++Subchannel_offset;
+					OFDMA_Symbol_offset = 0;
+				}				
+				UlMapIeNum++;
+			}
+		}
+		bssf = bssf->next;
+	}
+	
+	//Create Data Grant IE
+	bssf = BsSF_head;
+	while (bssf) {
+		if (bssf->Direction == UL && bssf->ScheduleType == 6)
+			BsSearchSsInfo(bssf->MacAddr, -1)->UplinkBandwidth += bssf->MaxTrafficRate/8/200;
+		if (bssf->Direction == UL && bssf->ScheduleType == 2)
+			if (Scheduler::instance().clock() - bssf->LastPollingTime >= (double)bssf->PollingInterval/1000) {
+				BsSearchSsInfo(bssf->MacAddr, -1)->UplinkBandwidth += bssf->MaxTrafficRate/8/200;
+				bssf->BwReqSize = bssf->MaxTrafficRate/8/200;
+				bssf->LastPollingTime = Scheduler::instance().clock();
+			}
+		bssf = bssf->next;
+	}
+	
+	modulcoding = QPSK_12;
+	BytePerSuchan = 6;
+	UIUC = 1;
+	ssinfo = BsSsInfo_head;
+	while (ssinfo) {
+		if (ssinfo->ModulCoding == modulcoding && ssinfo->UplinkBandwidth != 0 && UlAvailSymbol != 0){
+			ulmapie = CreateUlMapIe();
+			ulmapie->CID = ssinfo->BasicCID;
+			ulmapie->UIUC = UIUC;
+			ulmapie->Duration = ssinfo->UplinkBandwidth/BytePerSuchan/3;
+			if ((double)ssinfo->UplinkBandwidth/BytePerSuchan/BytePerSuchan/3 - ulmapie->Duration > 0)
+				ulmapie->Duration += 1;
+			if (UlAvailSymbol < ulmapie->Duration*3)
+				ulmapie->Duration = UlAvailSymbol/3;
+			if (ulmapie->Duration == 0)
+				ulmapie->Duration = 1;
+			UlAvailSymbol -= ulmapie->Duration*3;
+			ulmapie->Repetition_Coding_Indication = 0;
+			UlMapIeNum++;
+		}
+		ssinfo = ssinfo->next;
+		if (!ssinfo) {
+			switch (modulcoding) {
+				case QPSK_12: ssinfo = BsSsInfo_head; modulcoding = QPSK_34; BytePerSuchan = 9; UIUC = 2; break;
+				case QPSK_34: ssinfo = BsSsInfo_head; modulcoding = QAM16_12; BytePerSuchan = 12; UIUC = 3; break;
+				case QAM16_12:ssinfo = BsSsInfo_head; modulcoding = QAM16_34; BytePerSuchan = 18; UIUC = 4; break;
+				case QAM16_34:ssinfo = BsSsInfo_head; modulcoding = QAM64_23; BytePerSuchan = 24; UIUC = 5; break;
+				case QAM64_23:ssinfo = BsSsInfo_head; modulcoding = QAM64_34; BytePerSuchan = 27; UIUC = 6; break;
+				case QAM64_34:break;	
+			}
+		}
+	}
+	
+	ssinfo = BsSsInfo_head;
+	while (ssinfo) {
+		ssinfo->PollingStatus = false;
+		ssinfo->DownlinkBandwidth = 0;
+		ssinfo->UplinkBandwidth = 0;
+		ssinfo = ssinfo->next;
+	}
+	//printf("[2] Dl %d Ul %d\n",DlAvailSymbol,UlAvailSymbol);
+	sendDLMAP();
+	sendULMAP();
+	if (FrameNumber_Counter%100 == 0) {
+		DCD_Counter++;
+		sendDCD();
+		UCD_Counter++;
+		sendUCD();
+	}
+	dlmapTimer.start(2*SymbolLength);
+	return;
+}
+
+void
+Mac802_16::BsScheduler()
+{
+	DlMapIe *dlmapie = NULL;
+	dlmapie = DlMapIe_head;
+	while (dlmapie) {
+		if (BsSearchSsInfo(-1, dlmapie->CID)) {
+			int Bandwidth = 0;
+			int TrafficPriority = 0;
+			switch (BsSearchSsInfo(-1, dlmapie->CID)->ModulCoding) {
+				case QPSK_12: Bandwidth = dlmapie->No_OFDMA_Symbols*dlmapie->No_Subchannels*6*2; break;
+				case QPSK_34: Bandwidth = dlmapie->No_OFDMA_Symbols*dlmapie->No_Subchannels*9*2; break;
+				case QAM16_12:Bandwidth = dlmapie->No_OFDMA_Symbols*dlmapie->No_Subchannels*12*2; break;
+				case QAM16_34:Bandwidth = dlmapie->No_OFDMA_Symbols*dlmapie->No_Subchannels*18*2; break;
+				case QAM64_23:Bandwidth = dlmapie->No_OFDMA_Symbols*dlmapie->No_Subchannels*24*2; break;
+				case QAM64_34:Bandwidth = dlmapie->No_OFDMA_Symbols*dlmapie->No_Subchannels*27*2; break;	
+			}
+			BsServiceFlow *bssf = NULL;
+			bssf = BsSF_head;
+			while (bssf) {
+				if (bssf->Direction == DL && bssf->Status == Active && bssf->ScheduleType == 6 && BsSearchSsInfo(bssf->MacAddr, -1)->BasicCID == dlmapie->CID) {
+					//printf("Downlink Bandwidth %d CID %d UGS SFID=%d req size %d[%d]\n",Bandwidth,dlmapie->CID,bssf->SFID,bssf->SduQueue.byteLength(),bssf->SduQueue.count(bssf->SduQueue.byteLength()));
+					BsFragOrPack(bssf, bssf->SduQueue.count(bssf->SduQueue.byteLength()));
+					Bandwidth -= bssf->PduQueue.byteLength();
+					//printf("\tbs SduQ=%d\tPduQ=%d\n",bssf->SduQueue.byteLength(),bssf->PduQueue.byteLength());
+				}
+				if (bssf->Direction == DL && bssf->Status == Active && bssf->BwReqSize != 0 && bssf->ScheduleType >= 3 && bssf->ScheduleType <= 5 && BsSearchSsInfo(bssf->MacAddr, -1)->BasicCID == dlmapie->CID) {
+					//printf("Downlink Bandwidth %d CID %d Polling SFID=%d req size %d[%d]\n",Bandwidth,dlmapie->CID,bssf->SFID,bssf->BwReqSize,bssf->SduQueue.count(bssf->BwReqSize));
+					BsFragOrPack(bssf, bssf->SduQueue.count(bssf->BwReqSize));
+					bssf->BwReqSize = 0;
+					Bandwidth -= bssf->PduQueue.byteLength();
+					//printf("\tbs SduQ=%d\tPduQ=%d\n",bssf->SduQueue.byteLength(),bssf->PduQueue.byteLength());
+				}
+				if (bssf->Direction == DL && bssf->Status == Active && bssf->ScheduleType == 2 && BsSearchSsInfo(bssf->MacAddr, -1)->BasicCID == dlmapie->CID) {
+					TrafficPriority += bssf->TrafficPriority;
+				}
+				bssf = bssf->next;
+			}
+			if (Bandwidth > 0 && TrafficPriority > 0) {
+				bssf = BsSF_head;
+				while (bssf) {
+					if (bssf->Direction == DL && bssf->Status == Active && bssf->ScheduleType == 2 && BsSearchSsInfo(bssf->MacAddr, -1)->BasicCID == dlmapie->CID) {
+						//printf("Downlink Bandwidth %d CID %d BE SFID=%d req size %d[%d]\n",Bandwidth,dlmapie->CID,bssf->SFID,Bandwidth*bssf->TrafficPriority/TrafficPriority,bssf->SduQueue.count(Bandwidth*bssf->TrafficPriority/TrafficPriority));
+						BsFragOrPack(bssf, bssf->SduQueue.count(Bandwidth*bssf->TrafficPriority/TrafficPriority));
+						//printf("\tbs SduQ=%d\tPduQ=%d\n",bssf->SduQueue.byteLength(),bssf->PduQueue.byteLength());
+					}
+					bssf = bssf->next;
+				}
+			}
+		}
+		dlmapie = dlmapie->next;
+	}
+	BsBurstTransmit();
+	return;
+}
+
+void
+Mac802_16::SsScheduler()
+{
+	UlMapIe *ulmapie;
+	if (!RangingStatus) {
+		//Initial Ranging IE
+		ulmapie = UlMapIe_head;
+		while (ulmapie) {
+			if (ulmapie->UIUC == 0xC && ulmapie->CID == 0xFFFF)
+				sendRNGREQ(ulmapie);
+			ulmapie = ulmapie->next;
+		}
+	} else {
+		//Data Grant IE
+		ulmapie = UlMapIe_head;
+		while (ulmapie) {
+			if (ulmapie->UIUC != 0xC && ulmapie->CID == BasicCID) {
+				int Bandwidth = 0;
+				int TrafficPriority = 0;
+				switch (ModulCoding) {
+					case QPSK_12: Bandwidth = ulmapie->Duration*6*3; break;
+					case QPSK_34: Bandwidth = ulmapie->Duration*9*3; break;
+					case QAM16_12:Bandwidth = ulmapie->Duration*12*3; break;
+					case QAM16_34:Bandwidth = ulmapie->Duration*18*3; break;
+					case QAM64_23:Bandwidth = ulmapie->Duration*24*3; break;
+					case QAM64_34:Bandwidth = ulmapie->Duration*27*3; break;	
+				}
+				SsServiceFlow *sssf;
+				sssf = SsSF_head;
+				while (sssf) {
+					if (sssf->Status == Active && sssf->ScheduleType == 6) {
+						//printf("Uplink Bandwidth %d UGS SFID=%d req size %d[%d]\n",Bandwidth,sssf->SFID,sssf->SduQueue.byteLength(),sssf->SduQueue.count(sssf->SduQueue.byteLength()));
+						SsFragOrPack(sssf, sssf->SduQueue.count(sssf->SduQueue.byteLength()));
+						Bandwidth -= sssf->PduQueue.byteLength();
+						//printf("\tss SduQ=%d\tPduQ=%d\n",sssf->SduQueue.byteLength(),sssf->PduQueue.byteLength());
+					}
+					if (sssf->Status == Active && sssf->BwReqSize != 0 && sssf->ScheduleType >= 3 && sssf->ScheduleType <= 5 ) {
+						//printf("Uplink Bandwidth %d Polling SFID=%d req size %d[%d]\n",Bandwidth,sssf->SFID,sssf->BwReqSize,sssf->SduQueue.count(sssf->BwReqSize));
+						SsFragOrPack(sssf, sssf->SduQueue.count(sssf->BwReqSize));
+						sssf->BwReqSize = 0;
+						Bandwidth -= sssf->PduQueue.byteLength();
+						//printf("\tss SduQ=%d\tPduQ=%d\n",sssf->SduQueue.byteLength(),sssf->PduQueue.byteLength());
+					}
+					if (sssf->Status == Active && sssf->ScheduleType == 2) {
+						TrafficPriority += sssf->TrafficPriority;
+					}
+					sssf = sssf->next;
+				}
+				if (Bandwidth > 0 && TrafficPriority > 0) {
+					sssf = SsSF_head;
+					while (sssf) {
+						if (sssf->Status == Active && sssf->ScheduleType == 2) {
+							//printf("Uplink Bandwidth %d BE SFID=%d req size %d[%d]\n",Bandwidth,sssf->SFID,Bandwidth*sssf->TrafficPriority/TrafficPriority,sssf->SduQueue.count(Bandwidth*sssf->TrafficPriority/TrafficPriority));
+							SsFragOrPack(sssf, sssf->SduQueue.count(Bandwidth*sssf->TrafficPriority/TrafficPriority));
+							//printf("\tss SduQ=%d\tPduQ=%d\n",sssf->SduQueue.byteLength(),sssf->PduQueue.byteLength());
+						}
+						sssf = sssf->next;
+					}
+				}
+			}
+			ulmapie = ulmapie->next;
+		}
+		
+		//BW Request IE
+		ulmapie = UlMapIe_head;
+		while (ulmapie) {
+			if (ulmapie->UIUC == 0xC && ulmapie->CID == BasicCID)
+				sendBWREQ(ulmapie);
+			ulmapie = ulmapie->next;
+		}
+	}
+	SsBurstTransmit();
+	return;
+}
+
+void 
+Mac802_16::BsFragOrPack(BsServiceFlow *BsSF, int Size)
+{	
+	//printf("[1]BS SDU num=%d PDU num=%d\n",BsSF->SduQueue.length(),BsSF->PduQueue.length());
+	static int32_t tmp_size = PDUSIZE;	
+	Packet* frag;
+	Packet* sdu;
+BsStart:	
+	while (Size) {				
+		sdu = BsSF->SduQueue.deque();		
+		struct hdr_cmn* sdu_hdr = HDR_CMN(sdu);
+	    struct hdr_mac802_16* sdu_mac16 = HDR_MAC802_16(sdu);	
+		
+		if (sdu_hdr->size() <= tmp_size) {
+			//need to pack
+			sdu_mac16->generic_hdr.Type = 0x01;	
+			sdu->type_ = 1;	
+			struct subhdr_pack* psh = SUBHDR_Pack(sdu);
+			//printf("Add packing subheader FSN:%d\n",psh->FSN);
+			psh->FSN = (psh->FSN + 1)%8;				
+			if (sdu_hdr->size() < tmp_size) {
+				//Add PACKing subheader; add SDU or SDU fragment					
+				psh->FC = 0x0;
+				psh->Length = sdu_hdr->size();
+				tmp_size -= sdu_hdr->size();
+				//printf("Need to Pack:\n");	
+				Packet::free(sdu);
+			} else {
+				//add PACKing subheader; add fragment					
+				psh->FC = 0x2;
+				frag = sdu;   
+				BsSF->PduQueue.enque(sdu);	
+				//printf("[1]Complete a MPDU\nPacking with fragmetation; The remaining fragment is stored in queue\n");					
+				tmp_size = PDUSIZE;								
+			}
+			Size--;
+			goto BsStart;				
+		} else {
+			//Need fragmetation
+        	sdu_mac16->generic_hdr.Type = 0x04; 
+			sdu->type_ = 2;		
+			if (BsSF->FragQueue.length() != 0) { 		
+BsFragQueue:	
+				//Fragment-queue is not empty;
+				Packet::free(sdu);				
+				frag = BsSF->FragQueue.deque();
+				struct hdr_cmn* frag_hdr = HDR_CMN(frag);
+				struct subhdr_frag* fsh = SUBHDR_Frag(frag);				
+				//printf("Add fragmentation subheader FSN:%d\n",fsh->FSN);
+				fsh->FSN = (fsh->FSN + 1)%8;				
+				if (frag_hdr->size() <= tmp_size) {
+					//Add SDU to payload
+					//printf("Add SDU to payload\nLast Fragment\n");						
+					if (frag_hdr->size() < tmp_size) {
+						// last fragment  need pack
+						fsh->FC = 0x1;
+						tmp_size -= frag_hdr->size();
+						Packet::free(frag);
+					} else {
+						// last fragment
+						fsh->FC = 0x1;
+						// printf("Complete a MPDU\n\n");							 
+						tmp_size = PDUSIZE;	
+						BsSF->PduQueue.enque(frag);					
+					}	
+				} else {
+					// continue fragment	
+					fsh->FC = 0x3;		
+					//printf("Continue Fragment\n");
+					int i = frag_hdr->size();
+					frag_hdr->size() = tmp_size;
+					BsSF->PduQueue.enque(frag->copy());
+					frag_hdr->size() = i - tmp_size;
+					BsSF->FragQueue.enque(frag);
+					//printf("[2]Complete a MPDU\n The remaining fragment is stored in queue\n");					
+					tmp_size = PDUSIZE;
+					goto BsFragQueue;	
+				}
+			} else {
+				//there're no fragments in fragment-queue
+				struct hdr_cmn* sdu_hdr = HDR_CMN(sdu);
+				struct subhdr_frag* fsh = SUBHDR_Frag(sdu);
+				//printf("Add fragmentation subheader FSN:%d\n",fsh->FSN);
+				fsh->FSN = (fsh->FSN + 1)%8;
+				if (sdu_hdr->size() > tmp_size) {
+					//need to fragmentation
+					int i = sdu_hdr->size();
+					sdu_hdr->size() = PDUSIZE;
+					//printf("First Fragmentaton\n");					 					
+					fsh->FC = 0x2;  //first fragment
+					BsSF->PduQueue.enque(sdu->copy());
+					sdu_hdr->size() = i - tmp_size;
+					BsSF->FragQueue.enque(sdu);
+					//printf("[3]Complete a MPDU\n The remaining fragment is stored in queue\n");					
+					tmp_size = PDUSIZE;					
+					goto BsFragQueue;
+				}
+			}
+		}
+		Size--;
+	}
+	//printf("[2]BS SDU num=%d PDU num=%d\n",BsSF->SduQueue.length(),BsSF->PduQueue.length());
+	return;
+}
+
+void 
+Mac802_16::SsFragOrPack(SsServiceFlow *SsSF, int Size)
+{	
+	//printf("[1]SS SDU num=%d PDU num=%d\n",SsSF->SduQueue.length(),SsSF->PduQueue.length());
+	static int32_t tmp_size = PDUSIZE;	
+	Packet* frag;
+	Packet* sdu;
+SsStart:	
+	while (Size) {				
+		sdu = SsSF->SduQueue.deque();		
+		struct hdr_cmn* sdu_hdr = HDR_CMN(sdu);
+	    struct hdr_mac802_16* sdu_mac16 = HDR_MAC802_16(sdu);		
+		if (sdu_hdr->size() <= tmp_size) {
+			//need to pack
+			sdu_mac16->generic_hdr.Type = 0x01;	
+			sdu->type_ = 1;	
+			struct subhdr_pack* psh = SUBHDR_Pack(sdu);
+			//printf("Add packing subheader FSN:%d\n",psh->FSN);
+			psh->FSN = (psh->FSN + 1)%8;				
+			if (sdu_hdr->size() < tmp_size) {
+				//Add PACKing subheader; add SDU or SDU fragment					
+				psh->FC = 0x0;
+				psh->Length = sdu_hdr->size();
+				tmp_size -= sdu_hdr->size();
+				//printf("Need to Pack:\n");	
+				Packet::free(sdu);
+			} else {
+				//add PACKing subheader; add fragment					
+				psh->FC = 0x2;
+				frag = sdu;
+				SsSF->PduQueue.enque(sdu);	
+				//printf("[1]Complete a MPDU\nPacking with fragmetation; The remaining fragment is stored in queue\n");					
+				tmp_size = PDUSIZE;								
+			}
+			Size--;
+			goto SsStart;				
+		} else {
+			//Need fragmetation
+        	sdu_mac16->generic_hdr.Type = 0x04; 
+			sdu->type_ = 2;		
+			if (SsSF->FragQueue.length() != 0) { 		
+SsFragQueue:	
+				//Fragment-queue is not empty;
+				Packet::free(sdu);		
+				frag = SsSF->FragQueue.deque();
+				struct hdr_cmn* frag_hdr = HDR_CMN(frag);
+				struct subhdr_frag* fsh = SUBHDR_Frag(frag);				
+				//printf("Add fragmentation subheader FSN:%d\n",fsh->FSN);
+				fsh->FSN = (fsh->FSN + 1)%8;				
+				if (frag_hdr->size() <= tmp_size) {
+					//Add SDU to payload
+					//printf("Add SDU to payload\nLast Fragment\n");						
+					if (frag_hdr->size() < tmp_size) {
+						// last fragment  need pack
+						fsh->FC = 0x1;
+						tmp_size -= frag_hdr->size();
+						Packet::free(frag);
+					} else {
+						// last fragment
+						fsh->FC = 0x1;
+						// printf("Complete a MPDU\n\n");							 
+						tmp_size = PDUSIZE;	
+						SsSF->PduQueue.enque(frag);					
+					}	
+				} else {
+					// continue fragment	
+					fsh->FC = 0x3;		
+					//printf("Continue Fragment\n");
+					int i = frag_hdr->size();
+					frag_hdr->size() = tmp_size;
+					SsSF->PduQueue.enque(frag->copy());
+					frag_hdr->size() = i - tmp_size;
+					SsSF->FragQueue.enque(frag);
+					//printf("[2]Complete a MPDU\n The remaining fragment is stored in queue\n");					
+					tmp_size = PDUSIZE;
+					goto SsFragQueue;	
+				}
+			} else {
+				//there're no fragments in fragment-queue
+				struct hdr_cmn* sdu_hdr = HDR_CMN(sdu);
+				struct subhdr_frag* fsh = SUBHDR_Frag(sdu);
+				//printf("Add fragmentation subheader FSN:%d\n",fsh->FSN);
+				fsh->FSN = (fsh->FSN + 1)%8;
+				if (sdu_hdr->size() > tmp_size) {
+					//need to fragmentation
+					int i = sdu_hdr->size();
+					sdu_hdr->size() = PDUSIZE;
+					//printf("First Fragmentaton\n");					 					
+					fsh->FC = 0x2;  //first fragment
+					SsSF->PduQueue.enque(sdu->copy());
+					sdu_hdr->size() = i - tmp_size;
+					SsSF->FragQueue.enque(sdu);
+					//printf("[3]Complete a MPDU\n The remaining fragment is stored in queue\n");					
+					tmp_size = PDUSIZE;					
+					goto SsFragQueue;
+				}
+			}
+		}
+		Size--;
+	}
+	//printf("[2]SS SDU num=%d PDU num=%d\n",SsSF->SduQueue.length(),SsSF->PduQueue.length());*/
+	return;
+}
+
+void
+Mac802_16::BsBurstTransmit()
+{
+	BsServiceFlow *bssf = NULL;
+	bssf = BsSF_head;
+	while (bssf) {
+		while (bssf->Direction == DL && bssf->PduQueue.length() != 0) {
+			Packet *p = bssf->PduQueue.deque();
+			struct hdr_cmn *hdr = HDR_CMN(p);
+			struct hdr_mac *mac = HDR_MAC(p); 
+			struct hdr_mac802_16 *mac16 = HDR_MAC802_16(p);
+
+			mac->macDA() = bssf->MacAddr;
+			mac->macSA() = BsID;
+			mac->set(MF_DATA, NodeID);
+			state(MAC_SEND);
+	
+			hdr->uid() = 0;
+			hdr->size() += sizeof(GenericHdr);
+			hdr->iface() = -2;
+			hdr->error() = 0; 
+			hdr->txtime() = SymbolLength;
+	
+			mac16->generic_hdr.HT = 0;
+			mac16->generic_hdr.EC = 1;
+			mac16->generic_hdr.Type = 1;
+			mac16->generic_hdr.CI = 1; 
+			mac16->generic_hdr.EKS = 1;
+			mac16->generic_hdr.LEN = 3;
+			mac16->generic_hdr.CID = bssf->TransportCID;
+			mac16->generic_hdr.HCS = 0;
+			
+			//printf("bs  send pkt\n");
+			downtarget_->recv(p, this);
+			bssf->QueueTime = Scheduler::instance().clock();			
+		}		
+		//printf("bs  SFID=%d\tSduQ=%d\tPduQ=%d\tFragQ=%d\n",bssf->SFID,bssf->SduQueue.length(),bssf->PduQueue.length(),bssf->FragQueue.length());
+		bssf = bssf->next;
+	}
+	return;
+}
+
+void
+Mac802_16::SsBurstTransmit()
+{
+	SsServiceFlow *sssf = NULL;
+	sssf = SsSF_head;
+	while (sssf) {
+		while (sssf->PduQueue.length() != 0) {
+			Packet *p = sssf->PduQueue.deque();
+			struct hdr_cmn *hdr = HDR_CMN(p);
+			struct hdr_mac *mac = HDR_MAC(p); 
+			struct hdr_mac802_16 *mac16 = HDR_MAC802_16(p);
+
+			mac->macDA() = BsID;
+			mac->macSA() = NodeID;
+			mac->set(MF_DATA, NodeID);
+			state(MAC_SEND);
+	
+			hdr->uid() = 0;
+			hdr->size() += sizeof(GenericHdr);
+			hdr->iface() = -2;
+			hdr->error() = 0; 
+			hdr->txtime() = SymbolLength;
+	
+			mac16->generic_hdr.HT = 0;
+			mac16->generic_hdr.EC = 1;
+			mac16->generic_hdr.Type = 1;
+			mac16->generic_hdr.CI = 1; 
+			mac16->generic_hdr.EKS = 1;
+			mac16->generic_hdr.LEN = 3;
+			mac16->generic_hdr.CID = sssf->TransportCID;
+			mac16->generic_hdr.HCS = 0;
+			
+			//printf("  ss%d sendpkt\n",NodeID);
+			downtarget_->recv(p, this);
+			sssf->QueueTime = Scheduler::instance().clock();
+		}	
+		//printf("ss%d SFID=%d\tSduQ=%d\tPduQ=%d\tFragQ=%d\n",NodeID,sssf->SFID,sssf->SduQueue.length(),sssf->PduQueue.length(),sssf->FragQueue.length());
+		sssf = sssf->next;
+	}
+	return;
+}
+
+BsSsInfo*
+Mac802_16::BsSearchSsInfo(int MacAddr, int CID)
+{
+	BsSsInfo *ssinfo = NULL;
+	ssinfo = BsSsInfo_head;
+
+	if (CID != -1) {
+		while (ssinfo) {
+			if (ssinfo->BasicCID == CID || ssinfo->PrimaryCID == CID)
+				return ssinfo; 
+			else
+				ssinfo = ssinfo->next;
+		}
+	} else {
+		while (ssinfo) {
+			if (ssinfo->MacAddr == MacAddr)
+				return ssinfo; 
+			else
+				ssinfo = ssinfo->next;
+		}		
+	}
+	return NULL;
+}
+
+BsSsInfo*
+Mac802_16::BsCreateSsInfo(Packet *p)
+{	
+	struct hdr_mac *mac = HDR_MAC(p);
+	RngReqMsg *rngreq = (RngReqMsg*) p->accessdata(); 
+	printf("\tbs  create ss%d info\n", mac->macSA());
+	
+	BsSsInfo *ssinfo = new BsSsInfo;
+	ssinfo->MacAddr = rngreq->SS_MAC_Address;
+	ssinfo->BasicCID = BasicCID_Counter++;
+	ssinfo->PrimaryCID = PrimaryCID_Counter++;
+	
+	switch (rngreq->Requested_Downlink_Burst_Profile - 1) {
+		case 0:ssinfo->ModulCoding = QPSK_12; break;
+		case 1:ssinfo->ModulCoding = QPSK_34; break;
+		case 2:ssinfo->ModulCoding = QAM16_12; break;
+		case 3:ssinfo->ModulCoding = QAM16_34; break;
+		case 4:ssinfo->ModulCoding = QAM64_23; break;
+		case 5:ssinfo->ModulCoding = QAM64_34; break;
+	}
+
+	if (!BsSsInfo_head) {
+		BsSsInfo_head = BsSsInfo_tail = ssinfo;
+		ssinfo->next = NULL;
+	} else {
+		BsSsInfo_tail->next = ssinfo;
+		BsSsInfo_tail = ssinfo;
+		ssinfo->next = NULL;
+	}
+	return ssinfo;
+}
+
+BsServiceFlow*
+Mac802_16::BsSearchServiceFlow(int SrcMacAddr, int DstMacAddr, packet_t ptype, SfDirection Direction, int TransactionID, int CID)
+{
+	int ScheduleType;
+	BsServiceFlow *bssf = NULL;
+	bssf = BsSF_head;
+	switch (ptype) {
+		case PT_UGS: ScheduleType = 0x06; break;
+		case PT_ertPS: ScheduleType = 0x05; break;
+		case PT_rtPS: ScheduleType = 0x04; break;
+		case PT_nrtPS: ScheduleType = 0x03; break;
+		case PT_BE: ScheduleType = 0x02; break;
+		default: break;
+	}
+	
+	if (TransactionID != -1) {
+		while (bssf) {
+			if (bssf->TransactionID == TransactionID)
+				return bssf;
+			else
+				bssf = bssf->next;
+		}
+	} else if (TransactionID == -1 && CID != -1) {
+		while (bssf) {
+			if (bssf->TransportCID == CID)
+				return bssf;
+			else
+				bssf = bssf->next;
+		}
+	} else {
+		while (bssf) {
+			if (bssf->SrcMacAddr == SrcMacAddr && bssf->DstMacAddr == DstMacAddr && bssf->ScheduleType == ScheduleType && bssf->Direction == Direction)
+				return bssf;
+			else
+				bssf = bssf->next;
+		}
+	}
+	return NULL;
+}
+
+BsServiceFlow*
+Mac802_16::BsCreateServiceFlow(Packet *p, SfDirection Direction)
+{
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	struct hdr_mac *mac = HDR_MAC(p);
+	struct hdr_mac802_16 *mac16 = HDR_MAC802_16(p);	
+	DsaReqMsg *dsareq = (DsaReqMsg*) p->accessdata();
+	BsServiceFlow *bssf = new BsServiceFlow;
+
+	if (!CallAdmissionControl(p)) {
+		delete bssf;
+		return NULL;
+	}
+	
+	if (Direction == UL) {
+		bssf->MacAddr = BsSearchSsInfo(-1, mac16->generic_hdr.CID)->MacAddr;
+		bssf->DstMacAddr = dsareq->Service_Flow_Parameters.Destination_MAC_Address.Value;
+		bssf->SrcMacAddr = dsareq->Service_Flow_Parameters.Source_MAC_Address.Value;
+		bssf->TransactionID = dsareq->Transaction_ID;
+		bssf->TransportCID = TransportCID_Counter++;
+		if (dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value == 0x06) {	
+			bssf->SFID = (ServiceFlowID_Counter0++)*10;
+			bssf->MaxTrafficRate = dsareq->Service_Flow_Parameters.Maximum_Sustained_Traffic_Rate.Value;
+			bssf->MinTrafficRate = dsareq->Service_Flow_Parameters.Minimum_Reserved_Traffic_Rate.Value;
+			bssf->ToleratedJitter = dsareq->Service_Flow_Parameters.Tolerated_Jitter.Value;
+			bssf->MaxLatency = dsareq->Service_Flow_Parameters.Maximum_Latency.Value;
+			bssf->ReqTxPolicy = dsareq->Service_Flow_Parameters.Request_Transmission_Policy.Value;
+			printf("\tbs  create ss%d UL UGS SF sfid=%d\n",BsSearchSsInfo(-1, mac16->generic_hdr.CID)->MacAddr,bssf->SFID);	
+		} else if (dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value == 0x05) { 	
+			bssf->SFID = (ServiceFlowID_Counter1++)*10 + 1;
+			bssf->PollingInterval = dsareq->Service_Flow_Parameters.Tolerated_Jitter.Value;
+			bssf->LastPollingTime = Scheduler::instance().clock();
+			bssf->MaxTrafficRate = dsareq->Service_Flow_Parameters.Maximum_Sustained_Traffic_Rate.Value;
+			bssf->MinTrafficRate = dsareq->Service_Flow_Parameters.Minimum_Reserved_Traffic_Rate.Value;
+			bssf->ToleratedJitter = dsareq->Service_Flow_Parameters.Tolerated_Jitter.Value;
+			bssf->MaxLatency = dsareq->Service_Flow_Parameters.Maximum_Latency.Value;
+			bssf->ReqTxPolicy = dsareq->Service_Flow_Parameters.Request_Transmission_Policy.Value;
+			printf("\tbs  create ss%d UL ertPS SF sfid=%d\n",BsSearchSsInfo(-1, mac16->generic_hdr.CID)->MacAddr,bssf->SFID);
+		} else if (dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value == 0x04) { 	
+			bssf->SFID = (ServiceFlowID_Counter2++)*10 + 2;
+			bssf->PollingInterval = dsareq->Service_Flow_Parameters.Maximum_Latency.Value;
+			bssf->LastPollingTime = Scheduler::instance().clock();
+			bssf->MaxTrafficRate = dsareq->Service_Flow_Parameters.Maximum_Sustained_Traffic_Rate.Value;
+			bssf->MinTrafficRate = dsareq->Service_Flow_Parameters.Minimum_Reserved_Traffic_Rate.Value;
+			bssf->MaxLatency = dsareq->Service_Flow_Parameters.Maximum_Latency.Value;
+			bssf->ReqTxPolicy = dsareq->Service_Flow_Parameters.Request_Transmission_Policy.Value;
+			printf("\tbs  create ss%d UL rtPS SF sfid=%d\n",BsSearchSsInfo(-1, mac16->generic_hdr.CID)->MacAddr,bssf->SFID);
+		} else if (dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value == 0x03) { 	
+			bssf->SFID = (ServiceFlowID_Counter3++)*10 + 3;
+			bssf->PollingInterval = dsareq->Service_Flow_Parameters.Maximum_Latency.Value;
+			bssf->LastPollingTime = Scheduler::instance().clock();
+			bssf->MaxTrafficRate = dsareq->Service_Flow_Parameters.Maximum_Sustained_Traffic_Rate.Value;
+			bssf->MinTrafficRate = dsareq->Service_Flow_Parameters.Minimum_Reserved_Traffic_Rate.Value;
+			bssf->TrafficPriority = dsareq->Service_Flow_Parameters.Traffic_Priority.Value;
+			bssf->ReqTxPolicy = dsareq->Service_Flow_Parameters.Request_Transmission_Policy.Value;
+			printf("\tbs  create ss%d UL nrtPS SF sfid=%d\n",BsSearchSsInfo(-1, mac16->generic_hdr.CID)->MacAddr,bssf->SFID);
+		} else if (dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value == 0x02) {	
+			bssf->SFID = (ServiceFlowID_Counter4++)*10 + 4;
+			bssf->PollingInterval = 1000;
+			bssf->LastPollingTime = Scheduler::instance().clock();
+			bssf->MaxTrafficRate = dsareq->Service_Flow_Parameters.Maximum_Sustained_Traffic_Rate.Value;
+			bssf->TrafficPriority = dsareq->Service_Flow_Parameters.Traffic_Priority.Value;
+			bssf->ReqTxPolicy = dsareq->Service_Flow_Parameters.Request_Transmission_Policy.Value;
+			printf("\tbs  create ss%d UL BE SF sfid=%d\n",BsSearchSsInfo(-1, mac16->generic_hdr.CID)->MacAddr,bssf->SFID);
+		}	
+		bssf->ScheduleType = dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value;
+		bssf->Status = Active;	
+		bssf->Direction = UL;	
+	} else {	
+		bssf->MacAddr = mac->macDA();//hdr->next_hop();
+		bssf->SrcMacAddr = mac->macSA();
+		bssf->DstMacAddr = mac->macDA();
+		bssf->TransactionID = TransactionID_Counter++;
+		bssf->TransportCID = TransportCID_Counter++;
+		if (hdr->ptype() == PT_UGS) {// || dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value == 0x06) {
+			bssf->SFID = (ServiceFlowID_Counter5++)*10 + 5;
+			bssf->ScheduleType = 6;
+			bssf->MaxTrafficRate = 64000; //64Kbps
+			bssf->MinTrafficRate = 64000; //64Kbps
+			bssf->ToleratedJitter = 10;
+			bssf->MaxLatency = 50;
+			bssf->ReqTxPolicy = 0;
+			printf("\tbs  create ss%d DL UGS SF sfid=%d\n",mac->macDA(),bssf->SFID);	
+		} else if (hdr->ptype() == PT_ertPS) {// || dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value == 0x05) {
+			bssf->SFID = (ServiceFlowID_Counter6++)*10 + 6;
+			bssf->ScheduleType = 5;
+			bssf->MaxTrafficRate = 64000; //64Kbps
+			bssf->MinTrafficRate = 8000; //8Kbps
+			bssf->ToleratedJitter = 30;
+			bssf->MaxLatency = 50;
+			bssf->ReqTxPolicy = 0;
+			printf("\tbs  create ss%d DL ertPS SF sfid=%d\n",mac->macDA(),bssf->SFID);	
+		} else if (hdr->ptype() == PT_rtPS) {// || dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value == 0x04) {
+			bssf->SFID = (ServiceFlowID_Counter7++)*10 + 7;
+			bssf->ScheduleType = 4;
+			bssf->MaxTrafficRate = 1024000; //1Mbps
+			bssf->MinTrafficRate = 512000; //512Kbps
+			bssf->MaxLatency = 50;
+			bssf->ReqTxPolicy = 0;
+			printf("\tbs  create ss%d DL rtPS SF sfid=%d\n",mac->macDA(),bssf->SFID);	
+		} else if (hdr->ptype() == PT_nrtPS) {// || dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value == 0x03) {
+			bssf->SFID = (ServiceFlowID_Counter8++)*10 + 8;
+			bssf->ScheduleType = 3;
+			bssf->MaxTrafficRate = 1024000; //1Mbps
+			bssf->MinTrafficRate = 512000; //512Kbps
+			bssf->MaxLatency = 500;
+			bssf->TrafficPriority = 7;
+			bssf->ReqTxPolicy = 0;
+			printf("\tbs  create ss%d DL nrtPS SF sfid=%d\n",mac->macDA(),bssf->SFID);	
+		} else if (hdr->ptype() == PT_BE) {// || dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value == 0x02) {
+			bssf->SFID = (ServiceFlowID_Counter9++)*10 + 9;
+			bssf->ScheduleType = 2;
+			bssf->MaxTrafficRate = 1024000; //1Mbps
+			bssf->MaxLatency = 1000;
+			bssf->TrafficPriority = 7;
+			bssf->ReqTxPolicy = 0;
+			printf("\tbs  create ss%d DL BE SF sfid=%d\n",mac->macDA(),bssf->SFID);	
+		}
+		bssf->Status = Provisioned;
+		bssf->Direction = DL;	
+	}
+	printf("\tMacAddr %d SrcMacAddr %d DstMacAddr %d\n",bssf->MacAddr,bssf->SrcMacAddr,bssf->DstMacAddr);
+	
+	if (!BsSF_head) {
+		BsSF_head = BsSF_tail = bssf;
+		bssf->next = NULL;
+	} else {
+		BsSF_tail->next = bssf;
+		BsSF_tail = bssf;
+		bssf->next = NULL;
+	}
+	return bssf;
+}
+
+SsServiceFlow*
+Mac802_16::SsSearchServiceFlow(int DstMacAddr, packet_t ptype, SfDirection Direction, int TransactionID, int CID)
+{	
+	int ScheduleType;
+	SsServiceFlow *sssf = NULL;
+	sssf = SsSF_head;
+	
+	switch (ptype) {
+		case PT_UGS: ScheduleType = 0x06; break;
+		case PT_ertPS: ScheduleType = 0x05; break;
+		case PT_rtPS: ScheduleType = 0x04; break;
+		case PT_nrtPS: ScheduleType = 0x03; break;
+		case PT_BE: ScheduleType = 0x02; break;
+		default: break;
+	}
+	
+	if (TransactionID != -1) {
+		while (sssf) {
+			if (sssf->TransactionID == TransactionID)
+				return sssf;
+			else
+				sssf = sssf->next;
+		}
+	} else if (TransactionID == -1 && CID != -1) {
+		while (sssf) {
+			if (sssf->TransportCID == CID)
+				return sssf;
+			else
+				sssf = sssf->next;
+		}
+	} else {
+		while (sssf) {
+			if (sssf->DstMacAddr == DstMacAddr && sssf->ScheduleType == ScheduleType && sssf->Direction == Direction)
+				return sssf;
+			else
+				sssf = sssf->next;
+		}
+	}
+	return NULL;
+}
+
+SsServiceFlow*
+Mac802_16::SsCreateServiceFlow(Packet* p, SfDirection Direction)
+{	
+	struct hdr_cmn *hdr = HDR_CMN(p);
+	struct hdr_mac *mac = HDR_MAC(p); 
+	//struct hdr_mac802_16 *mac16 = HDR_MAC802_16(p);	
+	DsaReqMsg *dsareq = (DsaReqMsg*) p->accessdata();
+	SsServiceFlow *sssf = new SsServiceFlow;
+	
+	if (Direction == UL) {
+		sssf->MacAddr = NodeID;
+		sssf->DstMacAddr = mac->macDA();
+		sssf->SrcMacAddr = mac->macSA();
+		sssf->TransactionID = TransactionID_Counter++; //0x0000 ~ 0x7FFFF
+		sssf->TransportCID = -1;
+		sssf->SFID = -1;
+		if (hdr->ptype() == PT_UGS) {
+			printf("\tss%d create UL UGS SF\n",NodeID);	
+			sssf->ScheduleType = 6;
+			sssf->MaxTrafficRate = 64000; //64Kbps
+			sssf->MinTrafficRate = 64000; //64Kbps
+			sssf->ToleratedJitter = 10;
+			sssf->MaxLatency = 50;
+			sssf->ReqTxPolicy = 0;
+		} else if (hdr->ptype() == PT_ertPS) { 	
+			printf("\tss%d create UL ertPS SF\n",NodeID);	
+			sssf->ScheduleType = 5;
+			sssf->MaxTrafficRate = 64000; //64Kbps
+			sssf->MinTrafficRate = 8000; //8Kbps
+			sssf->ToleratedJitter = 30;
+			sssf->MaxLatency = 50;
+			sssf->ReqTxPolicy = 0;
+		} else if (hdr->ptype() == PT_rtPS) { 	
+			printf("\tss%d create UL rtPS SF\n",NodeID);	
+			sssf->ScheduleType = 4;
+			sssf->MaxTrafficRate = 1024000; //1Mbps
+			sssf->MinTrafficRate = 512000; //512Kbps
+			sssf->MaxLatency = 50;
+			sssf->ReqTxPolicy = 0;
+		} else if (hdr->ptype() == PT_nrtPS) { 	
+			printf("\tss%d create UL nrtPS SF\n",NodeID);	
+			sssf->ScheduleType = 3;
+			sssf->MaxTrafficRate = 1024000; //1Mbps
+			sssf->MinTrafficRate = 512000; //512Kbps
+			sssf->MaxLatency = 500;
+			sssf->TrafficPriority = 7;
+			sssf->ReqTxPolicy = 0;
+		} else if (hdr->ptype() == PT_BE) {	
+			printf("\tss%d create UL BE SF\n",NodeID);	
+			sssf->ScheduleType = 2;
+			sssf->MaxTrafficRate = 1024000; //1Mbps
+			sssf->TrafficPriority = 7;
+			sssf->ReqTxPolicy = 0;
+		}
+		sssf->Status = Provisioned;
+		sssf->Direction = UL;
+	} else {
+		sssf->MacAddr = BsID;
+		sssf->DstMacAddr = dsareq->Service_Flow_Parameters.Destination_MAC_Address.Value;
+		sssf->SrcMacAddr = dsareq->Service_Flow_Parameters.Source_MAC_Address.Value;
+		sssf->TransactionID = dsareq->Transaction_ID;
+		sssf->TransportCID =  dsareq->Service_Flow_Parameters.CID.Value;
+		sssf->SFID = dsareq->Service_Flow_Parameters.SFID.Value;
+		sssf->ScheduleType = dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value;
+		if (dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value == 0x06) {	
+			sssf->MaxTrafficRate = dsareq->Service_Flow_Parameters.Maximum_Sustained_Traffic_Rate.Value;
+			sssf->MinTrafficRate = dsareq->Service_Flow_Parameters.Minimum_Reserved_Traffic_Rate.Value;
+			sssf->ToleratedJitter = dsareq->Service_Flow_Parameters.Tolerated_Jitter.Value;
+			sssf->MaxLatency = dsareq->Service_Flow_Parameters.Maximum_Latency.Value;
+			sssf->ReqTxPolicy = dsareq->Service_Flow_Parameters.Request_Transmission_Policy.Value;
+			printf("\tss%d  create DL UGS SF\n",NodeID);	
+		} else if (dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value == 0x05) { 	
+			sssf->MaxTrafficRate = dsareq->Service_Flow_Parameters.Maximum_Sustained_Traffic_Rate.Value;
+			sssf->MinTrafficRate = dsareq->Service_Flow_Parameters.Minimum_Reserved_Traffic_Rate.Value;
+			sssf->ToleratedJitter = dsareq->Service_Flow_Parameters.Tolerated_Jitter.Value;
+			sssf->MaxLatency = dsareq->Service_Flow_Parameters.Maximum_Latency.Value;
+			sssf->ReqTxPolicy = dsareq->Service_Flow_Parameters.Request_Transmission_Policy.Value;
+			printf("\tss%d  create DL ertPS SF\n",NodeID);
+		} else if (dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value == 0x04) { 	
+			sssf->MaxTrafficRate = dsareq->Service_Flow_Parameters.Maximum_Sustained_Traffic_Rate.Value;
+			sssf->MinTrafficRate = dsareq->Service_Flow_Parameters.Minimum_Reserved_Traffic_Rate.Value;
+			sssf->MaxLatency = dsareq->Service_Flow_Parameters.Maximum_Latency.Value;
+			sssf->ReqTxPolicy = dsareq->Service_Flow_Parameters.Request_Transmission_Policy.Value;
+			printf("\tss%d  create DL rtPS SF\n",NodeID);
+		} else if (dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value == 0x03) { 	
+			sssf->MaxTrafficRate = dsareq->Service_Flow_Parameters.Maximum_Sustained_Traffic_Rate.Value;
+			sssf->MinTrafficRate = dsareq->Service_Flow_Parameters.Minimum_Reserved_Traffic_Rate.Value;
+			sssf->TrafficPriority = dsareq->Service_Flow_Parameters.Traffic_Priority.Value;
+			sssf->ReqTxPolicy = dsareq->Service_Flow_Parameters.Request_Transmission_Policy.Value;
+			printf("\tss%d  create DL nrtPS SF\n",NodeID);
+		} else if (dsareq->Service_Flow_Parameters.Service_Flow_Scheduling_Type.Value == 0x02) {	
+			sssf->MaxTrafficRate = dsareq->Service_Flow_Parameters.Maximum_Sustained_Traffic_Rate.Value;
+			sssf->TrafficPriority = dsareq->Service_Flow_Parameters.Traffic_Priority.Value;
+			sssf->ReqTxPolicy = dsareq->Service_Flow_Parameters.Request_Transmission_Policy.Value;
+			printf("\tss%d  create DL BE SF\n",NodeID);
+		}
+		sssf->Status = Active;			
+		sssf->Direction = DL;	
+	}
+	
+	if (!SsSF_head) {
+		SsSF_head = SsSF_tail = sssf;
+		sssf->next = NULL;
+	} else {
+		SsSF_tail->next = sssf;
+		SsSF_tail = sssf;
+		sssf->next = NULL;
+	}
+	return sssf;
+}
+
+DlMapIe*
+Mac802_16::CreateDlMapIe()
+{
+	DlMapIe *tmp = new DlMapIe;
+	if (!DlMapIe_head) {
+		DlMapIe_head = DlMapIe_tail = tmp;
+		tmp->next = NULL;
+	} else {
+		DlMapIe_tail->next = tmp;
+		DlMapIe_tail = tmp;
+		tmp->next = NULL;
+	}
+	return tmp;
+}
+
+UlMapIe*
+Mac802_16::CreateUlMapIe()
+{
+	UlMapIe *tmp = new UlMapIe;
+	if (!UlMapIe_head) {
+		UlMapIe_head = UlMapIe_tail = tmp;
+		tmp->next = NULL;
+	} else {
+		UlMapIe_tail->next = tmp;
+		UlMapIe_tail = tmp;
+		tmp->next = NULL;
+	}
+	return tmp;
+}
+
+void
+Mac802_16::FrameTimerHandler()
+{
+	if (NodeID == BsID) {
+		preambleTimer.start(SymbolLength);	
+		
+		UlMapIe *UlMapIe_tmp, *UlMapIe_backup;
+		DlMapIe *DlMapIe_tmp, *DlMapIe_backup;
+		
+		UlMapIe_tmp = UlMapIe_head;
+		while (UlMapIe_tmp) {
+			UlMapIe_backup = UlMapIe_tmp->next;
+			delete UlMapIe_tmp;
+			UlMapIe_tmp = UlMapIe_backup;
+		}
+		UlMapIe_head = NULL;
+		UlMapIe_tail = NULL;
+		
+		DlMapIe_tmp = DlMapIe_head;
+		while (DlMapIe_tmp) {
+			DlMapIe_backup = DlMapIe_tmp->next;
+			delete DlMapIe_tmp;
+			DlMapIe_tmp = DlMapIe_backup;
+		}
+		DlMapIe_head = NULL;
+		DlMapIe_tail = NULL;
+		
+		if (FrameNumber_Counter%100 == 0) {
+			UplinkBurstProfile *UlBurstProfile_tmp, *UlBurstProfile_backup;
+			DownlinkBurstProfile *DlBurstProfile_tmp, *DlBurstProfile_backup;
+		
+			UlBurstProfile_tmp = UlBurstProfile_head;
+			while (UlBurstProfile_tmp) {
+				UlBurstProfile_backup = UlBurstProfile_tmp->next;
+				delete UlBurstProfile_tmp;
+				UlBurstProfile_tmp = UlBurstProfile_backup;
+			}
+			UlBurstProfile_head = NULL;
+			UlBurstProfile_tail = NULL;
+		
+			DlBurstProfile_tmp = DlBurstProfile_head;
+			while (DlBurstProfile_tmp) {
+				DlBurstProfile_backup = DlBurstProfile_tmp->next;
+				delete DlBurstProfile_tmp;
+				DlBurstProfile_tmp = DlBurstProfile_backup;
+			}
+			DlBurstProfile_head = NULL;
+			DlBurstProfile_tail = NULL;
+		}
+	}
+}
+
+void
+Mac802_16::PreambleTimerHandler()
+{
+	if (NodeID == BsID) {	
+		frameTimer.start(DlSymbolNum*SymbolLength + TtgLength + UlSymbolNum*SymbolLength + RtgLength);
+		BandwidthManagement();
+		FrameNumber_Counter++;
+	}
+}
+
+void
+Mac802_16::DownlinkTimerHandler(Packet *pkt)
+{	
+	//printf("downlink time %f\n",Scheduler::instance().clock());
+	downtarget_->recv(pkt, this);
+}
+
+void
+Mac802_16::UplinkTimerHandler(Packet *pkt)
+{
+	//printf("uplink time %f\n",Scheduler::instance().clock());
+	downtarget_->recv(pkt, this);
+}
+
+int 
+Mac802_16::command(int argc, const char*const* argv)
+{
+	if (argc == 3) 
+	{
+		if (strcmp(argv[1], "log-target") == 0) 
+		{ 
+			logtarget_ = (NsObject*) TclObject::lookup(argv[2]);
+			if(logtarget_ == 0)
+				return TCL_ERROR;
+		}
+	} 
+	return Mac::command(argc, argv);
+}
+
+static class Mac802_16Class : public TclClass
+{
+public:
+	Mac802_16Class() : TclClass("Mac/802_16") {}
+	TclObject* create(int, const char*const*) 
+	{
+		return (new Mac802_16());
+	}
+} class_mac802_16;
diff -u -r -N ns-2.34.original/mac/mac-802_16/mac-802_16.h ns-2.34/mac/mac-802_16/mac-802_16.h
--- ns-2.34.original/mac/mac-802_16/mac-802_16.h	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/mac/mac-802_16/mac-802_16.h	2007-12-14 09:27:16.000000000 +0800
@@ -0,0 +1,186 @@
+/**************************************************************************************
+* *Copyright (c) 2006 Regents of the University of Chang Gung 						*
+* *All rights reserved.													*
+ *																*
+ * Redistribution and use in source and binary forms, with or without						*
+ * modification, are permitted provided that the following conditions					*
+ * are met: 															*
+ * 1. Redistributions of source code must retain the above copyright						*
+ *    notice, this list of conditions and the following disclaimer.						*
+ * 2. Redistributions in binary form must reproduce the above copyright					*
+ *    notice, this list of conditions and the following disclaimer in the						*
+ *    documentation and/or other materials provided with the distribution.					*
+ * 3. All advertising materials mentioning features or use of this software					*
+ *    must display the following acknowledgement:									*
+ *	This product includes software developed by the Computer Systems					*
+ *	Engineering Group at Lawrence Berkeley Laboratory.							*
+ * 4. Neither the name of the University nor of the Laboratory may be used					*
+ *    to endorse or promote products derived from this software without					*
+ *    specific prior written permission.										*
+ *5. If you have any problem about these codes, 									*
+       please mail to antibanish@gmail.com or b9229008@stmail.cgu.edu.tw                    			*
+**************************************************************************************/
+#ifndef ns_mac_80216_h
+#define ns_mac_80216_h
+
+#include "address.h"
+#include "ip.h"
+#include "packet-802_16.h"
+#include "timer-802_16.h"
+#include "marshall.h"
+
+#include "agent.h"
+#include "tclcl.h"
+#include "packet.h"
+#include "cmu-trace.h"
+#include "basetrace.h"
+#include "connector.h" 
+
+enum ModulCodingType { QPSK_12 = 0, QPSK_34 = 1, QAM16_12 = 2, QAM16_34 = 3, QAM64_23 = 4, QAM64_34 = 5};
+enum SfDirection { UL = 0, DL = 1};
+enum SfStatus {Provisioned = 0, Admitted = 1, Active = 2};
+//enum MacStatus {MSEND = 0, MIDLE = 1};
+
+struct BsSsInfo {
+	BsSsInfo(){next = NULL; BasicCID = -1; PrimaryCID = -1;}
+	int MacAddr;
+	int BasicCID;
+	int PrimaryCID;
+	int UplinkBandwidth;
+	int DownlinkBandwidth;
+	bool PollingStatus;
+	ModulCodingType ModulCoding;
+	BsSsInfo *next;
+};
+
+struct BsServiceFlow {
+	BsServiceFlow(){next = NULL; TransportCID = -1;}
+	int MacAddr;
+	int TransactionID;
+	int TransportCID;
+	int DstMacAddr;
+	int SrcMacAddr;
+	int PollingInterval; //ms
+	double LastPollingTime;
+	int BwReqSize;
+	int SFID; //Service Flow ID
+	int ScheduleType; //Service_Flow_Scheduling_Type
+	int MaxTrafficRate; //Maximum_Sustained_Traffic_Rate
+	int MinTrafficRate; //Minimum_Reserved_Traffic_Rate
+	int ToleratedJitter; //Tolerated_Jitter
+	int MaxLatency; //Maximum_Latency
+	int TrafficPriority; //Traffic_Priority
+	int ReqTxPolicy; //Request_Transmission_Policy
+	SfStatus Status; //QoS_Parameter_Set_Type
+	double QueueTime;
+	PacketQueue SduQueue;
+	PacketQueue PduQueue;
+	PacketQueue FragQueue;
+	SfDirection Direction;	
+	BsServiceFlow *next;
+};
+
+struct SsServiceFlow {
+	SsServiceFlow(){next = NULL; TransportCID = -1;}
+	int MacAddr;
+	int DstMacAddr;
+	int SrcMacAddr;
+	int TransactionID;
+	int TransportCID;
+	int BwReqSize;
+	int SFID; //Service Flow ID
+	int ScheduleType; //Service_Flow_Scheduling_Type
+	int MaxTrafficRate; //Maximum_Sustained_Traffic_Rate
+	int MinTrafficRate; //Minimum_Reserved_Traffic_Rate	
+	int ToleratedJitter; //Tolerated_Jitter
+	int MaxLatency; //Maximum_Latency
+	int TrafficPriority; //Traffic_Priority
+	int ReqTxPolicy; //Request_Transmission_Policy
+	SfStatus Status; //QoS_Parameter_Set_Type
+	double QueueTime;
+	PacketQueue SduQueue;
+	PacketQueue PduQueue;
+	PacketQueue FragQueue;
+	SfDirection Direction;
+	SsServiceFlow *next;
+};
+
+class Mac802_16 : public Mac
+{		
+	friend class FrameTimer;
+	friend class PreambleTimer;
+	friend class DownlinkTimer;
+	friend class UplinkTimer;
+	friend class UlMapTimer;
+	friend class DlMapTimer;
+	
+	public:
+		Mac802_16();
+		void	sendUCD();	
+		void	sendDCD();
+		void	sendDLMAP();
+		void	sendULMAP();
+		void	sendRNGREQ(UlMapIe *IE);
+		void	sendBWREQ(UlMapIe *IE);	
+		void	sendRNGRSP(BsSsInfo *SsInfo);
+		void	sendDSAREQ(SsServiceFlow *SsSF, BsServiceFlow *BsSF);
+		void	sendDSARSP(SsServiceFlow *SsSF, BsServiceFlow *BsSF);
+		void	sendDSAACK(Packet *pkt);
+		void	sendDSXRVD(Packet *pkt);	
+		bool	CallAdmissionControl(Packet *p);
+		void	BandwidthManagement();
+		void	BsScheduler();
+		void	SsScheduler();
+		void    BsFragOrPack(BsServiceFlow *BsSF, int Size);
+		void 	SsFragOrPack(SsServiceFlow *SsSF, int Size);			
+		void	BsBurstTransmit();
+		void	SsBurstTransmit();
+		BsSsInfo* BsSearchSsInfo(int MacAddr, int CID);
+		BsSsInfo* BsCreateSsInfo(Packet *p);
+		BsServiceFlow*	BsSearchServiceFlow(int SrcMacAddr, int DstMacAddr, packet_t ptype, SfDirection Direction, int TransactionID, int CID);
+		BsServiceFlow*	BsCreateServiceFlow(Packet *p, SfDirection Direction);
+		SsServiceFlow*	SsSearchServiceFlow(int DstMacAddr, packet_t ptype, SfDirection Direction, int TransactionID, int CID);
+		SsServiceFlow*	SsCreateServiceFlow(Packet *p, SfDirection Direction);
+		UlMapIe* CreateUlMapIe();
+		DlMapIe* CreateDlMapIe();
+		
+	protected:
+		int	NodeID;
+		int	BasicCID;
+		int	PrimaryCID;
+		int	TransactionID_Counter;
+		bool RangingStatus;
+		ModulCodingType ModulCoding;
+		int UcdConfigChangeCount;
+		int DcdConfigChangeCount;
+		UplinkBurstProfile UplinkBurstProfileTable;
+		DownlinkBurstProfile DownlinkBurstProfileTable;
+		PacketQueue	UgsQueue;
+		PacketQueue	ertPsQueue;
+		PacketQueue	rtPsQueue;
+		PacketQueue	nrtPsQueue;
+		PacketQueue	BeQueue;
+		SsServiceFlow *SsSF_head;
+		SsServiceFlow *SsSF_tail;
+		FrameTimer	frameTimer;
+		PreambleTimer preambleTimer;
+		DownlinkTimer downlinkTimer;
+		UplinkTimer uplinkTimer;
+		UlMapTimer ulmapTimer;
+		DlMapTimer dlmapTimer;
+		void FrameTimerHandler();
+		void PreambleTimerHandler();
+		void DownlinkTimerHandler(Packet *pkt);
+		void UplinkTimerHandler(Packet *pkt);
+	private:
+		MacState	rx_state_;	// incoming state (MAC_RECV or MAC_IDLE)
+		MacState	tx_state_;	// outgoint state
+		int			command(int argc, const char*const* argv);
+		void 		recv(Packet *, Handler *);	
+		NsObject*	logtarget_;
+		inline void	mac_log(Packet *p) 
+		{
+            logtarget_->recv(p, (Handler*) 0);
+        }		
+};
+#endif 
diff -u -r -N ns-2.34.original/mac/mac-802_16/packet-802_16.cc ns-2.34/mac/mac-802_16/packet-802_16.cc
--- ns-2.34.original/mac/mac-802_16/packet-802_16.cc	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/mac/mac-802_16/packet-802_16.cc	2007-12-14 09:27:16.000000000 +0800
@@ -0,0 +1,47 @@
+/**************************************************************************************
+* *Copyright (c) 2006 Regents of the University of Chang Gung 						*
+* *All rights reserved.													*
+ *																*
+ * Redistribution and use in source and binary forms, with or without						*
+ * modification, are permitted provided that the following conditions					*
+ * are met: 															*
+ * 1. Redistributions of source code must retain the above copyright						*
+ *    notice, this list of conditions and the following disclaimer.						*
+ * 2. Redistributions in binary form must reproduce the above copyright					*
+ *    notice, this list of conditions and the following disclaimer in the						*
+ *    documentation and/or other materials provided with the distribution.					*
+ * 3. All advertising materials mentioning features or use of this software					*
+ *    must display the following acknowledgement:									*
+ *	This product includes software developed by the Computer Systems					*
+ *	Engineering Group at Lawrence Berkeley Laboratory.							*
+ * 4. Neither the name of the University nor of the Laboratory may be used					*
+ *    to endorse or promote products derived from this software without					*
+ *    specific prior written permission.										*
+ *5. If you have any problem about these codes, 									*
+       please mail to antibanish@gmail.com or b9229008@stmail.cgu.edu.tw                    			*
+**************************************************************************************/
+#include "packet-802_16.h"
+
+int hdr_mac802_16::offset_;
+static class Mac802_16HeaderClass :public PacketHeaderClass {
+	public:
+		Mac802_16HeaderClass() : PacketHeaderClass("PacketHeader/802_16", sizeof(hdr_mac802_16)) {
+			bind_offset(&hdr_mac802_16::offset_);
+		}
+} class_hdr_mac802_16;
+
+int subhdr_pack::offset_;
+static class PackSubHeaderClass :public PacketHeaderClass {
+	public:
+		PackSubHeaderClass() : PacketHeaderClass("PacketHeader/pack", sizeof(subhdr_pack)) {
+			bind_offset(&subhdr_pack::offset_);
+		}
+} class_subhdr_pack;
+
+int subhdr_frag::offset_;
+static class FragSubHeaderClass :public PacketHeaderClass {
+	public:
+		FragSubHeaderClass() : PacketHeaderClass("PacketHeader/frag", sizeof(subhdr_frag)) {
+			bind_offset(&subhdr_frag::offset_);
+		}
+} class_subhdr_frag;
diff -u -r -N ns-2.34.original/mac/mac-802_16/packet-802_16.h ns-2.34/mac/mac-802_16/packet-802_16.h
--- ns-2.34.original/mac/mac-802_16/packet-802_16.h	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/mac/mac-802_16/packet-802_16.h	2007-12-14 09:27:16.000000000 +0800
@@ -0,0 +1,359 @@
+/**************************************************************************************
+* *Copyright (c) 2006 Regents of the University of Chang Gung 						*
+* *All rights reserved.													*
+ *																*
+ * Redistribution and use in source and binary forms, with or without						*
+ * modification, are permitted provided that the following conditions					*
+ * are met:															*
+ * 1. Redistributions of source code must retain the above copyright						*
+ *    notice, this list of conditions and the following disclaimer.						*
+ * 2. Redistributions in binary form must reproduce the above copyright					*
+ *    notice, this list of conditions and the following disclaimer in the						*
+ *    documentation and/or other materials provided with the distribution.					*
+ * 3. All advertising materials mentioning features or use of this software					*
+ *    must display the following acknowledgement:									*
+ *	This product includes software developed by the Computer Systems					*
+ *	Engineering Group at Lawrence Berkeley Laboratory.							*
+ * 4. Neither the name of the University nor of the Laboratory may be used					*
+ *    to endorse or promote products derived from this software without					*
+ *    specific prior written permission.										*
+ *5. If you have any problem about these codes, 									*
+       please mail to antibanish@gmail.com or b9229008@stmail.cgu.edu.tw                    			*
+**************************************************************************************/
+#ifndef ns_packet_80216_h
+#define ns_packet_80216_h
+#include "packet.h"
+
+struct GenericHdr {
+	//table 5
+    u_char    HT 		:1; 
+	u_char    EC 		:1;
+	u_char    Type 		:6; //table 6 
+	u_char    Reserved1 :1;
+	u_char    CI 		:1;
+	u_char    EKS 		:2;
+	u_char    Reserved2 :1;
+	u_int16_t LEN 		:11; //bype
+	u_int16_t CID 		:16;
+	u_int8_t  HCS 		:8;
+};
+
+struct BwReqHdr {
+	//table 7
+	u_char    HT 		:1; 
+	u_char    EC 		:1;
+	u_char    Type 		:6;
+	u_int32_t BR 		:19;
+	u_int16_t CID 		:16;
+	u_int8_t  HCS 		:8;
+};
+
+struct subhdr_pack {
+	//table 11
+	u_char    FC		:2;
+	u_char    FSN		:3;
+	u_int16_t Length	:11;	
+	static int offset_;
+	inline static int& offset() {return offset_;}
+	inline static subhdr_pack* access(const Packet* p) {
+		return (subhdr_pack*) p->access(offset_);
+	}
+};
+
+struct subhdr_frag {
+	//table 8
+    u_char    FC		:2;
+	u_char    FSN		:3;
+	u_int16_t Length	:11;
+	static int offset_;
+	inline static int& offset() {return offset_;}
+	inline static subhdr_frag* access(const Packet* p) {
+		return (subhdr_frag*) p->access(offset_);
+	}
+};
+
+struct hdr_mac802_16 {
+	GenericHdr generic_hdr;
+	BwReqHdr   bwreq_hdr;
+	//PackSubhdr pack_subhdr;
+	//FragSubhdr frag_subhdr;
+    
+	static int offset_;
+	inline static int& offset() {return offset_;}
+	inline static hdr_mac802_16* access(const Packet* p) {
+		return (hdr_mac802_16*) p->access(offset_);
+	}
+};
+
+struct TLV_LEN8 {
+	TLV_LEN8(){Length = 0x18;}
+	u_int8_t  Type									:8;
+	u_int8_t  Length								:8;
+	u_int8_t  Value									:8;
+};
+
+struct TLV_LEN9 {
+	TLV_LEN9(){Length = 0x19;}
+	u_int8_t  Type									:8;
+	u_int8_t  Length								:8;
+	u_int16_t Value									:9;
+};
+
+struct TLV_LEN13 {
+	TLV_LEN13(){Length = 0x1D;}
+	u_int8_t  Type									:8;
+	u_int8_t  Length								:8;
+	u_int16_t Value									:13;
+};
+
+struct TLV_LEN16 {
+	TLV_LEN16(){Length = 0x20;}
+	u_int8_t  Type									:8;
+	u_int8_t  Length								:8;
+	u_int16_t Value									:16;
+};
+	
+struct TLV_LEN24 {
+	TLV_LEN24(){Length = 0x28;}
+	u_int8_t  Type									:8;
+	u_int8_t  Length								:8;
+	u_int32_t Value									:24;
+};
+
+struct TLV_LEN32 {
+	TLV_LEN32(){Length = 0x30;}
+	u_int8_t  Type									:8;
+	u_int8_t  Length								:8;
+	u_int32_t Value									:32;
+};
+
+struct TLV_LEN40 {
+	TLV_LEN40(){Length = 0x38;}
+	u_int8_t  Type									:8;
+	u_int8_t  Length								:8;
+	u_int64_t Value									:40;
+};
+
+struct TLV_LEN48 {
+	TLV_LEN48(){Length = 0x40;}
+	u_int8_t  Type									:8;
+	u_int8_t  Length								:8;
+	u_int64_t Value									:48;
+};
+
+struct UplinkBurstProfile {
+	UplinkBurstProfile() {next = NULL;}
+	//table 304
+	u_int8_t  Type 									:8;
+	u_int8_t  Length 								:8;
+	u_char    Reserved 								:4;
+	u_char    UIUC 									:4;
+	//table 357
+	TLV_LEN8  FEC_Code_and_modulation_type;
+	TLV_LEN8  Ranging_data_ratio;
+	TLV_LEN40 Normalized_CN_override; //table 334
+	UplinkBurstProfile *next;
+};
+
+struct UcdMsg {
+	//table 17
+	u_int8_t  Management_Message_Type				:8;
+	u_int8_t  Config_Change_Count					:8;
+	u_int8_t  Rng_Backoff_Start						:8;
+	u_int8_t  Rng_Backoff_End 						:8;
+	u_int8_t  Req_Backoff_Start						:8;
+	u_int8_t  Req_Backoff_End						:8;
+	//table 349
+	TLV_LEN8  Contention_based_reservation_timeout;
+	TLV_LEN16 Bandwidth_request_opportunity_size;
+	TLV_LEN16 Ranging_request_opportunity_size;
+	TLV_LEN32 Frequency;
+	//table 353
+	TLV_LEN8  Initial_ranging_codes;
+	TLV_LEN8  Periodic_ranging_codes;
+	TLV_LEN8  Bandwidth_request_codes;
+	TLV_LEN8  Periodic_ranging_backoff_start;
+	TLV_LEN8  Periodic_ranging_backoff_end;
+	TLV_LEN8  Start_of_ranging_codes_group;
+	TLV_LEN8  Permutation_base;
+	TLV_LEN9  UL_allocated_subchannels_bitmap;
+	TLV_LEN13 Optional_permutation_UL_Allocated_subchannels_bitmap;
+	TLV_LEN8  Band_AMC_Allocation_Threshold;
+	TLV_LEN8  Band_AMC_Release_Threshold;
+	TLV_LEN8  Band_AMC_Allocation_Timer;
+	TLV_LEN8  Band_AMC_Release_Timer;
+	TLV_LEN8  Band_Status_Reporting_MAX_Period;
+	TLV_LEN8  Band_AMC_Retry_Timer;
+	TLV_LEN8  Safety_Channel_Allocation_Threshold;
+	TLV_LEN8  Safety_Channel_Release_Threshold;
+	TLV_LEN8  Safety_Channel_Allocation_Timer;
+	TLV_LEN8  Safety_Channel_Release_Timer;
+	TLV_LEN8  Bin_Status_Reporting_MAX_Period;
+	TLV_LEN8  Safety_Channel_Retry_Timer;
+	TLV_LEN8  HARQ_ACK_delay_for_UL_burst;
+	TLV_LEN8  CQICH_Band_AMCTransition_Delay;
+};
+
+struct DownlinkBurstProfile {
+	DownlinkBurstProfile() {next = NULL;}
+	//table 303
+	u_int8_t  Type 									:8;
+	u_int8_t  Length 								:8;
+	u_char    Reserved 								:4;
+	u_char    DIUC 									:4;
+	//table 363
+	TLV_LEN8  FEC_Code_type;
+	TLV_LEN8  DIUC_Mandatory_exit_threshold; //figure 81
+	TLV_LEN8  DIUC_Minimum_entry_threshold; //figure 81
+	DownlinkBurstProfile *next;
+};
+
+struct DcdMsg {
+	//table 15
+	u_int8_t  Management_Message_Type				:8;
+	u_int8_t  Reserved								:8;
+	u_int8_t  Config_Change_Count					:8;
+	//table 358
+	TLV_LEN16 BS_EIRP;
+	TLV_LEN8  Channel_Nr; //8.5.
+	TLV_LEN8  TTG;
+	TLV_LEN8  RTG;
+	TLV_LEN16 RSS;
+	TLV_LEN24 Channel_Switch_Frame_Number;
+	TLV_LEN32 Frequency;
+	TLV_LEN48 BS_ID;
+	TLV_LEN8  Size_of_CQICH_ID_field;
+	TLV_LEN8  HARQ_ACK_delay_for_DL_burst;
+	TLV_LEN8  MAC_version; //11.1.3
+};
+
+struct DlMapIe {
+	DlMapIe(){next = NULL;}
+	//table 275
+	u_char    DIUC 									:4;
+	u_int8_t  N_CID	 								:8; //table 276
+	u_int16_t CID 									:16;
+	u_int8_t  OFDMA_Symbol_offset					:8;
+	u_char    Subchannel_offset						:6;
+	u_char    Boosting								:3;
+	u_char    No_OFDMA_Symbols 						:7;
+	u_char    No_Subchannels	 					:6;
+	u_char    Repetition_Coding_Indication 			:2;
+	DlMapIe *next;
+};
+
+struct DlMapMsg {
+	//table 16
+	u_int8_t  Management_Message_Type				:8;
+	u_int8_t  DCD_Count								:8;
+	u_int64_t BS_ID									:48;
+	u_int8_t  No_OFDMA_Symbols	                    :8;
+	//table 273
+	u_int8_t  Frame_duration_code					:8;
+	u_int32_t Frame_number							:24;
+};
+
+struct UlMapIe {
+	UlMapIe(){next = NULL;}
+	//table 287
+	u_int16_t CID 									:16;
+	u_char    UIUC	 								:4; //table 288
+	u_int8_t  OFDMA_Symbol_offset					:8 ;
+	u_char    Subchannel_offset						:7;
+	u_char    No_OFDMA_Symbols 						:7;
+	u_char    No_Subchannels	 					:7;
+	u_char    Ranging_Method 						:2 ;
+	u_int64_t Duration	 							:10; //see 8.4.3.1
+	u_char    Repetition_Coding_Indication 			:2;
+	UlMapIe *next;
+};
+
+struct UlMapMsg {
+	//table 18
+	u_int8_t  Management_Message_Type				:8;
+	u_int8_t  Reserved								:8;
+	u_int8_t  UCD_Count								:8;
+	u_int32_t Allocation_Start_Time					:32;
+	u_int8_t  No_OFDMA_Symbols	                    :8;
+};
+
+struct RngReqMsg {
+	//table 19
+	u_int8_t  Management_Message_Type				:8;
+	u_int8_t  Reserved								:8;
+	//table 364
+	u_int8_t  Requested_Downlink_Burst_Profile 		:8;
+	u_int64_t SS_MAC_Address 						:48;
+	u_int8_t  Ranging_Anomalies 					:8;
+	u_int8_t  AAS_broadcast_capability 				:8;
+};
+
+struct RngRspMsg {
+	//table 20
+	u_int8_t  Management_Message_Type				:8;
+	u_int8_t  Reserved								:8;
+	//table 367
+	u_int32_t Timing_Adjust 						:32;
+	u_int8_t  Power_Level_Adjust 					:8;
+	u_int32_t Offset_Frequency_Adjust 				:32;
+	u_int8_t  Ranging_Status 						:8;
+	u_int32_t Downlink_frequency_override 			:32;
+	u_int8_t  Uplink_channel_ID_override 			:8;
+	u_int16_t Downlink_Operational_Burst_Profile	:16;
+	u_int64_t SS_MAC_Address 						:48;
+	u_int16_t Basic_CID 							:16;
+	u_int16_t Primary_Management_CID 				:16;
+	u_int8_t  AAS_broadcast_permission 				:8;
+};
+
+struct Service_Flow {
+	//table 383
+	TLV_LEN32 SFID; 
+	TLV_LEN16 CID;
+	TLV_LEN8  QoS_Parameter_Set_Type; //table 385
+	TLV_LEN8  Traffic_Priority; //0 (low) ~ 7 (high)
+	TLV_LEN32 Maximum_Sustained_Traffic_Rate; //bit per second
+	TLV_LEN32 Maximum_Traffic_Burst; //byte
+	TLV_LEN32 Minimum_Reserved_Traffic_Rate; //bit per second
+	TLV_LEN8  Service_Flow_Scheduling_Type; //11.13.11
+	TLV_LEN32 Request_Transmission_Policy; //11.13.12
+	TLV_LEN32 Tolerated_Jitter; //ms
+	TLV_LEN32 Maximum_Latency; //ms
+	TLV_LEN8  SDU_Indicator; //byte
+	TLV_LEN8  SDU_Size; //byte
+	TLV_LEN16 Target_SAID;
+	TLV_LEN48 Destination_MAC_Address;
+	TLV_LEN48 Source_MAC_Address;
+};
+
+struct DsaReqMsg {
+	//table 38
+	u_int8_t  Management_Message_Type				:8;
+	u_int16_t Transaction_ID						:16;
+	//table 383
+	Service_Flow Service_Flow_Parameters;
+};
+
+struct DsaRspMsg {
+	//table 39
+	u_int8_t  Management_Message_Type				:8;
+	u_int16_t Transaction_ID						:16;
+	u_int8_t  Confirmation_Code						:8; //table 384
+	//table 383
+	Service_Flow Service_Flow_Parameters;
+};
+
+struct DsaAckMsg {
+	//table 40
+	u_int8_t  Management_Message_Type				:8;
+	u_int16_t Transaction_ID						:16;
+	u_int8_t  Confirmation_Code						:8; //table 384
+};
+
+struct DsxRvdMsg {
+	//table 56
+	u_int8_t  Management_Message_Type				:8;
+	u_int16_t Transaction_ID						:16;
+	u_int8_t  Confirmation_Code						:8; //table 384
+};
+#endif
diff -u -r -N ns-2.34.original/mac/mac-802_16/timer-802_16.cc ns-2.34/mac/mac-802_16/timer-802_16.cc
--- ns-2.34.original/mac/mac-802_16/timer-802_16.cc	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/mac/mac-802_16/timer-802_16.cc	2007-12-14 09:27:16.000000000 +0800
@@ -0,0 +1,186 @@
+/**************************************************************************************
+* *Copyright (c) 2006 Regents of the University of Chang Gung 						*
+* *All rights reserved.													*
+ *																*
+ * Redistribution and use in source and binary forms, with or without						*
+ * modification, are permitted provided that the following conditions					*
+ * are met: 															*
+ * 1. Redistributions of source code must retain the above copyright						*
+ *    notice, this list of conditions and the following disclaimer.						*
+ * 2. Redistributions in binary form must reproduce the above copyright					*
+ *    notice, this list of conditions and the following disclaimer in the						*
+ *    documentation and/or other materials provided with the distribution.					*
+ * 3. All advertising materials mentioning features or use of this software					*
+ *    must display the following acknowledgement:									*
+ *	This product includes software developed by the Computer Systems					*
+ *	Engineering Group at Lawrence Berkeley Laboratory.							*
+ * 4. Neither the name of the University nor of the Laboratory may be used					*
+ *    to endorse or promote products derived from this software without					*
+ *    specific prior written permission.										*
+ *5. If you have any problem about these codes, 									*
+       please mail to antibanish@gmail.com or b9229008@stmail.cgu.edu.tw                    			*
+**************************************************************************************/
+#include "timer-802_16.h"
+#include <packet.h>
+#include <assert.h>
+#include <random.h>
+#include <scheduler.h>
+#include "mac-802_16.h"
+
+void Mac802_16Timer::start(double time)
+{
+	Scheduler &s = Scheduler::instance();
+	assert(busy_ == 0);
+	busy_ = 1;
+	paused_ = 0;
+	stime = s.clock();
+	wtime = time;
+	assert(wtime >= 0.0);
+	////event.uid_ = 0;
+	s.schedule(this, &event, wtime);
+}
+ 
+void Mac802_16Timer::stop(void)
+{ 
+	Scheduler &s = Scheduler::instance();
+
+	assert(busy_);
+	if(paused_ == 0)
+		s.cancel(&event);
+}
+
+void Mac802_16Timer::handle(Event* e){}
+
+void FrameTimer::start(double time)
+{
+	Scheduler &s = Scheduler::instance();
+	assert(busy_ == 0);
+	busy_ = 1;
+	paused_ = 0;
+	stime = s.clock();
+	rtime = time;
+	intr.uid_=0;
+	assert(rtime >= 0.0);
+	s.schedule(this, &intr, rtime);
+}
+
+void FrameTimer::handle(Event* e)
+{ 
+	busy_=0;
+	paused_=0;
+	stime=0.0;
+	wtime=0.0;
+	mac->FrameTimerHandler();
+}
+
+void PreambleTimer::start(double time)
+{
+	Scheduler &s = Scheduler::instance();
+	assert(busy_ == 0);
+	busy_ = 1;
+	paused_ = 0;
+	stime = s.clock();
+	rtime = time;
+	intr.uid_=0;
+	assert(rtime >= 0.0);
+	s.schedule(this, &intr, rtime);
+}
+
+void PreambleTimer::handle(Event* e)
+{ 
+	busy_=0;
+	paused_=0;
+	stime=0.0;
+	wtime=0.0;
+	mac->PreambleTimerHandler();
+}
+
+void DownlinkTimer::start(double time, Packet *p)
+{
+	Scheduler &s = Scheduler::instance();
+	assert(busy_ == 0);
+	pkt = p;
+	busy_ = 1;
+	paused_ = 0;
+	stime = s.clock();
+	rtime = time;
+	intr.uid_=0;
+	assert(rtime >= 0.0);
+	s.schedule(this, &intr, rtime);
+}
+
+void DownlinkTimer::handle(Event* e)
+{ 
+	busy_=0;
+	paused_=0;
+	stime=0.0;
+	wtime=0.0;
+	mac->DownlinkTimerHandler(pkt);
+}
+
+void UplinkTimer::start(double time, Packet *p)
+{
+	Scheduler &s = Scheduler::instance();
+	assert(busy_ == 0);
+	pkt = p;
+	busy_ = 1;
+	paused_ = 0;
+	stime = s.clock();
+	rtime = time;
+	intr.uid_=0;
+	assert(rtime >= 0.0);
+	s.schedule(this, &intr, rtime);
+}
+
+void UplinkTimer::handle(Event* e)
+{ 
+	busy_=0;
+	paused_=0;
+	stime=0.0;
+	wtime=0.0;
+	mac->UplinkTimerHandler(pkt);
+}
+
+void UlMapTimer::start(double time)
+{
+	Scheduler &s = Scheduler::instance();
+	assert(busy_ == 0);
+	busy_ = 1;
+	paused_ = 0;
+	stime = s.clock();
+	rtime = time;
+	intr.uid_=0;
+	assert(rtime >= 0.0);
+	s.schedule(this, &intr, rtime);
+}
+
+void UlMapTimer::handle(Event* e)
+{ 
+	busy_=0;
+	paused_=0;
+	stime=0.0;
+	wtime=0.0;
+	mac->SsScheduler();
+}
+
+void DlMapTimer::start(double time)
+{
+	Scheduler &s = Scheduler::instance();
+	assert(busy_ == 0);
+	busy_ = 1;
+	paused_ = 0;
+	stime = s.clock();
+	rtime = time;
+	intr.uid_=0;
+	assert(rtime >= 0.0);
+	s.schedule(this, &intr, rtime);
+}
+
+void DlMapTimer::handle(Event* e)
+{ 
+	busy_=0;
+	paused_=0;
+	stime=0.0;
+	wtime=0.0;
+	mac->BsScheduler();
+}
diff -u -r -N ns-2.34.original/mac/mac-802_16/timer-802_16.h ns-2.34/mac/mac-802_16/timer-802_16.h
--- ns-2.34.original/mac/mac-802_16/timer-802_16.h	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/mac/mac-802_16/timer-802_16.h	2007-12-14 09:27:16.000000000 +0800
@@ -0,0 +1,101 @@
+/**************************************************************************************
+* *Copyright (c) 2006 Regents of the University of Chang Gung 						*
+* *All rights reserved.													*
+ *																*
+ * Redistribution and use in source and binary forms, with or without						*
+ * modification, are permitted provided that the following conditions					*
+ * are met: 															*
+ * 1. Redistributions of source code must retain the above copyright						*
+ *    notice, this list of conditions and the following disclaimer.						*
+ * 2. Redistributions in binary form must reproduce the above copyright					*
+ *    notice, this list of conditions and the following disclaimer in the						*
+ *    documentation and/or other materials provided with the distribution.					*
+ * 3. All advertising materials mentioning features or use of this software					*
+ *    must display the following acknowledgement:									*
+ *	This product includes software developed by the Computer Systems					*
+ *	Engineering Group at Lawrence Berkeley Laboratory.							*
+ * 4. Neither the name of the University nor of the Laboratory may be used					*
+ *    to endorse or promote products derived from this software without					*
+ *    specific prior written permission.										*
+ *5. If you have any problem about these codes, 									*
+       please mail to antibanish@gmail.com or b9229008@stmail.cgu.edu.tw                    			*
+**************************************************************************************/
+#ifndef __mac_timers_80216_h__
+#define __mac_timers_80216_h__
+
+#include <scheduler.h>
+#include <assert.h>
+#include <packet.h>
+#include "packet-802_16.h"
+
+class Mac802_16;
+
+class Mac802_16Timer : public Handler
+{
+	public:
+		Mac802_16Timer(Mac802_16* m):mac(m),rtime(0){busy_ = paused_ = 0; stime = 0.0;};
+		virtual void	handle(Event *e)=0;		
+		virtual void	start(double time);
+		virtual void	stop(void);
+		virtual void	pause(void) {assert(0);}
+		virtual void	resume(void) {assert(0);}
+		inline int	busy(void) {return busy_;}
+		inline int	paused(void) {return paused_;}
+
+	protected:
+		Mac802_16	*mac;
+		int			busy_;
+		int			paused_;
+		Event		event;
+		Event		intr;		
+		double		stime;		//start time
+		double		wtime;		//waiting time
+		double      rtime;
+};
+
+class FrameTimer:public Mac802_16Timer{
+	public:
+		FrameTimer(Mac802_16* m):Mac802_16Timer(m){};
+		void 	start(double time);		
+		void	handle(Event *e);
+};
+
+class PreambleTimer:public Mac802_16Timer{
+	public:
+		PreambleTimer(Mac802_16* m):Mac802_16Timer(m){};
+		void 	start(double time);		
+		void	handle(Event *e);
+};
+
+class DownlinkTimer:public Mac802_16Timer{
+	public:
+		DownlinkTimer(Mac802_16* m):Mac802_16Timer(m){};
+		void 	start(double time, Packet *p);		
+		void	handle(Event *e);
+	protected:
+		Packet *pkt;
+};
+
+class UplinkTimer:public Mac802_16Timer{
+	public:
+		UplinkTimer(Mac802_16* m):Mac802_16Timer(m){};
+		void 	start(double time, Packet *p);		
+		void	handle(Event *e);
+	protected:
+		Packet *pkt;
+};
+
+class UlMapTimer:public Mac802_16Timer{
+	public:
+		UlMapTimer(Mac802_16* m):Mac802_16Timer(m){};
+		void 	start(double time);		
+		void	handle(Event *e);
+};
+
+class DlMapTimer:public Mac802_16Timer{
+	public:
+		DlMapTimer(Mac802_16* m):Mac802_16Timer(m){};
+		void 	start(double time);		
+		void	handle(Event *e);
+};
+#endif
diff -u -r -N ns-2.34.original/mac/mac-802_16/traffic/BE_traffic.cc ns-2.34/mac/mac-802_16/traffic/BE_traffic.cc
--- ns-2.34.original/mac/mac-802_16/traffic/BE_traffic.cc	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/mac/mac-802_16/traffic/BE_traffic.cc	2007-12-14 09:27:16.000000000 +0800
@@ -0,0 +1,82 @@
+/**************************************************************************************
+* *Copyright (c) 2006 Regents of the University of Chang Gung 						*
+* *All rights reserved.													*
+ *																*
+ * Redistribution and use in source and binary forms, with or without						*
+ * modification, are permitted provided that the following conditions					*
+ * are met: 															*
+ * 1. Redistributions of source code must retain the above copyright						*
+ *    notice, this list of conditions and the following disclaimer.						*
+ * 2. Redistributions in binary form must reproduce the above copyright					*
+ *    notice, this list of conditions and the following disclaimer in the						*
+ *    documentation and/or other materials provided with the distribution.					*
+ * 3. All advertising materials mentioning features or use of this software					*
+ *    must display the following acknowledgement:									*
+ *	This product includes software developed by the Computer Systems					*
+ *	Engineering Group at Lawrence Berkeley Laboratory.							*
+ * 4. Neither the name of the University nor of the Laboratory may be used					*
+ *    to endorse or promote products derived from this software without					*
+ *    specific prior written permission.										*
+ *5. If you have any problem about these codes, 									*
+       please mail to antibanish@gmail.com or b9229008@stmail.cgu.edu.tw                    			*
+**************************************************************************************/
+
+#include "random.h"
+#include "tcp.h"
+#include "BE_traffic.h"
+
+extern double tcplib_telnet_interarrival();
+
+static class BEAppClass : public TclClass {
+ public:
+	BEAppClass() : TclClass("Application/BE") {}
+	TclObject* create(int, const char*const*) {
+		return (new BEApp);
+	}
+} class_app_BE;
+
+
+BEApp::BEApp() : running_(0), timer_(this)
+{
+	//bind("interval_", &interval_);
+	interval_ = 0.01;
+}
+
+
+void BEAppTimer::expire(Event*)
+{
+    t_->timeout();
+}
+
+
+void BEApp::start()
+{
+    running_ = 1;
+	double t = next();
+	timer_.sched(t);
+}
+
+void BEApp::stop()
+{
+    running_ = 0;
+}
+
+void BEApp::timeout()
+{
+    if (running_) {
+		//BE service using variable bit rate packet.
+		size_ = (int)Random::uniform(200, 1000);
+		agent_->size() = size_;
+		agent_->send(agent_->size());
+		//Setting packet type to BE.
+		agent_->set_pkttype(PT_BE);
+		/* reschedule the timer */
+		double t = next();
+		timer_.resched(t);
+	}
+}
+
+double BEApp::next()
+{
+	return interval_;
+}
diff -u -r -N ns-2.34.original/mac/mac-802_16/traffic/BE_traffic.h ns-2.34/mac/mac-802_16/traffic/BE_traffic.h
--- ns-2.34.original/mac/mac-802_16/traffic/BE_traffic.h	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/mac/mac-802_16/traffic/BE_traffic.h	2007-12-14 09:27:16.000000000 +0800
@@ -0,0 +1,58 @@
+/**************************************************************************************
+* *Copyright (c) 2006 Regents of the University of Chang Gung 						*
+* *All rights reserved.													*
+ *																*
+ * Redistribution and use in source and binary forms, with or without						*
+ * modification, are permitted provided that the following conditions					*
+ * are met: 															*
+ * 1. Redistributions of source code must retain the above copyright						*
+ *    notice, this list of conditions and the following disclaimer.						*
+ * 2. Redistributions in binary form must reproduce the above copyright					*
+ *    notice, this list of conditions and the following disclaimer in the						*
+ *    documentation and/or other materials provided with the distribution.					*
+ * 3. All advertising materials mentioning features or use of this software					*
+ *    must display the following acknowledgement:									*
+ *	This product includes software developed by the Computer Systems					*
+ *	Engineering Group at Lawrence Berkeley Laboratory.							*
+ * 4. Neither the name of the University nor of the Laboratory may be used					*
+ *    to endorse or promote products derived from this software without					*
+ *    specific prior written permission.										*
+ *5. If you have any problem about these codes, 									*
+       please mail to antibanish@gmail.com or b9229008@stmail.cgu.edu.tw                    			*
+**************************************************************************************/
+
+#ifndef ns_BE_h
+#define ns_BE_h
+
+#include "timer-handler.h"
+#include "app.h"
+
+class TcpAgent;
+class TfrcAgent;
+class BEApp;
+
+class BEAppTimer : public TimerHandler {
+ public:
+	BEAppTimer(BEApp* t) : TimerHandler(), t_(t) {}
+	inline virtual void expire(Event*);
+ protected:
+	BEApp* t_;
+};
+
+
+class BEApp : public Application {
+ public:
+	BEApp();
+	void timeout();
+ protected:
+	void start();
+	void stop();
+	inline double next();
+
+	double interval_;
+	int size_;
+	int running_;
+	BEAppTimer timer_;
+};
+
+#endif
diff -u -r -N ns-2.34.original/mac/mac-802_16/traffic/UGS_traffic.cc ns-2.34/mac/mac-802_16/traffic/UGS_traffic.cc
--- ns-2.34.original/mac/mac-802_16/traffic/UGS_traffic.cc	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/mac/mac-802_16/traffic/UGS_traffic.cc	2007-12-14 09:27:16.000000000 +0800
@@ -0,0 +1,101 @@
+/**************************************************************************************
+* *Copyright (c) 2006 Regents of the University of Chang Gung 						*
+* *All rights reserved.													*
+ *																*
+ * Redistribution and use in source and binary forms, with or without						*
+ * modification, are permitted provided that the following conditions					*
+ * are met: 															*
+ * 1. Redistributions of source code must retain the above copyright						*
+ *    notice, this list of conditions and the following disclaimer.						*
+ * 2. Redistributions in binary form must reproduce the above copyright					*
+ *    notice, this list of conditions and the following disclaimer in the						*
+ *    documentation and/or other materials provided with the distribution.					*
+ * 3. All advertising materials mentioning features or use of this software					*
+ *    must display the following acknowledgement:									*
+ *	This product includes software developed by the Computer Systems					*
+ *	Engineering Group at Lawrence Berkeley Laboratory.							*
+ * 4. Neither the name of the University nor of the Laboratory may be used					*
+ *    to endorse or promote products derived from this software without					*
+ *    specific prior written permission.										*
+ *5. If you have any problem about these codes, 									*
+       please mail to antibanish@gmail.com or b9229008@stmail.cgu.edu.tw                    			*
+**************************************************************************************/
+#include <stdlib.h>
+ 
+#include "random.h"
+#include "trafgen.h"
+#include "ranvar.h"
+#include "priority.h"
+
+
+/* 
+ * Constant bit rate traffic source.   Parameterized by interval, (optional)
+ * random noise in the interval, and packet size.  
+ */
+
+class UGS_Traffic : public TrafficGenerator {
+ public:
+	UGS_Traffic();
+	virtual double next_interval(int&);
+	//HACK so that udp agent knows interpacket arrival time within a burst
+	inline double interval() { return (interval_); }
+ protected:
+	virtual void start();
+	void init();
+	double rate_;     /* send rate during on time (bps) */
+	double interval_; /* packet inter-arrival time during burst (sec) */
+	double random_;
+	int seqno_;
+	int maxpkts_;
+};
+
+static class UGSTrafficClass : public TclClass {
+ public:
+	UGSTrafficClass() : TclClass("Application/Traffic/UGS") {}
+	TclObject* create(int, const char*const*) {
+		return (new UGS_Traffic());
+	}
+} class_UGS_Traffic;
+
+UGS_Traffic::UGS_Traffic() : seqno_(0)
+{
+	rate_ = 64000;
+	random_ = 0;
+	size_ = 200;
+	maxpkts_ = 268435456;
+}
+
+void UGS_Traffic::init()
+{
+    // compute inter-packet interval 
+	interval_ = (double)(size_ << 3)/(double)rate_;
+	if (agent_)
+		if (agent_->get_pkttype() != PT_TCP && agent_->get_pkttype() != PT_TFRC)
+			//Setting packet type to UGS.
+			agent_->set_pkttype(PT_UGS);
+			//x.setpriority(agent_,1);
+}
+
+void UGS_Traffic::start()
+{
+    init();
+    running_ = 1;
+    timeout();
+}
+
+double UGS_Traffic::next_interval(int& size)
+{
+	// Recompute interval in case rate_ or size_ has changes
+	interval_ = (double)(size << 3)/(double)rate_;
+	double t = interval_;
+	if (random_)
+		t += interval_ * Random::uniform(-0.5, 0.5);
+	//UGS service using constant bit rate packet.	
+	size = 200;
+	
+	if (++seqno_ < maxpkts_)
+		return(t);
+	else
+		return(-1); 
+}
+
diff -u -r -N ns-2.34.original/mac/mac-802_16/traffic/ertPS_traffic.cc ns-2.34/mac/mac-802_16/traffic/ertPS_traffic.cc
--- ns-2.34.original/mac/mac-802_16/traffic/ertPS_traffic.cc	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/mac/mac-802_16/traffic/ertPS_traffic.cc	2007-12-14 09:27:16.000000000 +0800
@@ -0,0 +1,130 @@
+/**************************************************************************************
+* *Copyright (c) 2006 Regents of the University of Chang Gung 						*
+* *All rights reserved.													*
+ *																*
+ * Redistribution and use in source and binary forms, with or without						*
+ * modification, are permitted provided that the following conditions					*
+ * are met: 															*
+ * 1. Redistributions of source code must retain the above copyright						*
+ *    notice, this list of conditions and the following disclaimer.						*
+ * 2. Redistributions in binary form must reproduce the above copyright					*
+ *    notice, this list of conditions and the following disclaimer in the						*
+ *    documentation and/or other materials provided with the distribution.					*
+ * 3. All advertising materials mentioning features or use of this software					*
+ *    must display the following acknowledgement:									*
+ *	This product includes software developed by the Computer Systems					*
+ *	Engineering Group at Lawrence Berkeley Laboratory.							*
+ * 4. Neither the name of the University nor of the Laboratory may be used					*
+ *    to endorse or promote products derived from this software without					*
+ *    specific prior written permission.										*
+ *5. If you have any problem about these codes, 									*
+       please mail to antibanish@gmail.com or b9229008@stmail.cgu.edu.tw                    			*
+**************************************************************************************/
+#include <stdlib.h>
+ 
+#include "random.h"
+#include "trafgen.h"
+#include "ranvar.h"
+
+
+/* 
+ * Constant bit rate traffic source.   Parameterized by interval, (optional)
+ * random noise in the interval, and packet size.  
+ */
+double talk_spurt = 1;
+double silence_spurt = 0.1;
+double duration = 0;
+double last_duration = 0;
+int talking_ = 1;
+
+class ertPS_Traffic : public TrafficGenerator {
+ public:
+	ertPS_Traffic();
+	virtual double next_interval(int&);
+	//HACK so that udp agent knows interpacket arrival time within a burst
+	inline double interval() { return (interval_); }
+ protected:
+	virtual void start();
+	void init();
+	double rate_;     /* send rate during on time (bps) */
+	double interval_; /* packet inter-arrival time during burst (sec) */
+	double random_;
+	int seqno_;
+	int maxpkts_;
+};
+
+static class ertPSTrafficClass : public TclClass {
+ public:
+	ertPSTrafficClass() : TclClass("Application/Traffic/ertPS") {}
+	TclObject* create(int, const char*const*) {
+		return (new ertPS_Traffic());
+	}
+} class_ertPS_Traffic;
+
+ertPS_Traffic::ertPS_Traffic() : seqno_(0)
+{
+	rate_ = 64000;
+	random_ = 0;
+	size_ = 200;
+	maxpkts_ = 268435456;
+}
+
+void ertPS_Traffic::init()
+{
+    // compute inter-packet interval 
+	interval_ = (double)(size_ << 3)/(double)rate_;
+	//printf("interval_ : %f \n",interval_);
+	if (agent_)
+		if (agent_->get_pkttype() != PT_TCP && agent_->get_pkttype() != PT_TFRC)
+			//Setting packet type to ertPS.
+			agent_->set_pkttype(PT_ertPS);
+}
+
+void ertPS_Traffic::start()
+{
+    init();
+    running_ = 1;
+    timeout();
+}
+
+double ertPS_Traffic::next_interval(int& size)
+{		
+	// Recompute interval in case rate_ or size_ has changes
+	interval_ = (double)(200 << 3)/(double)rate_;
+	double t = interval_;
+	if (random_)
+		t += interval_ * Random::uniform(-0.5, 0.5);
+		
+	if (talking_ == 1 && (duration - last_duration) > talk_spurt) {	
+		//If talking time is large than talk-spurt.		
+		size = 1;
+		if (talking_ == 1) {
+			last_duration = duration;
+			talking_ = 0;
+		}
+		//printf("          ~~~~ change to silence ~~~~~\n");
+	} else if (talking_ == 1 && (duration - last_duration) <= talk_spurt) {
+		//If talking time is less than talk-spurt.
+		size = 200;
+		//printf("         ~~~~ talk mode ~~~~~\n");
+	} else if (talking_ == 0 && (duration - last_duration) > silence_spurt) {
+		//If silence time is large than silence-spurt.
+		size = 200;
+		if (talking_ == 0) {
+			last_duration = duration;
+			talking_ = 1;
+		}
+		//printf("          ~~~~ change to talk ~~~~~\n");
+	} else if (talking_ == 0 && (duration - last_duration) <= silence_spurt) {
+		//If silence time is less than silence-spurt.
+		size = 1;
+		//printf("          ~~~~ silence mode ~~~~~\n");
+	}
+	duration = duration + t;
+	
+	if (++seqno_ < maxpkts_)
+		return(t);
+	else
+		return(-1); 
+}
+
diff -u -r -N ns-2.34.original/mac/mac-802_16/traffic/nrtPS_traffic.cc ns-2.34/mac/mac-802_16/traffic/nrtPS_traffic.cc
--- ns-2.34.original/mac/mac-802_16/traffic/nrtPS_traffic.cc	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/mac/mac-802_16/traffic/nrtPS_traffic.cc	2007-12-14 09:27:16.000000000 +0800
@@ -0,0 +1,82 @@
+/**************************************************************************************
+* *Copyright (c) 2006 Regents of the University of Chang Gung 						*
+* *All rights reserved.													*
+ *																*
+ * Redistribution and use in source and binary forms, with or without						*
+ * modification, are permitted provided that the following conditions					*
+ * are met: 															*
+ * 1. Redistributions of source code must retain the above copyright						*
+ *    notice, this list of conditions and the following disclaimer.						*
+ * 2. Redistributions in binary form must reproduce the above copyright					*
+ *    notice, this list of conditions and the following disclaimer in the						*
+ *    documentation and/or other materials provided with the distribution.					*
+ * 3. All advertising materials mentioning features or use of this software					*
+ *    must display the following acknowledgement:									*
+ *	This product includes software developed by the Computer Systems					*
+ *	Engineering Group at Lawrence Berkeley Laboratory.							*
+ * 4. Neither the name of the University nor of the Laboratory may be used					*
+ *    to endorse or promote products derived from this software without					*
+ *    specific prior written permission.										*
+ *5. If you have any problem about these codes, 									*
+       please mail to antibanish@gmail.com or b9229008@stmail.cgu.edu.tw                    			*
+**************************************************************************************/
+
+#include "random.h"
+#include "tcp.h"
+#include "nrtPS_traffic.h"
+
+extern double tcplib_telnet_interarrival();
+
+static class nrtPSAppClass : public TclClass {
+ public:
+	nrtPSAppClass() : TclClass("Application/nrtPS") {}
+	TclObject* create(int, const char*const*) {
+		return (new nrtPSApp);
+	}
+} class_app_nrtPS;
+
+
+nrtPSApp::nrtPSApp() : running_(0), timer_(this)
+{
+	//bind("interval_", &interval_);
+	interval_ = 0.01;
+}
+
+
+void nrtPSAppTimer::expire(Event*)
+{
+    t_->timeout();
+}
+
+
+void nrtPSApp::start()
+{
+    running_ = 1;
+	double t = next();
+	timer_.sched(t);
+}
+
+void nrtPSApp::stop()
+{
+    running_ = 0;
+}
+
+void nrtPSApp::timeout()
+{
+    if (running_) {
+		//nrtPS service using variable bit rate packet.
+		size_ = (int)Random::uniform(200, 1000);
+		agent_->size() = size_;
+		agent_->send(agent_->size());
+		//Setting packet type to nrtPS.
+		agent_->set_pkttype(PT_nrtPS);
+		/* reschedule the timer */
+		double t = next();
+		timer_.resched(t);
+	}
+}
+
+double nrtPSApp::next()
+{
+	return interval_;
+}
diff -u -r -N ns-2.34.original/mac/mac-802_16/traffic/nrtPS_traffic.h ns-2.34/mac/mac-802_16/traffic/nrtPS_traffic.h
--- ns-2.34.original/mac/mac-802_16/traffic/nrtPS_traffic.h	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/mac/mac-802_16/traffic/nrtPS_traffic.h	2007-12-14 09:27:16.000000000 +0800
@@ -0,0 +1,58 @@
+/**************************************************************************************
+* *Copyright (c) 2006 Regents of the University of Chang Gung 						*
+* *All rights reserved.													*
+ *																*
+ * Redistribution and use in source and binary forms, with or without						*
+ * modification, are permitted provided that the following conditions					*
+ * are met: 															*
+ * 1. Redistributions of source code must retain the above copyright						*
+ *    notice, this list of conditions and the following disclaimer.						*
+ * 2. Redistributions in binary form must reproduce the above copyright					*
+ *    notice, this list of conditions and the following disclaimer in the						*
+ *    documentation and/or other materials provided with the distribution.					*
+ * 3. All advertising materials mentioning features or use of this software					*
+ *    must display the following acknowledgement:									*
+ *	This product includes software developed by the Computer Systems					*
+ *	Engineering Group at Lawrence Berkeley Laboratory.							*
+ * 4. Neither the name of the University nor of the Laboratory may be used					*
+ *    to endorse or promote products derived from this software without					*
+ *    specific prior written permission.										*
+ *5. If you have any problem about these codes, 									*
+       please mail to antibanish@gmail.com or b9229008@stmail.cgu.edu.tw                    			*
+**************************************************************************************/
+
+#ifndef ns_nrtPS_h
+#define ns_nrtPS_h
+
+#include "timer-handler.h"
+#include "app.h"
+
+class TcpAgent;
+class TfrcAgent;
+class nrtPSApp;
+
+class nrtPSAppTimer : public TimerHandler {
+ public:
+	nrtPSAppTimer(nrtPSApp* t) : TimerHandler(), t_(t) {}
+	inline virtual void expire(Event*);
+ protected:
+	nrtPSApp* t_;
+};
+
+
+class nrtPSApp : public Application {
+ public:
+	nrtPSApp();
+	void timeout();
+ protected:
+	void start();
+	void stop();
+	inline double next();
+
+	double interval_;
+	int size_;
+	int running_;
+	nrtPSAppTimer timer_;
+};
+
+#endif
diff -u -r -N ns-2.34.original/mac/mac-802_16/traffic/priority.cc ns-2.34/mac/mac-802_16/traffic/priority.cc
--- ns-2.34.original/mac/mac-802_16/traffic/priority.cc	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/mac/mac-802_16/traffic/priority.cc	2007-12-14 09:27:16.000000000 +0800
@@ -0,0 +1,27 @@
+#include "priority.h"
+#include "agent.h"
+#include "packet.h"
+
+void priority::setpriority(Agent* agent, int priority){
+packet_t pt;
+
+//]wstype
+if(priority == 1){
+pt = PT_UGS;
+}
+else if(priority == 2){
+pt = PT_ertPS;
+}
+else if(priority == 3){
+pt = PT_rtPS;
+}
+else if(priority == 4){
+pt = PT_nrtPS;
+}
+else if(priority == 2){
+pt = PT_BE;
+}
+
+//]wpacket type
+agent->set_pkttype(pt);
+}
\ No newline at end of file
diff -u -r -N ns-2.34.original/mac/mac-802_16/traffic/priority.h ns-2.34/mac/mac-802_16/traffic/priority.h
--- ns-2.34.original/mac/mac-802_16/traffic/priority.h	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/mac/mac-802_16/traffic/priority.h	2007-12-14 09:27:16.000000000 +0800
@@ -0,0 +1,7 @@
+#include "packet.h"
+#include "agent.h"
+
+class priority{
+public:
+void setpriority(Agent* agent, int priority);
+};
\ No newline at end of file
diff -u -r -N ns-2.34.original/mac/mac-802_16/traffic/rtPS_traffic.cc ns-2.34/mac/mac-802_16/traffic/rtPS_traffic.cc
--- ns-2.34.original/mac/mac-802_16/traffic/rtPS_traffic.cc	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/mac/mac-802_16/traffic/rtPS_traffic.cc	2007-12-14 09:27:16.000000000 +0800
@@ -0,0 +1,99 @@
+/**************************************************************************************
+* *Copyright (c) 2006 Regents of the University of Chang Gung 						*
+* *All rights reserved.													*
+ *																*
+ * Redistribution and use in source and binary forms, with or without						*
+ * modification, are permitted provided that the following conditions					*
+ * are met: 															*
+ * 1. Redistributions of source code must retain the above copyright						*
+ *    notice, this list of conditions and the following disclaimer.						*
+ * 2. Redistributions in binary form must reproduce the above copyright					*
+ *    notice, this list of conditions and the following disclaimer in the						*
+ *    documentation and/or other materials provided with the distribution.					*
+ * 3. All advertising materials mentioning features or use of this software					*
+ *    must display the following acknowledgement:									*
+ *	This product includes software developed by the Computer Systems					*
+ *	Engineering Group at Lawrence Berkeley Laboratory.							*
+ * 4. Neither the name of the University nor of the Laboratory may be used					*
+ *    to endorse or promote products derived from this software without					*
+ *    specific prior written permission.										*
+ *5. If you have any problem about these codes, 									*
+       please mail to antibanish@gmail.com or b9229008@stmail.cgu.edu.tw                    			*
+**************************************************************************************/
+#include <stdlib.h>
+ 
+#include "random.h"
+#include "trafgen.h"
+#include "ranvar.h"
+
+
+/* 
+ * Constant bit rate traffic source.   Parameterized by interval, (optional)
+ * random noise in the interval, and packet size.  
+ */
+
+class rtPS_Traffic : public TrafficGenerator {
+ public:
+	rtPS_Traffic();
+	virtual double next_interval(int&);
+	//HACK so that udp agent knows interpacket arrival time within a burst
+	inline double interval() { return (interval_); }
+ protected:
+	virtual void start();
+	void init();
+	double rate_;     /* send rate during on time (bps) */
+	double interval_; /* packet inter-arrival time during burst (sec) */
+	double random_;
+	int seqno_;
+	int maxpkts_;
+};
+
+static class rtPSTrafficClass : public TclClass {
+ public:
+	rtPSTrafficClass() : TclClass("Application/Traffic/rtPS") {}
+	TclObject* create(int, const char*const*) {
+		return (new rtPS_Traffic());
+	}
+} class_rtPS_Traffic;
+
+rtPS_Traffic::rtPS_Traffic() : seqno_(0)
+{
+	rate_ = 1024000;
+	random_ = 1;
+	size_ = 200;
+	maxpkts_ = 268435456;
+}
+
+void rtPS_Traffic::init()
+{
+    // compute inter-packet interval 
+	interval_ = (double)(size_ << 3)/(double)rate_;
+	if (agent_)
+		if (agent_->get_pkttype() != PT_TCP && agent_->get_pkttype() != PT_TFRC)
+			//Setting packet type to rtPS.
+			agent_->set_pkttype(PT_rtPS);
+}
+
+void rtPS_Traffic::start()
+{
+    init();
+    running_ = 1;
+    timeout();
+}
+
+double rtPS_Traffic::next_interval(int& size)
+{
+	// Recompute interval in case rate_ or size_ has changes
+	interval_ = (double)(size << 3)/(double)rate_;
+	double t = interval_;
+	if (random_)
+		t += interval_ * Random::uniform(-0.5, 0.5);
+	//nrtPS service using variable bit rate packet.
+	size = (int)Random::uniform(200, 1000);
+	
+	if (++seqno_ < maxpkts_)
+		return(t);
+	else
+		return(-1); 
+}
+
diff -u -r -N ns-2.34.original/queue/queue.h ns-2.34/queue/queue.h
--- ns-2.34.original/queue/queue.h	2009-06-15 01:35:44.000000000 +0800
+++ ns-2.34/queue/queue.h	2012-08-08 15:01:23.749500000 +0800
@@ -1,177 +1,185 @@
-/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
-/*
- * Copyright (c) 1996-1997 The Regents of the University of California.
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- * 	This product includes software developed by the Network Research
- * 	Group at Lawrence Berkeley National Laboratory.
- * 4. Neither the name of the University nor of the Laboratory may be used
- *    to endorse or promote products derived from this software without
- *    specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * @(#) $Header: /cvsroot/nsnam/ns-2/queue/queue.h,v 1.35 2005/01/13 18:33:48 haldar Exp $ (LBL)
- */
-
-#ifndef ns_queue_h
-#define ns_queue_h
-
-#include "connector.h"
-#include "packet.h"
-#include "ip.h"
-class Packet;
-
-class PacketQueue : public TclObject {
-public:
-	PacketQueue() : head_(0), tail_(0), len_(0), bytes_(0) {}
-	virtual int length() const { return (len_); }
-	virtual int byteLength() const { return (bytes_); }
-	virtual Packet* enque(Packet* p) { // Returns previous tail
-		Packet* pt = tail_;
-		if (!tail_) head_= tail_= p;
-		else {
-			tail_->next_= p;
-			tail_= p;
-		}
-		tail_->next_= 0;
-		++len_;
-		bytes_ += hdr_cmn::access(p)->size();
-		return pt;
-	}
-	virtual Packet* deque() {
-		if (!head_) return 0;
-		Packet* p = head_;
-		head_= p->next_; // 0 if p == tail_
-		if (p == tail_) head_= tail_= 0;
-		--len_;
-		bytes_ -= hdr_cmn::access(p)->size();
-		return p;
-	}
-	Packet* lookup(int n) {
-		for (Packet* p = head_; p != 0; p = p->next_) {
-			if (--n < 0)
-				return (p);
-		}
-		return (0);
-	}
-	/* remove a specific packet, which must be in the queue */
-	virtual void remove(Packet*);
-	/* Remove a packet, located after a given packet. Either could be 0. */
-	void remove(Packet *, Packet *);
-        Packet* head() { return head_; }
-	Packet* tail() { return tail_; }
-	// MONARCH EXTNS
-	virtual inline void enqueHead(Packet* p) {
-	        if (!head_) tail_ = p;
-	        p->next_ = head_;
-		head_ = p;
-		++len_;
-		bytes_ += hdr_cmn::access(p)->size();
-	}
-        void resetIterator() {iter = head_;}
-        Packet* getNext() { 
-	        if (!iter) return 0;
-		Packet *tmp = iter; iter = iter->next_;
-		return tmp;
-	}
-
-protected:
-	Packet* head_;
-	Packet* tail_;
-	int len_;		// packet count
-	int bytes_;		// queue size in bytes
-
-
-// MONARCH EXTNS
-private:
-	Packet *iter;
-};
-
-class Queue;
-
-class QueueHandler : public Handler {
-public:
-	inline QueueHandler(Queue& q) : queue_(q) {}
-	void handle(Event*);
-private:
-	Queue& queue_;
-};
-
-
-class Queue : public Connector {
-public:
-	virtual void enque(Packet*) = 0;
-	virtual Packet* deque() = 0;
-	virtual void recv(Packet*, Handler*);
-	virtual void updateStats(int queuesize); 
-	void resume();
-	
-	int blocked() const { return (blocked_ == 1); }
-	void unblock() { blocked_ = 0; }
-	void block() { blocked_ = 1; }
-	int limit() { return qlim_; }
-	int length() { return pq_->length(); }	/* number of pkts currently in
-						 * underlying packet queue */
-	int byteLength() { return pq_->byteLength(); }	/* number of bytes *
-						 * currently in packet queue */
-	/* mean utilization, decaying based on util_weight */
-	virtual double utilization (void);
-
-	/* max utilization over recent time period.
-	   Returns the maximum of recent measurements stored in util_buf_*/
-	double peak_utilization(void);
-	virtual ~Queue();
-protected:
-	Queue();
-	void reset();
-	int qlim_;		/* maximum allowed pkts in queue */
-	int blocked_;		/* blocked now? */
-	int unblock_on_resume_;	/* unblock q on idle? */
-	QueueHandler qh_;
-	PacketQueue *pq_;	/* pointer to actual packet queue 
-				 * (maintained by the individual disciplines
-				 * like DropTail and RED). */
-	double true_ave_;	/* true long-term average queue size */
-	double total_time_;	/* total time average queue size compute for */
-
-
-	void utilUpdate(double int_begin, double int_end, int link_state);
-	double last_change_;  /* time at which state changed/utilization measured */
-	double old_util_;     /* current utilization */ 
-	double util_weight_;  /* decay factor for measuring the link utilization */
-	double util_check_intv_; /* interval for reseting the current
-				    utilization measurements (seconds) */
-	double period_begin_;	/* time of starting the current utilization
-				   measurement */
-	double cur_util_;	/* utilization during current time period */
-	int buf_slot_;		/* Currently active utilization buffer */
-	double *util_buf_;    /* Buffer for recent utilization measurements */
-	int util_records_;	/* Number of recent utilization measurements
-				   stored in memory. One slot in buffer holds
-				   period of util_check_intv_ seconds. */
-	// measuring #drops
-	
-};
-
-#endif
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+/*
+ * Copyright (c) 1996-1997 The Regents of the University of California.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ * 	This product includes software developed by the Network Research
+ * 	Group at Lawrence Berkeley National Laboratory.
+ * 4. Neither the name of the University nor of the Laboratory may be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * @(#) $Header: /cvsroot/nsnam/ns-2/queue/queue.h,v 1.35 2005/01/13 18:33:48 haldar Exp $ (LBL)
+ */
+
+#ifndef ns_queue_h
+#define ns_queue_h
+
+#include "connector.h"
+#include "packet.h"
+#include "ip.h"
+class Packet;
+
+class PacketQueue : public TclObject {
+public:
+	PacketQueue() : head_(0), tail_(0), len_(0), bytes_(0) {}
+	virtual int length() const { return (len_); }
+	virtual int byteLength() const { return (bytes_); }
+	virtual Packet* enque(Packet* p) { // Returns previous tail
+		Packet* pt = tail_;
+		if (!tail_) head_= tail_= p;
+		else {
+			tail_->next_= p;
+			tail_= p;
+		}
+		tail_->next_= 0;
+		++len_;
+		bytes_ += hdr_cmn::access(p)->size();
+		return pt;
+	}
+	virtual Packet* deque() {
+		if (!head_) return 0;
+		Packet* p = head_;
+		head_= p->next_; // 0 if p == tail_
+		if (p == tail_) head_= tail_= 0;
+		--len_;
+		bytes_ -= hdr_cmn::access(p)->size();
+		return p;
+	}
+	Packet* lookup(int n) {
+		for (Packet* p = head_; p != 0; p = p->next_) {
+			if (--n < 0)
+				return (p);
+		}
+		return (0);
+	}
+	/* remove a specific packet, which must be in the queue */
+	virtual void remove(Packet*);
+	/* Remove a packet, located after a given packet. Either could be 0. */
+	void remove(Packet *, Packet *);
+        Packet* head() { return head_; }
+	Packet* tail() { return tail_; }
+	// MONARCH EXTNS
+	virtual inline void enqueHead(Packet* p) {
+	        if (!head_) tail_ = p;
+	        p->next_ = head_;
+		head_ = p;
+		++len_;
+		bytes_ += hdr_cmn::access(p)->size();
+	}
+        void resetIterator() {iter = head_;}
+        Packet* getNext() { 
+	        if (!iter) return 0;
+		Packet *tmp = iter; iter = iter->next_;
+		return tmp;
+	}
+	int count(int grab) {	
+		int j = 0;
+		if (bytes_ <= grab) return len_;
+		for (int i = len_; i >= 0; i--, ++j) {			
+			if (grab <= 0) return j; 
+			else grab -= hdr_cmn::access(lookup(i-1))->size();			
+		}
+		return 0;	
+	}
+protected:
+	Packet* head_;
+	Packet* tail_;
+	int len_;		// packet count
+	int bytes_;		// queue size in bytes
+
+
+// MONARCH EXTNS
+private:
+	Packet *iter;
+};
+
+class Queue;
+
+class QueueHandler : public Handler {
+public:
+	inline QueueHandler(Queue& q) : queue_(q) {}
+	void handle(Event*);
+private:
+	Queue& queue_;
+};
+
+
+class Queue : public Connector {
+public:
+	virtual void enque(Packet*) = 0;
+	virtual Packet* deque() = 0;
+	virtual void recv(Packet*, Handler*);
+	virtual void updateStats(int queuesize); 
+	void resume();
+	
+	int blocked() const { return (blocked_ == 1); }
+	void unblock() { blocked_ = 0; }
+	void block() { blocked_ = 1; }
+	int limit() { return qlim_; }
+	int length() { return pq_->length(); }	/* number of pkts currently in
+						 * underlying packet queue */
+	int byteLength() { return pq_->byteLength(); }	/* number of bytes *
+						 * currently in packet queue */
+	/* mean utilization, decaying based on util_weight */
+	virtual double utilization (void);
+
+	/* max utilization over recent time period.
+	   Returns the maximum of recent measurements stored in util_buf_*/
+	double peak_utilization(void);
+	virtual ~Queue();
+protected:
+	Queue();
+	void reset();
+	int qlim_;		/* maximum allowed pkts in queue */
+	int blocked_;		/* blocked now? */
+	int unblock_on_resume_;	/* unblock q on idle? */
+	QueueHandler qh_;
+	PacketQueue *pq_;	/* pointer to actual packet queue 
+				 * (maintained by the individual disciplines
+				 * like DropTail and RED). */
+	double true_ave_;	/* true long-term average queue size */
+	double total_time_;	/* total time average queue size compute for */
+
+
+	void utilUpdate(double int_begin, double int_end, int link_state);
+	double last_change_;  /* time at which state changed/utilization measured */
+	double old_util_;     /* current utilization */ 
+	double util_weight_;  /* decay factor for measuring the link utilization */
+	double util_check_intv_; /* interval for reseting the current
+				    utilization measurements (seconds) */
+	double period_begin_;	/* time of starting the current utilization
+				   measurement */
+	double cur_util_;	/* utilization during current time period */
+	int buf_slot_;		/* Currently active utilization buffer */
+	double *util_buf_;    /* Buffer for recent utilization measurements */
+	int util_records_;	/* Number of recent utilization measurements
+				   stored in memory. One slot in buffer holds
+				   period of util_check_intv_ seconds. */
+	// measuring #drops
+	
+};
+
+#endif
