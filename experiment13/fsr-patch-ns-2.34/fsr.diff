diff -urN ns-2.34.original/Makefile.in ns-2.34/Makefile.in
--- ns-2.34.original/Makefile.in	2009-06-15 01:35:44.000000000 +0800
+++ ns-2.34/Makefile.in	2012-08-08 16:31:57.343250000 +0800
@@ -1,610 +1,612 @@
-#  Copyright (c) 1994, 1995, 1996
-# 	The Regents of the University of California.  All rights reserved.
-#
-#  Redistribution and use in source and binary forms, with or without
-#  modification, are permitted provided that: (1) source code distributions
-#  retain the above copyright notice and this paragraph in its entirety, (2)
-#  distributions including binary code include the above copyright notice and
-#  this paragraph in its entirety in the documentation or other materials
-#  provided with the distribution, and (3) all advertising materials mentioning
-#  features or use of this software display the following acknowledgement:
-#  ``This product includes software developed by the University of California,
-#  Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
-#  the University nor the names of its contributors may be used to endorse
-#  or promote products derived from this software without specific prior
-#  written permission.
-#  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
-#  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
-#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
-#
-# @(#) $Header: 2002/10/09 15:34:11
-
-#
-# Various configurable paths (remember to edit Makefile.in, not Makefile)
-#
-
-# Top level hierarchy
-prefix	= @prefix@
-# Pathname of directory to install the binary
-BINDEST	= @prefix@/bin
-# Pathname of directory to install the man page
-MANDEST	= @prefix@/man
-
-BLANK	= # make a blank space.  DO NOT add anything to this line
-
-# The following will be redefined under Windows (see WIN32 lable below)
-CC	= @CC@
-CPP	= @CXX@
-LINK	= $(CPP)
-LINK_SHLIB = @SHLIB_LD@
-MKDEP	= ./conf/mkdep
-TCLSH	= @V_TCLSH@
-TCL2C	= @V_TCL2CPP@
-AR	= ar rc $(BLANK)
-
-RANLIB	= @V_RANLIB@
-INSTALL	= @INSTALL@
-LN	= ln
-TEST	= test
-RM	= rm -f
-MV      = mv
-PERL	= @PERL@
-
-# for diffusion
-#DIFF_INCLUDES = "./diffusion3/main ./diffusion3/lib ./diffusion3/nr ./diffusion3/ns"
-
-CCOPT	= @V_CCOPT@ 
-STATIC	= @V_STATIC@
-#LDFLAGS	= $(STATIC)
-LDFLAGS	= @LDFLAGS@ 
-LDOUT	= -o $(BLANK)
-
-DEFINE	= -DTCP_DELAY_BIND_ALL -DNO_TK @V_DEFINE@ @V_DEFINES@ @DEFS@ -DNS_DIFFUSION -DSMAC_NO_SYNC -DCPP_NAMESPACE=@CPP_NAMESPACE@ -DUSE_SINGLE_ADDRESS_SPACE -Drng_test
-
-INCLUDES = \
-	-I. @V_INCLUDE_X11@ \
-	-I. \
-	@V_INCLUDES@ \
-	-I./tcp -I./sctp -I./common -I./link -I./queue \
-	-I./adc -I./apps -I./mac -I./mobile -I./trace \
-	-I./routing -I./tools -I./classifier -I./mcast \
-	-I./diffusion3/lib/main -I./diffusion3/lib \
-	-I./diffusion3/lib/nr -I./diffusion3/ns \
-	-I./diffusion3/filter_core -I./asim/ -I./qs \
-	-I./diffserv -I./satellite \
-	-I./wpan
-
-
-LIB	= \
-	@V_LIBS@ \
-	@V_LIB_X11@ \
-	@V_LIB@ \
-	-lm @LIBS@
-#	-L@libdir@ \
-
-CFLAGS	+= $(CCOPT) $(DEFINE) 
-
-# Explicitly define compilation rules since SunOS 4's make doesn't like gcc.
-# Also, gcc does not remove the .o before forking 'as', which can be a
-# problem if you don't own the file but can write to the directory.
-.SUFFIXES: .cc	# $(.SUFFIXES)
-
-.cc.o:
-	@rm -f $@
-	$(CPP) -c $(CFLAGS) $(INCLUDES) -o $@ $*.cc
-
-.c.o:
-	@rm -f $@
-	$(CC) -c $(CFLAGS) $(INCLUDES) -o $@ $*.c
-
-
-GEN_DIR	= gen/
-LIB_DIR	= lib/
-NS	= ns
-NSLIB   = @NSLIB@
-NSX	= nsx
-NSE	= nse
-NSTK = nstk
-
-# To allow conf/makefile.win overwrite this macro
-# We will set these two macros to empty in conf/makefile.win since VC6.0
-# does not seem to support the STL in gcc 2.8 and up. 
-OBJ_STL = diffusion3/lib/nr/nr.o diffusion3/lib/dr.o \
-	diffusion3/filters/diffusion/one_phase_pull.o \
-	diffusion3/filters/diffusion/two_phase_pull.o \
-	diffusion3/lib/diffapp.o \
-	diffusion3/ns/diffagent.o diffusion3/ns/diffrtg.o \
-	diffusion3/ns/difftimer.o \
-	diffusion3/filter_core/filter_core.o \
-	diffusion3/filter_core/iolog.o \
-	diffusion3/filter_core/iostats.o \
-	diffusion3/lib/main/attrs.o \
-	diffusion3/lib/main/events.o \
-	diffusion3/lib/main/iodev.o \
-	diffusion3/lib/main/iohook.o \
-	diffusion3/lib/main/timers.o \
-	diffusion3/lib/main/message.o \
-	diffusion3/lib/main/tools.o \
-	diffusion3/apps/gear_examples/gear_common.o \
-	diffusion3/apps/gear_examples/gear_receiver.o \
-	diffusion3/apps/gear_examples/gear_sender.o \
-	diffusion3/apps/rmst_examples/rmst_sink.o \
-	diffusion3/apps/rmst_examples/rmst_source.o \
-	diffusion3/apps/ping/1pp_ping_sender.o \
-	diffusion3/apps/ping/1pp_ping_receiver.o \
-	diffusion3/apps/ping/2pp_ping_sender.o \
-	diffusion3/apps/ping/2pp_ping_receiver.o \
-	diffusion3/apps/ping/ping_common.o \
-	diffusion3/apps/ping/push_receiver.o \
-	diffusion3/apps/ping/push_sender.o \
-	diffusion3/filters/gear/gear_attr.o \
-	diffusion3/filters/gear/gear.o \
-	diffusion3/filters/gear/gear_tools.o \
-	diffusion3/filters/misc/log.o \
-	diffusion3/filters/misc/srcrt.o \
-	diffusion3/filters/misc/tag.o \
-	diffusion3/filters/rmst/rmst.o \
-	diffusion3/filters/rmst/rmst_filter.o \
-	delaybox/delaybox.o \
-	packmime/packmime_HTTP.o packmime/packmime_HTTP_rng.o \
-	packmime/packmime_OL.o packmime/packmime_OL_ranvar.o\
-	packmime/packmime_ranvar.o \
-	tmix/tmix.o tmix/tmix_delaybox.o
-
-NS_TCL_LIB_STL = tcl/lib/ns-diffusion.tcl \
-	tcl/delaybox/delaybox.tcl \
-	tcl/packmime/packmime.tcl \
-	tcl/tmix/tmix.tcl \
-	tcl/tmix/tmix_delaybox.tcl
-
-
-# WIN32: uncomment the following line to include specific make for VC++
-# !include <conf/makefile.win>
-
-OBJ_CC = \
-	tools/random.o tools/rng.o tools/ranvar.o common/misc.o common/timer-handler.o \
-	common/scheduler.o common/object.o common/packet.o \
-	common/ip.o routing/route.o common/connector.o common/ttl.o \
-	trace/trace.o trace/trace-ip.o \
-	classifier/classifier.o classifier/classifier-addr.o \
-	classifier/classifier-hash.o \
-	classifier/classifier-virtual.o \
-	classifier/classifier-mcast.o \
-	classifier/classifier-bst.o \
-	classifier/classifier-mpath.o mcast/replicator.o \
-	classifier/classifier-mac.o \
-	classifier/classifier-qs.o \
-	classifier/classifier-port.o src_rtg/classifier-sr.o \
-        src_rtg/sragent.o src_rtg/hdr_src.o adc/ump.o \
-	qs/qsagent.o qs/hdr_qs.o \
-	apps/app.o apps/telnet.o tcp/tcplib-telnet.o \
-	tools/trafgen.o trace/traffictrace.o tools/pareto.o \
-	tools/expoo.o tools/cbr_traffic.o \
-	adc/tbf.o adc/resv.o adc/sa.o tcp/saack.o \
-	tools/measuremod.o adc/estimator.o adc/adc.o adc/ms-adc.o \
-	adc/timewindow-est.o adc/acto-adc.o \
-        adc/pointsample-est.o adc/salink.o adc/actp-adc.o \
-	adc/hb-adc.o adc/expavg-est.o\
-	adc/param-adc.o adc/null-estimator.o \
-	adc/adaptive-receiver.o apps/vatrcvr.o adc/consrcvr.o \
-	common/agent.o common/message.o apps/udp.o \
-	common/session-rtp.o apps/rtp.o tcp/rtcp.o \
-	common/ivs.o \
-	common/messpass.o common/tp.o common/tpm.o apps/worm.o \
-	tcp/tcp.o tcp/tcp-sink.o tcp/tcp-reno.o \
-	tcp/tcp-newreno.o \
-	tcp/tcp-vegas.o tcp/tcp-rbp.o tcp/tcp-full.o tcp/rq.o \
-	baytcp/tcp-full-bay.o baytcp/ftpc.o baytcp/ftps.o \
-	tcp/scoreboard.o tcp/scoreboard-rq.o tcp/tcp-sack1.o tcp/tcp-fack.o \
-	tcp/linux/tcp_naivereno.o\
-	tcp/linux/src/tcp_cong.o\
-	tcp/linux/src/tcp_highspeed.o tcp/linux/src/tcp_bic.o tcp/linux/src/tcp_htcp.o tcp/linux/src/tcp_scalable.o tcp/linux/src/tcp_cubic.o\
-	tcp/linux/src/tcp_westwood.o tcp/linux/src/tcp_vegas.o tcp/linux/src/tcp_hybla.o\
-	tcp/linux/src/tcp_illinois.o tcp/linux/src/tcp_yeah.o \
-	tcp/linux/src/tcp_veno.o tcp/linux/src/tcp_compound.o tcp/linux/src/tcp_lp.o\
-	tcp/scoreboard1.o tcp/tcp-linux.o tcp/linux/ns-linux-util.o tcp/linux/ns-linux-c.o tcp/linux/ns-linux-param.o\
-	tcp/tcp-asym.o tcp/tcp-asym-sink.o tcp/tcp-fs.o \
-	tcp/tcp-asym-fs.o \
-	tcp/tcp-int.o tcp/chost.o tcp/tcp-session.o \
-	tcp/nilist.o \
-	sctp/sctp.o apps/sctp_app1.o\
-	sctp/sctp-timestamp.o sctp/sctp-hbAfterRto.o \
-	sctp/sctp-multipleFastRtx.o sctp/sctp-mfrHbAfterRto.o \
-	sctp/sctp-mfrTimestamp.o \
-	sctp/sctp-cmt.o \
-	sctp/sctpDebug.o \
-	tools/integrator.o tools/queue-monitor.o \
-	tools/flowmon.o tools/loss-monitor.o \
-	queue/queue.o queue/drop-tail.o \
-	adc/simple-intserv-sched.o queue/red.o \
-	queue/semantic-packetqueue.o queue/semantic-red.o \
-	tcp/ack-recons.o \
-	queue/sfq.o queue/fq.o queue/drr.o queue/srr.o queue/cbq.o \
-	queue/jobs.o queue/marker.o queue/demarker.o \
-	link/hackloss.o queue/errmodel.o queue/fec.o\
-	link/delay.o tcp/snoop.o \
-	gaf/gaf.o \
-	link/dynalink.o routing/rtProtoDV.o common/net-interface.o \
-	mcast/ctrMcast.o mcast/mcast_ctrl.o mcast/srm.o \
-	common/sessionhelper.o queue/delaymodel.o \
-	mcast/srm-ssm.o mcast/srm-topo.o \
-	routing/alloc-address.o routing/address.o \
-	$(LIB_DIR)int.Vec.o $(LIB_DIR)int.RVec.o \
-	$(LIB_DIR)dmalloc_support.o \
-	webcache/http.o webcache/tcp-simple.o webcache/pagepool.o \
-	webcache/inval-agent.o webcache/tcpapp.o webcache/http-aux.o \
-	webcache/mcache.o webcache/webtraf.o \
-	webcache/webserver.o \
-	webcache/logweb.o \
-	empweb/empweb.o \
-	empweb/empftp.o \
-	realaudio/realaudio.o \
-	mac/lanRouter.o classifier/filter.o \
-	common/pkt-counter.o \
-	common/Decapsulator.o common/Encapsulator.o \
-	common/encap.o \
-	mac/channel.o mac/mac.o mac/ll.o mac/mac-802_11.o \
-	mac/mac-802_11Ext.o \
-	mac/mac-802_3.o mac/mac-tdma.o mac/smac.o \
-	mobile/mip.o mobile/mip-reg.o mobile/gridkeeper.o \
-	mobile/propagation.o mobile/tworayground.o \
-	mobile/nakagami.o \
-	mobile/antenna.o mobile/omni-antenna.o \
-	mobile/shadowing.o mobile/shadowing-vis.o mobile/dumb-agent.o \
-	common/bi-connector.o common/node.o \
-	common/mobilenode.o \
-	mac/arp.o mobile/god.o mobile/dem.o \
-	mobile/topography.o mobile/modulation.o \
-	queue/priqueue.o queue/dsr-priqueue.o \
-	mac/phy.o mac/wired-phy.o mac/wireless-phy.o \
-	mac/wireless-phyExt.o \
-	mac/mac-timers.o trace/cmu-trace.o mac/varp.o \
-	mac/mac-simple.o \
-	satellite/sat-hdlc.o \
-	dsdv/dsdv.o dsdv/rtable.o queue/rtqueue.o \
-	routing/rttable.o \
-	imep/imep.o imep/dest_queue.o imep/imep_api.o \
-	imep/imep_rt.o imep/rxmit_queue.o imep/imep_timers.o \
-	imep/imep_util.o imep/imep_io.o \
-	tora/tora.o tora/tora_api.o tora/tora_dest.o \
-	tora/tora_io.o tora/tora_logs.o tora/tora_neighbor.o \
-	dsr/dsragent.o dsr/hdr_sr.o dsr/mobicache.o dsr/path.o \
-	dsr/requesttable.o dsr/routecache.o dsr/add_sr.o \
-	dsr/dsr_proto.o dsr/flowstruct.o dsr/linkcache.o \
-	dsr/simplecache.o dsr/sr_forwarder.o \
-	aodv/aodv_logs.o aodv/aodv.o \
-	aodv/aodv_rtable.o aodv/aodv_rqueue.o \
-	aomdv/aomdv_logs.o aomdv/aomdv.o \
-	aomdv/aomdv_rtable.o aomdv/aomdv_rqueue.o \
-	common/ns-process.o \
-	satellite/satgeometry.o satellite/sathandoff.o \
-	satellite/satlink.o satellite/satnode.o \
-	satellite/satposition.o satellite/satroute.o \
-	satellite/sattrace.o \
-	rap/raplist.o rap/rap.o rap/media-app.o rap/utilities.o \
-	common/fsm.o tcp/tcp-abs.o \
-	diffusion/diffusion.o diffusion/diff_rate.o diffusion/diff_prob.o \
-	diffusion/diff_sink.o diffusion/flooding.o diffusion/omni_mcast.o \
-	diffusion/hash_table.o diffusion/routing_table.o diffusion/iflist.o \
-	tcp/tfrc.o tcp/tfrc-sink.o mobile/energy-model.o apps/ping.o tcp/tcp-rfc793edu.o \
-	queue/rio.o queue/semantic-rio.o tcp/tcp-sack-rh.o tcp/scoreboard-rh.o \
-	plm/loss-monitor-plm.o plm/cbr-traffic-PP.o \
-	linkstate/hdr-ls.o \
-	mpls/classifier-addr-mpls.o mpls/ldp.o mpls/mpls-module.o \
-	routing/rtmodule.o classifier/classifier-hier.o \
-	routing/addr-params.o \
-         nix/hdr_nv.o nix/classifier-nix.o \
-         nix/nixnode.o \
-         routealgo/rnode.o \
-         routealgo/bfs.o \
-         routealgo/rbitmap.o \
-         routealgo/rlookup.o \
-         routealgo/routealgo.o \
-         nix/nixvec.o \
-	nix/nixroute.o \
-	diffserv/dsred.o diffserv/dsredq.o \
-	diffserv/dsEdge.o diffserv/dsCore.o \
-	diffserv/dsPolicy.o diffserv/ew.o diffserv/dewp.o \
-	queue/red-pd.o queue/pi.o queue/vq.o queue/rem.o \
-	queue/gk.o \
-	pushback/rate-limit.o pushback/rate-limit-strategy.o \
-	pushback/ident-tree.o pushback/agg-spec.o \
-	pushback/logging-data-struct.o \
-	pushback/rate-estimator.o \
-	pushback/pushback-queue.o pushback/pushback.o \
-	common/parentnode.o trace/basetrace.o \
-	common/simulator.o asim/asim.o \
-	common/scheduler-map.o common/splay-scheduler.o \
-	linkstate/ls.o linkstate/rtProtoLS.o \
-	pgm/classifier-pgm.o pgm/pgm-agent.o pgm/pgm-sender.o \
-	pgm/pgm-receiver.o mcast/rcvbuf.o \
-	mcast/classifier-lms.o mcast/lms-agent.o mcast/lms-receiver.o \
-	mcast/lms-sender.o \
-	queue/delayer.o \
-	xcp/xcpq.o xcp/xcp.o xcp/xcp-end-sys.o \
-	wpan/p802_15_4csmaca.o wpan/p802_15_4fail.o \
-	wpan/p802_15_4hlist.o wpan/p802_15_4mac.o \
-	wpan/p802_15_4nam.o wpan/p802_15_4phy.o \
-	wpan/p802_15_4sscs.o wpan/p802_15_4timer.o \
-	wpan/p802_15_4trace.o wpan/p802_15_4transac.o \
-	apps/pbc.o \
-	@V_STLOBJ@
-
-
-# don't allow comments to follow continuation lines
-
-#  mac-csma.o mac-multihop.o\
-#	sensor-nets/landmark.o mac-simple-wireless.o \
-#	sensor-nets/tags.o sensor-nets/sensor-query.o \
-#	sensor-nets/flood-agent.o \
-
-# what was here before is now in emulate/
-OBJ_C =
-
-OBJ_COMPAT = $(OBJ_GETOPT) common/win32.o
-#XXX compat/win32x.o compat/tkConsole.o
-
-OBJ_EMULATE_CC = \
-	emulate/net-ip.o \
-	emulate/net.o \
-	emulate/tap.o \
-	emulate/ether.o \
-	emulate/internet.o \
-	emulate/ping_responder.o \
-	emulate/arp.o \
-	emulate/icmp.o \
-	emulate/net-pcap.o \
-	emulate/nat.o  \
-	emulate/iptap.o \
-	emulate/tcptap.o
-
-OBJ_EMULATE_C = \
-	emulate/inet.o
-
-OBJ_GEN = $(GEN_DIR)version.o $(GEN_DIR)ns_tcl.o $(GEN_DIR)ptypes.o
-
-SRC =	$(OBJ_C:.o=.c) $(OBJ_CC:.o=.cc) \
-	$(OBJ_EMULATE_C:.o=.c) $(OBJ_EMULATE_CC:.o=.cc) \
-	common/tclAppInit.cc common/tkAppInit.cc 
-
-OBJ =	$(OBJ_C) $(OBJ_CC) $(OBJ_GEN) $(OBJ_COMPAT)
-
-CLEANFILES = ns nse nsx ns.dyn $(OBJ) $(OBJ_EMULATE_CC) \
-	$(OBJ_EMULATE_C) common/tclAppInit.o \
-	common/tkAppInit.o nstk \
-	$(GEN_DIR)* $(NS).core core core.$(NS) core.$(NSX) core.$(NSE) \
-	common/ptypes2tcl common/ptypes2tcl.o 
-
-SUBDIRS=\
-	indep-utils/cmu-scen-gen/setdest \
-	indep-utils/webtrace-conv/dec \
-	indep-utils/webtrace-conv/epa \
-	indep-utils/webtrace-conv/nlanr \
-	indep-utils/webtrace-conv/ucb
-
-BUILD_NSE = @build_nse@
-
-all: $(NS) $(BUILD_NSE) $(NSTK) all-recursive Makefile
-
-
-all-recursive:
-	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) all; ) done
-
-
-
-
-ifeq ($(NSLIB),libns.dll)
-
-# This is for cygwin
-
-NS_CPPFLAGS = -DNSLIBNAME=\"$(NSLIB)\" 
-NS_LIBS =  @DL_LIBS@
-
-$(NSLIB): $(OBJ) common/tclAppInit.o 
-	$(LINK) -shared $(LDFLAGS) \
-		$(LDOUT)$@  \
-		-Wl,--export-all-symbols \
-		-Wl,--enable-auto-import \
-		-Wl,--out-implib=$@.a \
-		-Wl,--whole-archive $^ \
-		-Wl,--no-whole-archive @V_IMPORT_LIBS@ 
-
-$(NS): $(NSLIB) common/main-modular.cc 
-	$(LINK) $(NS_CPPFLAGS) $(LDFLAGS) $(LDOUT)$@ common/main-modular.cc $(NS_LIBS)
-
-else 
-
-# default for all systems but cygwin
-
-$(NS): $(OBJ) common/tclAppInit.o common/main-monolithic.o
-	$(LINK) $(LDFLAGS) $(LDOUT)$@ $^ $(LIB)
-
-endif 
-
-
-
-Makefile: Makefile.in
-	@echo "Makefile.in is newer than Makefile."
-	@echo "You need to re-run configure."
-	false
-
-$(NSE): $(OBJ) common/tclAppInit.o common/main-monolithic.o $(OBJ_EMULATE_CC) $(OBJ_EMULATE_C)
-	$(LINK) $(LDFLAGS) $(LDOUT)$@ $^ $(LIB) 
-
-$(NSTK): $(OBJ) common/tkAppInit.o 
-	$(LINK) $(LDFLAGS) $(LDOUT)$@ $^ $(LIB)
-
-ns.dyn: $(OBJ) common/tclAppInit.o common/main-monolithic.o 
-	$(LINK) $(LDFLAGS) -o $@ $^ $(LIB)
-
-PURIFY	= purify -cache-dir=/tmp
-ns-pure: $(OBJ) common/tclAppInit.o common/main-monolithic.o 
-	$(PURIFY) $(LINK) $(LDFLAGS) -o $@ $^ $(LIB)
-
-NS_TCL_LIB = \
-	tcl/lib/ns-compat.tcl \
-	tcl/lib/ns-default.tcl \
-	tcl/lib/ns-errmodel.tcl \
-	tcl/lib/ns-lib.tcl \
-	tcl/lib/ns-link.tcl \
-	tcl/lib/ns-mobilenode.tcl \
-	tcl/lib/ns-sat.tcl \
-	tcl/lib/ns-cmutrace.tcl \
-	tcl/lib/ns-node.tcl \
-	tcl/lib/ns-rtmodule.tcl \
-	tcl/lib/ns-hiernode.tcl \
-	tcl/lib/ns-packet.tcl \
-	tcl/lib/ns-queue.tcl \
-	tcl/lib/ns-source.tcl \
-	tcl/lib/ns-nam.tcl \
-	tcl/lib/ns-trace.tcl \
-	tcl/lib/ns-agent.tcl \
-	tcl/lib/ns-random.tcl \
-	tcl/lib/ns-namsupp.tcl \
-	tcl/lib/ns-address.tcl \
-	tcl/lib/ns-intserv.tcl \
-	tcl/lib/ns-autoconf.tcl \
-	tcl/rtp/session-rtp.tcl \
-	tcl/lib/ns-mip.tcl \
-	tcl/rtglib/dynamics.tcl \
-	tcl/rtglib/route-proto.tcl \
-	tcl/rtglib/algo-route-proto.tcl \
-	tcl/rtglib/ns-rtProtoLS.tcl \
-        tcl/interface/ns-iface.tcl \
-	tcl/mcast/BST.tcl \
-        tcl/mcast/ns-mcast.tcl \
-        tcl/mcast/McastProto.tcl \
-        tcl/mcast/DM.tcl \
-	tcl/mcast/srm.tcl \
-	tcl/mcast/srm-adaptive.tcl \
-	tcl/mcast/srm-ssm.tcl \
-	tcl/mcast/timer.tcl \
-	tcl/mcast/McastMonitor.tcl \
-	tcl/mobility/dsdv.tcl \
-	tcl/mobility/dsr.tcl \
-        tcl/ctr-mcast/CtrMcast.tcl \
-        tcl/ctr-mcast/CtrMcastComp.tcl \
-        tcl/ctr-mcast/CtrRPComp.tcl \
-	tcl/rlm/rlm.tcl \
-	tcl/rlm/rlm-ns.tcl \
-	tcl/session/session.tcl \
-	tcl/lib/ns-route.tcl \
-	tcl/emulate/ns-emulate.tcl \
-	tcl/lan/vlan.tcl \
-	tcl/lan/abslan.tcl \
-	tcl/lan/ns-ll.tcl \
-	tcl/lan/ns-mac.tcl \
-	tcl/webcache/http-agent.tcl \
-	tcl/webcache/http-server.tcl \
-	tcl/webcache/http-cache.tcl \
-	tcl/webcache/http-mcache.tcl \
-	tcl/webcache/webtraf.tcl \
-	tcl/webcache/empweb.tcl \
-	tcl/webcache/empftp.tcl \
-	tcl/plm/plm.tcl \
-	tcl/plm/plm-ns.tcl \
-	tcl/plm/plm-topo.tcl \
-	tcl/mpls/ns-mpls-classifier.tcl \
-	tcl/mpls/ns-mpls-ldpagent.tcl \
-	tcl/mpls/ns-mpls-node.tcl \
-	tcl/mpls/ns-mpls-simulator.tcl \
-	tcl/lib/ns-pushback.tcl \
-	tcl/lib/ns-srcrt.tcl \
-	tcl/mcast/ns-lms.tcl \
-	tcl/lib/ns-qsnode.tcl \
-	@V_NS_TCL_LIB_STL@
-
-$(GEN_DIR)ns_tcl.cc: $(NS_TCL_LIB)
-	$(TCLSH) bin/tcl-expand.tcl tcl/lib/ns-lib.tcl @V_NS_TCL_LIB_STL@ | $(TCL2C) et_ns_lib > $@
-
-$(GEN_DIR)version.c: VERSION
-	$(RM) $@
-	$(TCLSH) bin/string2c.tcl version_string < VERSION > $@
-
-$(GEN_DIR)ptypes.cc: common/ptypes2tcl common/packet.h
-	./common/ptypes2tcl > $@
-
-common/ptypes2tcl: common/ptypes2tcl.o
-	$(LINK) $(LDFLAGS) $(LDOUT)$@ common/ptypes2tcl.o
-
-common/ptypes2tcl.o: common/ptypes2tcl.cc common/packet.h
-
-dirs:
-	for d in $(DESTDIR)$(MANDEST)/man1; do \
-		if [ ! -d $$d ]; then \
-			mkdir -p $$d ;\
-		fi;\
-	done
-
-
-install: dirs force install-ns install-man
-
-install-ns: force
-	$(INSTALL) -m 755 ns $(DESTDIR)$(BINDEST)
-
-install-man: force
-	$(INSTALL) -m 644 ns.1 $(DESTDIR)$(MANDEST)/man1
-
-install-recursive: force
-	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) install; ) done
-
-clean:
-	$(RM) $(CLEANFILES)
-
-AUTOCONF_GEN = tcl/lib/ns-autoconf.tcl
-distclean: distclean-recursive
-	$(RM) $(CLEANFILES) Makefile config.cache config.log config.status \
-	    autoconf.h gnuc.h os-proto.h $(AUTOCONF_GEN); \
-	$(MV) .configure .configure- ;\
-	echo "Moved .configure to .configure-"
-
-distclean-recursive:
-	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) clean; $(RM) Makefile; ) done
-
-tags:	force
-	ctags -wtd *.cc *.h webcache/*.cc webcache/*.h dsdv/*.cc dsdv/*.h \
-	dsr/*.cc dsr/*.h webcache/*.cc webcache/*.h lib/*.cc lib/*.h \
-	../Tcl/*.cc ../Tcl/*.h 
-
-TAGS:	force
-	etags *.cc *.h webcache/*.cc webcache/*.h dsdv/*.cc dsdv/*.h \
-	dsr/*.cc dsr/*.h webcache/*.cc webcache/*.h lib/*.cc lib/*.h \
-	../Tcl/*.cc ../Tcl/*.h
-
-tcl/lib/TAGS:	force
-	( \
-		cd tcl/lib; \
-		$(TCLSH) ../../bin/tcl-expand.tcl ns-lib.tcl | grep '^### tcl-expand.tcl: begin' | awk '{print $$5}' >.tcl_files; \
-		etags --lang=none -r '/^[ \t]*proc[ \t]+\([^ \t]+\)/\1/' `cat .tcl_files`; \
-		etags --append --lang=none -r '/^\([A-Z][^ \t]+\)[ \t]+\(instproc\|proc\)[ \t]+\([^ \t]+\)[ \t]+/\1::\3/' `cat .tcl_files`; \
-	)
-
-depend: $(SRC)
-	$(MKDEP) $(CFLAGS) $(INCLUDES) -- $(SRC) 2>&1 > /dev/null
-
-srctar:
-	@cwd=`pwd` ; dir=`basename $$cwd` ; \
-	    name=ns-`cat VERSION | tr A-Z a-z` ; \
-	    tar=ns-src-`cat VERSION`.tar.gz ; \
-	    list="" ; \
-	    for i in `cat FILES` ; do list="$$list $$name/$$i" ; done; \
-	    echo \
-	    "(rm -f $$tar; cd .. ; ln -s $$dir $$name)" ; \
-	     (rm -f $$tar; cd .. ; ln -s $$dir $$name) ; \
-	    echo \
-	    "(cd .. ; tar cfhz $$tar [lots of files])" ; \
-	     (cd .. ; tar cfhz - $$list) > $$tar ; \
-	    echo \
-	    "rm ../$$name; chmod 444 $$tar" ;  \
-	     rm ../$$name; chmod 444 $$tar
-
-force:
-
-test:	force
-	./validate
-
-# Create makefile.vc for Win32 development by replacing:
-# "# !include ..." 	-> 	"!include ..."
-makefile.vc:	Makefile.in
-	$(PERL) bin/gen-vcmake.pl < Makefile.in > makefile.vc
-#	$(PERL) -pe 's/^# (\!include)/\!include/o' < Makefile.in > makefile.vc
+#  Copyright (c) 1994, 1995, 1996
+# 	The Regents of the University of California.  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that: (1) source code distributions
+#  retain the above copyright notice and this paragraph in its entirety, (2)
+#  distributions including binary code include the above copyright notice and
+#  this paragraph in its entirety in the documentation or other materials
+#  provided with the distribution, and (3) all advertising materials mentioning
+#  features or use of this software display the following acknowledgement:
+#  ``This product includes software developed by the University of California,
+#  Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
+#  the University nor the names of its contributors may be used to endorse
+#  or promote products derived from this software without specific prior
+#  written permission.
+#  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
+#  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+#
+# @(#) $Header: 2002/10/09 15:34:11
+
+#
+# Various configurable paths (remember to edit Makefile.in, not Makefile)
+#
+
+# Top level hierarchy
+prefix	= @prefix@
+# Pathname of directory to install the binary
+BINDEST	= @prefix@/bin
+# Pathname of directory to install the man page
+MANDEST	= @prefix@/man
+
+BLANK	= # make a blank space.  DO NOT add anything to this line
+
+# The following will be redefined under Windows (see WIN32 lable below)
+CC	= @CC@
+CPP	= @CXX@
+LINK	= $(CPP)
+LINK_SHLIB = @SHLIB_LD@
+MKDEP	= ./conf/mkdep
+TCLSH	= @V_TCLSH@
+TCL2C	= @V_TCL2CPP@
+AR	= ar rc $(BLANK)
+
+RANLIB	= @V_RANLIB@
+INSTALL	= @INSTALL@
+LN	= ln
+TEST	= test
+RM	= rm -f
+MV      = mv
+PERL	= @PERL@
+
+# for diffusion
+#DIFF_INCLUDES = "./diffusion3/main ./diffusion3/lib ./diffusion3/nr ./diffusion3/ns"
+
+CCOPT	= @V_CCOPT@ 
+STATIC	= @V_STATIC@
+#LDFLAGS	= $(STATIC)
+LDFLAGS	= @LDFLAGS@ 
+LDOUT	= -o $(BLANK)
+
+DEFINE	= -DTCP_DELAY_BIND_ALL -DNO_TK @V_DEFINE@ @V_DEFINES@ @DEFS@ -DNS_DIFFUSION -DSMAC_NO_SYNC -DCPP_NAMESPACE=@CPP_NAMESPACE@ -DUSE_SINGLE_ADDRESS_SPACE -Drng_test
+
+INCLUDES = \
+	-I. @V_INCLUDE_X11@ \
+	-I. \
+	@V_INCLUDES@ \
+	-I./tcp -I./sctp -I./common -I./link -I./queue \
+	-I./adc -I./apps -I./mac -I./mobile -I./trace \
+	-I./routing -I./tools -I./classifier -I./mcast \
+	-I./diffusion3/lib/main -I./diffusion3/lib \
+	-I./diffusion3/lib/nr -I./diffusion3/ns \
+	-I./diffusion3/filter_core -I./asim/ -I./qs \
+	-I./diffserv -I./satellite \
+	-I./wpan
+
+
+LIB	= \
+	@V_LIBS@ \
+	@V_LIB_X11@ \
+	@V_LIB@ \
+	-lm @LIBS@
+#	-L@libdir@ \
+
+CFLAGS	+= $(CCOPT) $(DEFINE) 
+
+# Explicitly define compilation rules since SunOS 4's make doesn't like gcc.
+# Also, gcc does not remove the .o before forking 'as', which can be a
+# problem if you don't own the file but can write to the directory.
+.SUFFIXES: .cc	# $(.SUFFIXES)
+
+.cc.o:
+	@rm -f $@
+	$(CPP) -c $(CFLAGS) $(INCLUDES) -o $@ $*.cc
+
+.c.o:
+	@rm -f $@
+	$(CC) -c $(CFLAGS) $(INCLUDES) -o $@ $*.c
+
+
+GEN_DIR	= gen/
+LIB_DIR	= lib/
+NS	= ns
+NSLIB   = @NSLIB@
+NSX	= nsx
+NSE	= nse
+NSTK = nstk
+
+# To allow conf/makefile.win overwrite this macro
+# We will set these two macros to empty in conf/makefile.win since VC6.0
+# does not seem to support the STL in gcc 2.8 and up. 
+OBJ_STL = diffusion3/lib/nr/nr.o diffusion3/lib/dr.o \
+	diffusion3/filters/diffusion/one_phase_pull.o \
+	diffusion3/filters/diffusion/two_phase_pull.o \
+	diffusion3/lib/diffapp.o \
+	diffusion3/ns/diffagent.o diffusion3/ns/diffrtg.o \
+	diffusion3/ns/difftimer.o \
+	diffusion3/filter_core/filter_core.o \
+	diffusion3/filter_core/iolog.o \
+	diffusion3/filter_core/iostats.o \
+	diffusion3/lib/main/attrs.o \
+	diffusion3/lib/main/events.o \
+	diffusion3/lib/main/iodev.o \
+	diffusion3/lib/main/iohook.o \
+	diffusion3/lib/main/timers.o \
+	diffusion3/lib/main/message.o \
+	diffusion3/lib/main/tools.o \
+	diffusion3/apps/gear_examples/gear_common.o \
+	diffusion3/apps/gear_examples/gear_receiver.o \
+	diffusion3/apps/gear_examples/gear_sender.o \
+	diffusion3/apps/rmst_examples/rmst_sink.o \
+	diffusion3/apps/rmst_examples/rmst_source.o \
+	diffusion3/apps/ping/1pp_ping_sender.o \
+	diffusion3/apps/ping/1pp_ping_receiver.o \
+	diffusion3/apps/ping/2pp_ping_sender.o \
+	diffusion3/apps/ping/2pp_ping_receiver.o \
+	diffusion3/apps/ping/ping_common.o \
+	diffusion3/apps/ping/push_receiver.o \
+	diffusion3/apps/ping/push_sender.o \
+	diffusion3/filters/gear/gear_attr.o \
+	diffusion3/filters/gear/gear.o \
+	diffusion3/filters/gear/gear_tools.o \
+	diffusion3/filters/misc/log.o \
+	diffusion3/filters/misc/srcrt.o \
+	diffusion3/filters/misc/tag.o \
+	diffusion3/filters/rmst/rmst.o \
+	diffusion3/filters/rmst/rmst_filter.o \
+	delaybox/delaybox.o \
+	packmime/packmime_HTTP.o packmime/packmime_HTTP_rng.o \
+	packmime/packmime_OL.o packmime/packmime_OL_ranvar.o\
+	packmime/packmime_ranvar.o \
+	tmix/tmix.o tmix/tmix_delaybox.o
+
+NS_TCL_LIB_STL = tcl/lib/ns-diffusion.tcl \
+	tcl/delaybox/delaybox.tcl \
+	tcl/packmime/packmime.tcl \
+	tcl/tmix/tmix.tcl \
+	tcl/tmix/tmix_delaybox.tcl
+
+
+# WIN32: uncomment the following line to include specific make for VC++
+# !include <conf/makefile.win>
+
+OBJ_CC = \
+	tools/random.o tools/rng.o tools/ranvar.o common/misc.o common/timer-handler.o \
+	common/scheduler.o common/object.o common/packet.o \
+	common/ip.o routing/route.o common/connector.o common/ttl.o \
+	trace/trace.o trace/trace-ip.o \
+	classifier/classifier.o classifier/classifier-addr.o \
+	classifier/classifier-hash.o \
+	classifier/classifier-virtual.o \
+	classifier/classifier-mcast.o \
+	classifier/classifier-bst.o \
+	classifier/classifier-mpath.o mcast/replicator.o \
+	classifier/classifier-mac.o \
+	classifier/classifier-qs.o \
+	classifier/classifier-port.o src_rtg/classifier-sr.o \
+        src_rtg/sragent.o src_rtg/hdr_src.o adc/ump.o \
+	qs/qsagent.o qs/hdr_qs.o \
+	apps/app.o apps/telnet.o tcp/tcplib-telnet.o \
+	tools/trafgen.o trace/traffictrace.o tools/pareto.o \
+	tools/expoo.o tools/cbr_traffic.o \
+	adc/tbf.o adc/resv.o adc/sa.o tcp/saack.o \
+	tools/measuremod.o adc/estimator.o adc/adc.o adc/ms-adc.o \
+	adc/timewindow-est.o adc/acto-adc.o \
+        adc/pointsample-est.o adc/salink.o adc/actp-adc.o \
+	adc/hb-adc.o adc/expavg-est.o\
+	adc/param-adc.o adc/null-estimator.o \
+	adc/adaptive-receiver.o apps/vatrcvr.o adc/consrcvr.o \
+	common/agent.o common/message.o apps/udp.o \
+	common/session-rtp.o apps/rtp.o tcp/rtcp.o \
+	common/ivs.o \
+	common/messpass.o common/tp.o common/tpm.o apps/worm.o \
+	tcp/tcp.o tcp/tcp-sink.o tcp/tcp-reno.o \
+	tcp/tcp-newreno.o \
+	tcp/tcp-vegas.o tcp/tcp-rbp.o tcp/tcp-full.o tcp/rq.o \
+	baytcp/tcp-full-bay.o baytcp/ftpc.o baytcp/ftps.o \
+	tcp/scoreboard.o tcp/scoreboard-rq.o tcp/tcp-sack1.o tcp/tcp-fack.o \
+	tcp/linux/tcp_naivereno.o\
+	tcp/linux/src/tcp_cong.o\
+	tcp/linux/src/tcp_highspeed.o tcp/linux/src/tcp_bic.o tcp/linux/src/tcp_htcp.o tcp/linux/src/tcp_scalable.o tcp/linux/src/tcp_cubic.o\
+	tcp/linux/src/tcp_westwood.o tcp/linux/src/tcp_vegas.o tcp/linux/src/tcp_hybla.o\
+	tcp/linux/src/tcp_illinois.o tcp/linux/src/tcp_yeah.o \
+	tcp/linux/src/tcp_veno.o tcp/linux/src/tcp_compound.o tcp/linux/src/tcp_lp.o\
+	tcp/scoreboard1.o tcp/tcp-linux.o tcp/linux/ns-linux-util.o tcp/linux/ns-linux-c.o tcp/linux/ns-linux-param.o\
+	tcp/tcp-asym.o tcp/tcp-asym-sink.o tcp/tcp-fs.o \
+	tcp/tcp-asym-fs.o \
+	tcp/tcp-int.o tcp/chost.o tcp/tcp-session.o \
+	tcp/nilist.o \
+	sctp/sctp.o apps/sctp_app1.o\
+	sctp/sctp-timestamp.o sctp/sctp-hbAfterRto.o \
+	sctp/sctp-multipleFastRtx.o sctp/sctp-mfrHbAfterRto.o \
+	sctp/sctp-mfrTimestamp.o \
+	sctp/sctp-cmt.o \
+	sctp/sctpDebug.o \
+	tools/integrator.o tools/queue-monitor.o \
+	tools/flowmon.o tools/loss-monitor.o \
+	queue/queue.o queue/drop-tail.o \
+	adc/simple-intserv-sched.o queue/red.o \
+	queue/semantic-packetqueue.o queue/semantic-red.o \
+	tcp/ack-recons.o \
+	queue/sfq.o queue/fq.o queue/drr.o queue/srr.o queue/cbq.o \
+	queue/jobs.o queue/marker.o queue/demarker.o \
+	link/hackloss.o queue/errmodel.o queue/fec.o\
+	link/delay.o tcp/snoop.o \
+	gaf/gaf.o \
+	link/dynalink.o routing/rtProtoDV.o common/net-interface.o \
+	mcast/ctrMcast.o mcast/mcast_ctrl.o mcast/srm.o \
+	common/sessionhelper.o queue/delaymodel.o \
+	mcast/srm-ssm.o mcast/srm-topo.o \
+	routing/alloc-address.o routing/address.o \
+	$(LIB_DIR)int.Vec.o $(LIB_DIR)int.RVec.o \
+	$(LIB_DIR)dmalloc_support.o \
+	webcache/http.o webcache/tcp-simple.o webcache/pagepool.o \
+	webcache/inval-agent.o webcache/tcpapp.o webcache/http-aux.o \
+	webcache/mcache.o webcache/webtraf.o \
+	webcache/webserver.o \
+	webcache/logweb.o \
+	empweb/empweb.o \
+	empweb/empftp.o \
+	realaudio/realaudio.o \
+	mac/lanRouter.o classifier/filter.o \
+	common/pkt-counter.o \
+	common/Decapsulator.o common/Encapsulator.o \
+	common/encap.o \
+	mac/channel.o mac/mac.o mac/ll.o mac/mac-802_11.o \
+	mac/mac-802_11Ext.o \
+	mac/mac-802_3.o mac/mac-tdma.o mac/smac.o \
+	mobile/mip.o mobile/mip-reg.o mobile/gridkeeper.o \
+	mobile/propagation.o mobile/tworayground.o \
+	mobile/nakagami.o \
+	mobile/antenna.o mobile/omni-antenna.o \
+	mobile/shadowing.o mobile/shadowing-vis.o mobile/dumb-agent.o \
+	common/bi-connector.o common/node.o \
+	common/mobilenode.o \
+	mac/arp.o mobile/god.o mobile/dem.o \
+	mobile/topography.o mobile/modulation.o \
+	queue/priqueue.o queue/dsr-priqueue.o \
+	mac/phy.o mac/wired-phy.o mac/wireless-phy.o \
+	mac/wireless-phyExt.o \
+	mac/mac-timers.o trace/cmu-trace.o mac/varp.o \
+	mac/mac-simple.o \
+	satellite/sat-hdlc.o \
+	dsdv/dsdv.o dsdv/rtable.o queue/rtqueue.o \
+	routing/rttable.o \
+	imep/imep.o imep/dest_queue.o imep/imep_api.o \
+	imep/imep_rt.o imep/rxmit_queue.o imep/imep_timers.o \
+	imep/imep_util.o imep/imep_io.o \
+	tora/tora.o tora/tora_api.o tora/tora_dest.o \
+	tora/tora_io.o tora/tora_logs.o tora/tora_neighbor.o \
+	dsr/dsragent.o dsr/hdr_sr.o dsr/mobicache.o dsr/path.o \
+	dsr/requesttable.o dsr/routecache.o dsr/add_sr.o \
+	dsr/dsr_proto.o dsr/flowstruct.o dsr/linkcache.o \
+	dsr/simplecache.o dsr/sr_forwarder.o \
+	aodv/aodv_logs.o aodv/aodv.o \
+	aodv/aodv_rtable.o aodv/aodv_rqueue.o \
+	aomdv/aomdv_logs.o aomdv/aomdv.o \
+	aomdv/aomdv_rtable.o aomdv/aomdv_rqueue.o \
+	common/ns-process.o \
+	satellite/satgeometry.o satellite/sathandoff.o \
+	satellite/satlink.o satellite/satnode.o \
+	satellite/satposition.o satellite/satroute.o \
+	satellite/sattrace.o \
+	rap/raplist.o rap/rap.o rap/media-app.o rap/utilities.o \
+	common/fsm.o tcp/tcp-abs.o \
+	diffusion/diffusion.o diffusion/diff_rate.o diffusion/diff_prob.o \
+	diffusion/diff_sink.o diffusion/flooding.o diffusion/omni_mcast.o \
+	diffusion/hash_table.o diffusion/routing_table.o diffusion/iflist.o \
+	tcp/tfrc.o tcp/tfrc-sink.o mobile/energy-model.o apps/ping.o tcp/tcp-rfc793edu.o \
+	queue/rio.o queue/semantic-rio.o tcp/tcp-sack-rh.o tcp/scoreboard-rh.o \
+	plm/loss-monitor-plm.o plm/cbr-traffic-PP.o \
+	linkstate/hdr-ls.o \
+	mpls/classifier-addr-mpls.o mpls/ldp.o mpls/mpls-module.o \
+	routing/rtmodule.o classifier/classifier-hier.o \
+	routing/addr-params.o \
+         nix/hdr_nv.o nix/classifier-nix.o \
+         nix/nixnode.o \
+         routealgo/rnode.o \
+         routealgo/bfs.o \
+         routealgo/rbitmap.o \
+         routealgo/rlookup.o \
+         routealgo/routealgo.o \
+         nix/nixvec.o \
+	nix/nixroute.o \
+	diffserv/dsred.o diffserv/dsredq.o \
+	diffserv/dsEdge.o diffserv/dsCore.o \
+	diffserv/dsPolicy.o diffserv/ew.o diffserv/dewp.o \
+	queue/red-pd.o queue/pi.o queue/vq.o queue/rem.o \
+	queue/gk.o \
+	pushback/rate-limit.o pushback/rate-limit-strategy.o \
+	pushback/ident-tree.o pushback/agg-spec.o \
+	pushback/logging-data-struct.o \
+	pushback/rate-estimator.o \
+	pushback/pushback-queue.o pushback/pushback.o \
+	common/parentnode.o trace/basetrace.o \
+	common/simulator.o asim/asim.o \
+	common/scheduler-map.o common/splay-scheduler.o \
+	linkstate/ls.o linkstate/rtProtoLS.o \
+	pgm/classifier-pgm.o pgm/pgm-agent.o pgm/pgm-sender.o \
+	pgm/pgm-receiver.o mcast/rcvbuf.o \
+	mcast/classifier-lms.o mcast/lms-agent.o mcast/lms-receiver.o \
+	mcast/lms-sender.o \
+	queue/delayer.o \
+	xcp/xcpq.o xcp/xcp.o xcp/xcp-end-sys.o \
+	wpan/p802_15_4csmaca.o wpan/p802_15_4fail.o \
+	wpan/p802_15_4hlist.o wpan/p802_15_4mac.o \
+	wpan/p802_15_4nam.o wpan/p802_15_4phy.o \
+	wpan/p802_15_4sscs.o wpan/p802_15_4timer.o \
+	wpan/p802_15_4trace.o wpan/p802_15_4transac.o \
+	apps/pbc.o \
+	fsr/fsr.o fsr/fsr_rtable.o fsr/fsr_ttable.o \
+	@V_STLOBJ@
+
+
+# don't allow comments to follow continuation lines
+
+#  mac-csma.o mac-multihop.o\
+#	sensor-nets/landmark.o mac-simple-wireless.o \
+#	sensor-nets/tags.o sensor-nets/sensor-query.o \
+#	sensor-nets/flood-agent.o \
+
+# what was here before is now in emulate/
+OBJ_C =
+
+OBJ_COMPAT = $(OBJ_GETOPT) common/win32.o
+#XXX compat/win32x.o compat/tkConsole.o
+
+OBJ_EMULATE_CC = \
+	emulate/net-ip.o \
+	emulate/net.o \
+	emulate/tap.o \
+	emulate/ether.o \
+	emulate/internet.o \
+	emulate/ping_responder.o \
+	emulate/arp.o \
+	emulate/icmp.o \
+	emulate/net-pcap.o \
+	emulate/nat.o  \
+	emulate/iptap.o \
+	emulate/tcptap.o
+
+OBJ_EMULATE_C = \
+	emulate/inet.o
+
+OBJ_GEN = $(GEN_DIR)version.o $(GEN_DIR)ns_tcl.o $(GEN_DIR)ptypes.o
+
+SRC =	$(OBJ_C:.o=.c) $(OBJ_CC:.o=.cc) \
+	$(OBJ_EMULATE_C:.o=.c) $(OBJ_EMULATE_CC:.o=.cc) \
+	common/tclAppInit.cc common/tkAppInit.cc 
+
+OBJ =	$(OBJ_C) $(OBJ_CC) $(OBJ_GEN) $(OBJ_COMPAT)
+
+CLEANFILES = ns nse nsx ns.dyn $(OBJ) $(OBJ_EMULATE_CC) \
+	$(OBJ_EMULATE_C) common/tclAppInit.o \
+	common/tkAppInit.o nstk \
+	$(GEN_DIR)* $(NS).core core core.$(NS) core.$(NSX) core.$(NSE) \
+	common/ptypes2tcl common/ptypes2tcl.o 
+
+SUBDIRS=\
+	indep-utils/cmu-scen-gen/setdest \
+	indep-utils/webtrace-conv/dec \
+	indep-utils/webtrace-conv/epa \
+	indep-utils/webtrace-conv/nlanr \
+	indep-utils/webtrace-conv/ucb
+
+BUILD_NSE = @build_nse@
+
+all: $(NS) $(BUILD_NSE) $(NSTK) all-recursive Makefile
+
+
+all-recursive:
+	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) all; ) done
+
+
+
+
+ifeq ($(NSLIB),libns.dll)
+
+# This is for cygwin
+
+NS_CPPFLAGS = -DNSLIBNAME=\"$(NSLIB)\" 
+NS_LIBS =  @DL_LIBS@
+
+$(NSLIB): $(OBJ) common/tclAppInit.o 
+	$(LINK) -shared $(LDFLAGS) \
+		$(LDOUT)$@  \
+		-Wl,--export-all-symbols \
+		-Wl,--enable-auto-import \
+		-Wl,--out-implib=$@.a \
+		-Wl,--whole-archive $^ \
+		-Wl,--no-whole-archive @V_IMPORT_LIBS@ 
+
+$(NS): $(NSLIB) common/main-modular.cc 
+	$(LINK) $(NS_CPPFLAGS) $(LDFLAGS) $(LDOUT)$@ common/main-modular.cc $(NS_LIBS)
+
+else 
+
+# default for all systems but cygwin
+
+$(NS): $(OBJ) common/tclAppInit.o common/main-monolithic.o
+	$(LINK) $(LDFLAGS) $(LDOUT)$@ $^ $(LIB)
+
+endif 
+
+
+
+Makefile: Makefile.in
+	@echo "Makefile.in is newer than Makefile."
+	@echo "You need to re-run configure."
+	false
+
+$(NSE): $(OBJ) common/tclAppInit.o common/main-monolithic.o $(OBJ_EMULATE_CC) $(OBJ_EMULATE_C)
+	$(LINK) $(LDFLAGS) $(LDOUT)$@ $^ $(LIB) 
+
+$(NSTK): $(OBJ) common/tkAppInit.o 
+	$(LINK) $(LDFLAGS) $(LDOUT)$@ $^ $(LIB)
+
+ns.dyn: $(OBJ) common/tclAppInit.o common/main-monolithic.o 
+	$(LINK) $(LDFLAGS) -o $@ $^ $(LIB)
+
+PURIFY	= purify -cache-dir=/tmp
+ns-pure: $(OBJ) common/tclAppInit.o common/main-monolithic.o 
+	$(PURIFY) $(LINK) $(LDFLAGS) -o $@ $^ $(LIB)
+
+NS_TCL_LIB = \
+	tcl/lib/ns-compat.tcl \
+	tcl/lib/ns-default.tcl \
+	tcl/lib/ns-errmodel.tcl \
+	tcl/lib/ns-lib.tcl \
+	tcl/lib/ns-link.tcl \
+	tcl/lib/ns-mobilenode.tcl \
+	tcl/lib/ns-sat.tcl \
+	tcl/lib/ns-cmutrace.tcl \
+	tcl/lib/ns-node.tcl \
+	tcl/lib/ns-rtmodule.tcl \
+	tcl/lib/ns-hiernode.tcl \
+	tcl/lib/ns-packet.tcl \
+	tcl/lib/ns-queue.tcl \
+	tcl/lib/ns-source.tcl \
+	tcl/lib/ns-nam.tcl \
+	tcl/lib/ns-trace.tcl \
+	tcl/lib/ns-agent.tcl \
+	tcl/lib/ns-random.tcl \
+	tcl/lib/ns-namsupp.tcl \
+	tcl/lib/ns-address.tcl \
+	tcl/lib/ns-intserv.tcl \
+	tcl/lib/ns-autoconf.tcl \
+	tcl/rtp/session-rtp.tcl \
+	tcl/lib/ns-mip.tcl \
+	tcl/rtglib/dynamics.tcl \
+	tcl/rtglib/route-proto.tcl \
+	tcl/rtglib/algo-route-proto.tcl \
+	tcl/rtglib/ns-rtProtoLS.tcl \
+        tcl/interface/ns-iface.tcl \
+	tcl/mcast/BST.tcl \
+        tcl/mcast/ns-mcast.tcl \
+        tcl/mcast/McastProto.tcl \
+        tcl/mcast/DM.tcl \
+	tcl/mcast/srm.tcl \
+	tcl/mcast/srm-adaptive.tcl \
+	tcl/mcast/srm-ssm.tcl \
+	tcl/mcast/timer.tcl \
+	tcl/mcast/McastMonitor.tcl \
+	tcl/mobility/dsdv.tcl \
+	tcl/mobility/dsr.tcl \
+	tcl/mobility/fsr.tcl \
+        tcl/ctr-mcast/CtrMcast.tcl \
+        tcl/ctr-mcast/CtrMcastComp.tcl \
+        tcl/ctr-mcast/CtrRPComp.tcl \
+	tcl/rlm/rlm.tcl \
+	tcl/rlm/rlm-ns.tcl \
+	tcl/session/session.tcl \
+	tcl/lib/ns-route.tcl \
+	tcl/emulate/ns-emulate.tcl \
+	tcl/lan/vlan.tcl \
+	tcl/lan/abslan.tcl \
+	tcl/lan/ns-ll.tcl \
+	tcl/lan/ns-mac.tcl \
+	tcl/webcache/http-agent.tcl \
+	tcl/webcache/http-server.tcl \
+	tcl/webcache/http-cache.tcl \
+	tcl/webcache/http-mcache.tcl \
+	tcl/webcache/webtraf.tcl \
+	tcl/webcache/empweb.tcl \
+	tcl/webcache/empftp.tcl \
+	tcl/plm/plm.tcl \
+	tcl/plm/plm-ns.tcl \
+	tcl/plm/plm-topo.tcl \
+	tcl/mpls/ns-mpls-classifier.tcl \
+	tcl/mpls/ns-mpls-ldpagent.tcl \
+	tcl/mpls/ns-mpls-node.tcl \
+	tcl/mpls/ns-mpls-simulator.tcl \
+	tcl/lib/ns-pushback.tcl \
+	tcl/lib/ns-srcrt.tcl \
+	tcl/mcast/ns-lms.tcl \
+	tcl/lib/ns-qsnode.tcl \
+	@V_NS_TCL_LIB_STL@
+
+$(GEN_DIR)ns_tcl.cc: $(NS_TCL_LIB)
+	$(TCLSH) bin/tcl-expand.tcl tcl/lib/ns-lib.tcl @V_NS_TCL_LIB_STL@ | $(TCL2C) et_ns_lib > $@
+
+$(GEN_DIR)version.c: VERSION
+	$(RM) $@
+	$(TCLSH) bin/string2c.tcl version_string < VERSION > $@
+
+$(GEN_DIR)ptypes.cc: common/ptypes2tcl common/packet.h
+	./common/ptypes2tcl > $@
+
+common/ptypes2tcl: common/ptypes2tcl.o
+	$(LINK) $(LDFLAGS) $(LDOUT)$@ common/ptypes2tcl.o
+
+common/ptypes2tcl.o: common/ptypes2tcl.cc common/packet.h
+
+dirs:
+	for d in $(DESTDIR)$(MANDEST)/man1; do \
+		if [ ! -d $$d ]; then \
+			mkdir -p $$d ;\
+		fi;\
+	done
+
+
+install: dirs force install-ns install-man
+
+install-ns: force
+	$(INSTALL) -m 755 ns $(DESTDIR)$(BINDEST)
+
+install-man: force
+	$(INSTALL) -m 644 ns.1 $(DESTDIR)$(MANDEST)/man1
+
+install-recursive: force
+	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) install; ) done
+
+clean:
+	$(RM) $(CLEANFILES)
+
+AUTOCONF_GEN = tcl/lib/ns-autoconf.tcl
+distclean: distclean-recursive
+	$(RM) $(CLEANFILES) Makefile config.cache config.log config.status \
+	    autoconf.h gnuc.h os-proto.h $(AUTOCONF_GEN); \
+	$(MV) .configure .configure- ;\
+	echo "Moved .configure to .configure-"
+
+distclean-recursive:
+	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) clean; $(RM) Makefile; ) done
+
+tags:	force
+	ctags -wtd *.cc *.h webcache/*.cc webcache/*.h dsdv/*.cc dsdv/*.h \
+	fsr/*.cc fsr/*.h dsr/*.cc dsr/*.h webcache/*.cc webcache/*.h lib/*.cc lib/*.h \
+	../Tcl/*.cc ../Tcl/*.h 
+
+TAGS:	force
+	etags *.cc *.h webcache/*.cc webcache/*.h dsdv/*.cc dsdv/*.h \
+	dsr/*.cc dsr/*.h webcache/*.cc webcache/*.h lib/*.cc lib/*.h \
+	../Tcl/*.cc ../Tcl/*.h
+
+tcl/lib/TAGS:	force
+	( \
+		cd tcl/lib; \
+		$(TCLSH) ../../bin/tcl-expand.tcl ns-lib.tcl | grep '^### tcl-expand.tcl: begin' | awk '{print $$5}' >.tcl_files; \
+		etags --lang=none -r '/^[ \t]*proc[ \t]+\([^ \t]+\)/\1/' `cat .tcl_files`; \
+		etags --append --lang=none -r '/^\([A-Z][^ \t]+\)[ \t]+\(instproc\|proc\)[ \t]+\([^ \t]+\)[ \t]+/\1::\3/' `cat .tcl_files`; \
+	)
+
+depend: $(SRC)
+	$(MKDEP) $(CFLAGS) $(INCLUDES) -- $(SRC) 2>&1 > /dev/null
+
+srctar:
+	@cwd=`pwd` ; dir=`basename $$cwd` ; \
+	    name=ns-`cat VERSION | tr A-Z a-z` ; \
+	    tar=ns-src-`cat VERSION`.tar.gz ; \
+	    list="" ; \
+	    for i in `cat FILES` ; do list="$$list $$name/$$i" ; done; \
+	    echo \
+	    "(rm -f $$tar; cd .. ; ln -s $$dir $$name)" ; \
+	     (rm -f $$tar; cd .. ; ln -s $$dir $$name) ; \
+	    echo \
+	    "(cd .. ; tar cfhz $$tar [lots of files])" ; \
+	     (cd .. ; tar cfhz - $$list) > $$tar ; \
+	    echo \
+	    "rm ../$$name; chmod 444 $$tar" ;  \
+	     rm ../$$name; chmod 444 $$tar
+
+force:
+
+test:	force
+	./validate
+
+# Create makefile.vc for Win32 development by replacing:
+# "# !include ..." 	-> 	"!include ..."
+makefile.vc:	Makefile.in
+	$(PERL) bin/gen-vcmake.pl < Makefile.in > makefile.vc
+#	$(PERL) -pe 's/^# (\!include)/\!include/o' < Makefile.in > makefile.vc
diff -urN ns-2.34.original/fsr/fsr.cc ns-2.34/fsr/fsr.cc
--- ns-2.34.original/fsr/fsr.cc	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/fsr/fsr.cc	2005-01-11 17:50:10.000000000 +0800
@@ -0,0 +1,1028 @@
+/***************************************************************************
+                       fsr.cc  -  FSR Routing Agent
+                             -------------------
+    purpose              : Implementation of a Fisheye State Routing (FSR)
+                            module for ns-2 (vers. 2.27)
+    reference            : draft-ietf-manet-fsr-03.txt
+    begin                : Thu Jul 29 2004 
+    copyright            : (C) 2004 by Sven Jaap
+    			   Institute of Operating Systems 
+    			   and Computer Networks
+    			   Technical University of Braunschweig
+    			   Germany
+    email                : jaap@ibr.cs.tu-bs.de
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include <fsr/fsr.h>
+#include <random.h>
+#include <address.h>
+
+/*
+   TCL Hook for FSR Routing Agent
+*/
+static class FSRClass:public TclClass
+{
+  public:
+  FSRClass ():TclClass ("Agent/FSR"){}
+  TclObject *create (int argc, const char *const * argv)
+  {
+    assert(argc==5);
+    //create new routing agent
+    return (new FSR_Agent ( (nsaddr_t) Address::instance().str2addr(argv[4])));
+  }
+} class_fsr;
+
+/*
+  Initialisation of the Routing Agent when the simulation starts
+*/
+void
+FSR_Agent::initialize_node()
+{
+  nbrsChanged=false;
+  topoChanged=false;
+  nbrlist_size=0;
+  wlist_size=0;
+  //initialize Topo Table
+  tt_addOwnEntry();
+  //initialize Routing Table
+  rt_addOwnEntry();
+  //Start timers for LS Updates
+  lstimerS1.init();
+#ifdef SCOPE2_INTERVAL
+  lstimerS2.init();
+#endif
+#ifdef SCOPE3_INTERVAL
+  lstimerS3.init();
+#endif
+  // Start neighbor timer
+  nbrtimer.handle((Event*) 0);
+}
+
+/*
+   TCL Hook (execution of TCL commands)
+*/
+int
+FSR_Agent::command(int argc, const char*const* argv)
+{
+  if (argc == 2) {
+    Tcl& tcl=Tcl::instance();
+    if (strncasecmp (argv[1], "start-fsr",2) == 0){
+        // start routing agent
+        initialize_node();
+	      return (TCL_OK);
+	  }else if (strncasecmp (argv[1], "id",2) == 0){
+        //get own address
+        tcl.resultf("%d",my_addr);
+        return (TCL_OK);
+    }
+  }else if (argc == 3){
+    if (strcmp(argv[1],"my_addr") == 0){
+      //set own address
+      my_addr=atoi(argv[2]);
+      return TCL_OK;
+    }else if (strcasecmp (argv[1], "tracetarget") == 0){
+      //set target gor traces
+      tracetarget=(Trace*) TclObject::lookup(argv[2]);
+      if (tracetarget==0){
+        return TCL_ERROR;
+      }else{
+        return TCL_OK;
+      }
+    }else if (strcasecmp (argv[1], "drop-target") == 0) {
+          //
+    }else if (strcasecmp (argv[1], "if-queue") == 0) {
+      //set reference to interface queue (see node structure in ns-2)
+      ifqueue = (PriQueue*) TclObject::lookup(argv[2]);
+      if (ifqueue == 0){
+        return TCL_ERROR;
+      } else {
+        return TCL_OK;
+      }                
+    }else if (strcasecmp (argv[1], "port-dmux") == 0) {
+      //set reference to port dmux (see node structure in ns-2)
+  	  port_dmux_ = (PortClassifier *)TclObject::lookup(argv[2]);
+      if (port_dmux_ == 0){
+        fprintf(stderr, "%s: %s lookup of %s failed\n",__FILE__, argv[1], argv[2]);
+        return TCL_ERROR;
+      } else {
+        return TCL_OK;
+      }
+    }
+  }
+  return Agent::command (argc, argv);
+}
+
+/*
+    Constructor of FSR routing agent
+*/
+
+
+FSR_Agent::FSR_Agent(nsaddr_t id): Agent(PT_MESSAGE),
+                                     lstimerS1(this),
+                          #ifdef SCOPE2_INTERVAL
+                                     lstimerS2(this),
+                          #endif                                     
+                          #ifdef SCOPE3_INTERVAL
+                                     lstimerS3(this),
+                          #endif
+                                     nbrtimer(this){
+  // set some variables
+  my_addr=id;
+  curr_seqno=0;
+
+  LIST_INIT(&nbrhead);
+  LIST_INIT(&whead);
+  ifqueue=0;
+  tracetarget=0;
+}
+
+/*************************************************
+    TIMERS
+**************************************************/
+
+/*
+  Handle Event for new LS Update (Scope 1)
+*/
+void
+LSUpdateTimerS1::handle(Event*){
+ //send LS update
+ agent->sendLSUpdate(0,SCOPE1_HOPS);
+ double interval=SCOPE1_INTERVAL+(LS_UPDATE_JITTER * Random::uniform());
+ assert (interval >= 0);
+ //reschedule event
+ Scheduler::instance().schedule(this, &intr, interval);
+}
+
+/*
+  Initilize Update Timer for scope 1
+*/
+void
+LSUpdateTimerS1::init(){
+   //start updates immediately
+   handle( (Event*) 0);
+}
+
+#ifdef SCOPE2_INTERVAL
+/*
+  Handle Event for new LS Update (Scope 2)
+*/
+void
+LSUpdateTimerS2::handle(Event*){
+ //send LS update  
+ agent->sendLSUpdate(SCOPE1_HOPS+1,SCOPE2_HOPS);
+ double interval=SCOPE2_INTERVAL+(LS_UPDATE_JITTER * Random::uniform());
+ assert (interval >= 0);
+ //reschedule event
+ Scheduler::instance().schedule(this, &intr, interval);
+}
+/*
+  Initilize Update Timer for scope 2
+*/
+void
+LSUpdateTimerS2::init(){
+   //send first updates at about time SCOPE2_INTERVAL
+  double interval=SCOPE2_INTERVAL+(LS_UPDATE_JITTER * Random::uniform());
+  assert (interval >= 0);
+  //schedule event
+  Scheduler::instance().schedule(this, &intr, interval);
+}
+#endif
+
+#ifdef SCOPE3_INTERVAL
+/*
+  Handle Event for new LS Update (Scope 3)
+*/
+void
+LSUpdateTimerS3::handle(Event*){
+ //send LS Update
+ agent->sendLSUpdate(SCOPE2_HOPS+1,SCOPE3_HOPS);
+ double interval=SCOPE3_INTERVAL+(LS_UPDATE_JITTER * Random::uniform());
+ assert (interval >= 0);
+ //reschedule event
+ Scheduler::instance().schedule(this, &intr, interval);
+}
+/*
+  Initilize Update Timer for scope 2
+*/
+void
+LSUpdateTimerS3::init(){
+   //send first updates at about time SCOPE3_INTERVAL
+  double interval=SCOPE3_INTERVAL+(LS_UPDATE_JITTER * Random::uniform());
+  assert (interval >= 0);
+  //schedule event
+  Scheduler::instance().schedule(this, &intr, interval);
+}
+# endif
+
+
+/*
+  Handle Event for purging neighbor list
+*/
+void
+NbrPurgeTimer::handle(Event *){
+  agent->nbr_purge();
+  Scheduler::instance().schedule(this, &intr,NEIGHBOR_TIMEOUT);
+}
+
+/*************************************************
+    MANAGEMENT OF THE FSR NEIGHBOR LIST
+**************************************************/
+
+/*
+    Insert new neighboring node into list
+*/
+void
+FSR_Agent::nbr_insert(nsaddr_t addr){
+ FSR_Neighbor *nbr = new FSR_Neighbor(addr);
+ assert (nbr); //check whether new neighbor is created
+ nbr->nbr_lastRecvTime=NOW;
+ LIST_INSERT_HEAD(&nbrhead,nbr,nbr_link);
+ nbrlist_size++;
+}
+/*
+    Remove neighboring node from list
+*/
+void
+FSR_Agent::nbr_delete(nsaddr_t addr){
+ FSR_Neighbor *nbr = nbrhead.lh_first;
+ for(;nbr;nbr=nbr->nbr_link.le_next){
+   if(nbr->nbr_addr == addr){
+      LIST_REMOVE(nbr,nbr_link);
+      delete nbr;
+      nbrlist_size--;
+      break;
+   }
+ }
+}
+/*
+    Get number of neighbors
+*/
+int
+FSR_Agent::nbr_size(){
+ return nbrlist_size;
+}
+/*
+    Remove neighbors that have expired
+*/
+void
+FSR_Agent::nbr_purge(){
+ FSR_Neighbor *nbr=nbrhead.lh_first;
+ FSR_Neighbor *next_nbr;
+ double now = NOW;
+ double interval=NEIGHBOR_TIMEOUT;
+ //run through the neighbor list and delete expired entries
+ for(;nbr;nbr=next_nbr){
+    next_nbr=nbr->nbr_link.le_next;
+    if((nbr->nbr_lastRecvTime+interval) < now){
+      nbr_delete(nbr->nbr_addr); // remove
+      nbrsChanged=true;
+    }
+ }
+}
+/*
+    Get Neighbor from List
+*/
+FSR_Neighbor*
+FSR_Agent::nbr_lookup(nsaddr_t addr){
+ FSR_Neighbor *nbr = nbrhead.lh_first;
+ for(;nbr;nbr=nbr->nbr_link.le_next){
+  if(nbr->nbr_addr == addr)
+    break;
+ }
+ return nbr;
+}
+
+/*************************************************
+    MANAGEMENT OF THE findSP() iteration list
+**************************************************/
+
+/*
+    Insert new node into list
+*/
+void
+FSR_Agent::w_insert(nsaddr_t addr, fsr_tt_entry* tt, fsr_rt_entry* rt){
+ fsr_wlist_entry *node = new fsr_wlist_entry(addr,tt,rt);
+ assert (node); //check whether new entry is created
+ LIST_INSERT_HEAD(&whead,node,node_link);
+ wlist_size++;
+}
+
+/*
+    Remove node from list
+*/
+void
+FSR_Agent::w_delete(nsaddr_t addr){
+ fsr_wlist_entry *node = whead.lh_first;
+ for(;node;node=node->node_link.le_next){
+   if(node->node_addr == addr){
+      LIST_REMOVE(node,node_link);
+      delete node;
+      wlist_size--;
+      break;
+   }
+ }
+}
+
+/*
+    Get number of nodes
+*/
+int
+FSR_Agent::w_size(){
+ return wlist_size;
+}
+
+/*
+    Remove all elements from list
+*/
+
+void
+FSR_Agent::w_clear(){
+ fsr_wlist_entry *node;
+ while(node=whead.lh_first){
+    LIST_REMOVE(node,node_link);
+    delete node;
+ }
+ wlist_size=0;
+}
+
+/*
+    Get Entry from List
+*/
+fsr_wlist_entry*
+FSR_Agent::w_lookup(nsaddr_t addr){
+ fsr_wlist_entry *node = whead.lh_first;
+ for(;node;node=node->node_link.le_next){
+  if(node->node_addr == addr)
+    break;
+ }
+ return node;
+}
+
+
+/*************************************************
+    MANAGEMENT OF THE TOPOLOGY TABLE
+**************************************************/
+
+/*
+    Add own entry to Topology Table after initialization
+*/
+void
+FSR_Agent::tt_addOwnEntry(){
+ fsr_tt_entry *tt;
+ tt=ttable.tt_lookup(my_addr);
+ if(tt==0){
+    //set up own entry
+    tt=ttable.tt_add(my_addr);
+    tt->tt_destseq=curr_seqno;
+    tt->tt_lstheardtime=NOW;
+    tt->tt_prevseq=curr_seqno;
+ }
+}
+/*
+    Update entry of own node in the Topology Table
+*/
+void
+FSR_Agent::tt_updateOwnEntry(){
+  FSR_Neighbor *nbr=nbrhead.lh_first;
+  if (nbrsChanged){
+    int numNbrs=0;
+    //increment own sequence number
+    curr_seqno++;
+    fsr_tt_entry *tt=ttable.tt_lookup(my_addr);
+    assert(tt);
+    tt->tt_destseq=curr_seqno;
+    tt->tt_lstheardtime=NOW;
+    tt->tt_needtosend=true;
+    tt->nbr_clear();
+    //renew own Neighbor list in Topology Table
+    for(;nbr && (numNbrs < FSR_MAX_NBRS);nbr=nbr-> nbr_link.le_next){
+         tt->nbr_insert(nbr->nbr_addr);
+         numNbrs++;
+    }
+    nbrsChanged=false;
+  }
+}
+/*
+    Remove stale entries from the Topology Table
+    The Timeout interval depends on the scope's update interval
+*/
+void
+FSR_Agent::tt_purge(){
+  fsr_tt_entry *tt = ttable.head();
+  fsr_tt_entry *next_tt;
+  fsr_rt_entry *rt;
+  double scope1_int= ((double)TOPO_TIMEOUT_MUL)*SCOPE1_INTERVAL;
+  #ifdef SCOPE2_INTERVAL
+  double scope2_int=((double)TOPO_TIMEOUT_MUL)*SCOPE2_INTERVAL;
+  #endif
+  #ifdef SCOPE3_INTERVAL
+  double scope3_int=((double)TOPO_TIMEOUT_MUL)*SCOPE3_INTERVAL;
+  #endif
+  //iterate through all entries
+  for(;tt;tt=next_tt){
+    next_tt=tt->tt_link.le_next;
+    if(rt=rtable.rt_lookup(tt->tt_dest)){
+      // determine node's scope
+      // never time out own entry (dist=0)
+      if ( 1 <= rt->rt_dist && rt->rt_dist <= SCOPE1_HOPS){
+          //SCOPE 1
+          if ( (tt->tt_lstheardtime + scope1_int) < NOW){
+              ttable.tt_delete(tt->tt_dest);
+              continue;
+          }
+      }
+   #ifdef SCOPE2_INTERVAL
+      else if ((SCOPE1_HOPS < rt->rt_dist) && (rt->rt_dist <= SCOPE2_HOPS)){
+          //SCOPE 2
+          if ( (tt->tt_lstheardtime + scope2_int) < NOW){
+              ttable.tt_delete(tt->tt_dest);
+              continue;
+          }
+      }
+   #endif
+   #ifdef SCOPE3_INTERVAL
+      else if ((SCOPE2_HOPS < rt->rt_dist) && (rt->rt_dist <= SCOPE3_HOPS)){
+          //SCOPE 3
+          if ( (tt->tt_lstheardtime + scope3_int) < NOW){
+              ttable.tt_delete(tt->tt_dest);
+              continue;
+          }
+      }
+   #endif
+    }
+  }
+}
+
+/*************************************************
+    MANAGEMENT OF THE ROUTING TABLE
+**************************************************/
+
+/*
+    Add own entry to Topology Table after initialization
+*/
+void
+FSR_Agent::rt_addOwnEntry(){
+ fsr_rt_entry *rt;
+ rt=rtable.rt_lookup(my_addr);
+ if(rt==0){
+    //set up own entry
+    rt=rtable.rt_add(my_addr);
+    rt->rt_dist=0;
+    rt->rt_nexthop=my_addr;
+ }
+}
+
+
+/*
+    initialize neighbored node
+*/
+void
+FSR_Agent::rt_initnbrnode(fsr_rt_entry* rt, nsaddr_t dest){
+  rt->rt_dist=FSR_WEIGHT;
+  rt->rt_nexthop=dest;
+}
+
+/*
+    initialize other node
+*/
+void
+FSR_Agent::rt_initothernode(fsr_rt_entry* rt){
+  rt->rt_dist=FSR_UNREACHABLE;
+  rt->rt_nexthop=-1;
+}
+
+/*
+    get entry for node from the routing table that is
+    currently not processed (is in w list) and is
+    closest to me
+*/
+fsr_wlist_entry*
+FSR_Agent::rt_getnxtentry(){
+  fsr_wlist_entry *min;
+  fsr_wlist_entry *w=whead.lh_first;
+  int minDist=FSR_UNREACHABLE;
+  //iterate through w_list
+  for(;w;w=w->node_link.le_next){
+    if (w->rt->rt_dist <= minDist){
+      //found new node with min distance to me => remember it
+      minDist=w->rt->rt_dist;
+      min=w;
+    }
+  }
+  return min;
+}
+/*
+   Start update of routing table
+*/
+void
+FSR_Agent::rt_replace(){
+
+  // 1. Purge Topology Table
+  tt_purge();
+  // 2. Clear current Routing Table
+  rtable.rt_clear(my_addr);
+  // 3. find shortest path tree rooted at my node
+  rt_findSP();
+  // 4. remove entries that are unreachable
+  //    (may appear e.g. due to timeouts of topo entries )
+  rtable.rt_purge();
+}
+
+/*
+   Determining the routing table from the known topology information
+        => calculate shortest path tree routed at my node
+*/
+void
+FSR_Agent::rt_findSP(){
+  fsr_tt_entry* tt=ttable.head();
+  fsr_rt_entry* rt;
+  fsr_rt_entry* rt_it;
+  fsr_wlist_entry* wl;
+  FSR_Neighbor *nbr;
+  // 1. INITIALISATION
+  // initialisation of own entry
+  //     => insert my address in iteration list
+  w_clear();
+  // initialize the temporary routing table with all known destinations
+  for(;tt;tt=tt->tt_link.le_next){
+    if (tt->tt_dest==my_addr){
+      //Skip own entry
+    } else if (nbr_lookup(tt->tt_dest)){
+      // destination is in the immediate communication range
+      if(!w_lookup(tt->tt_dest)){
+        if (!rtable.rt_lookup(tt->tt_dest)){
+           rt=rtable.rt_add(tt->tt_dest);
+           rt_initnbrnode(rt,tt->tt_dest);
+        }
+	w_insert(tt->tt_dest,tt,rt);
+      }
+    } else {
+      // other nodes that are not immediate neighbors to me
+      if(!w_lookup(tt->tt_dest)){
+        if (!rtable.rt_lookup(tt->tt_dest)){
+           rt=rtable.rt_add(tt->tt_dest);
+           rt_initothernode(rt);
+	}
+	w_insert(tt->tt_dest,tt,rt);
+      }
+    }
+    //scan neighbors for further nodes
+    nbr=tt->tt_nbrlist.lh_first;
+    for (;nbr;nbr=nbr->nbr_link.le_next){
+      if (nbr->nbr_addr==my_addr){
+          //Skip own entry
+      } else if (nbr_lookup(nbr->nbr_addr)){
+        // destination is in the immediate communication range
+        if (!rtable.rt_lookup(nbr->nbr_addr)){
+           rt=rtable.rt_add(nbr->nbr_addr);
+           rt_initnbrnode(rt,nbr->nbr_addr);
+        }
+      } else {
+        // other nodes that are not immediate neighbors to me
+        if (!rtable.rt_lookup(nbr->nbr_addr)){
+           rt=rtable.rt_add(nbr->nbr_addr);
+           rt_initothernode(rt);
+        }
+      }
+    }
+  }
+  // 2. START CALCULATION
+  while (whead.lh_first){
+    // iterate until all nodes from w list are processed
+    wl=rt_getnxtentry();
+    // Get pointers to entries in Topo and Routing Table
+    tt=wl->tt;
+    rt=wl->rt;
+    if (tt){
+        nbr=tt->tt_nbrlist.lh_first;
+        for (;nbr;nbr=nbr->nbr_link.le_next){
+           // check routes to all neighbors from rt->dest
+           rt_it=rtable.rt_lookup(nbr->nbr_addr);
+           if( (rt->rt_dist+FSR_WEIGHT) < rt_it->rt_dist){
+              // found new shortest path
+              rt_it->rt_dist=rt->rt_dist+FSR_WEIGHT;
+              rt_it->rt_nexthop=rt->rt_nexthop;
+           }
+        }
+    }
+    w_delete(wl->node_addr);
+  }
+}
+
+/*
+    Resolve route to destination and forward packet
+*/
+void
+FSR_Agent::rt_resolve(Packet *p){
+  struct hdr_ip *iph = HDR_IP(p);
+  struct hdr_cmn *cmh = HDR_CMN(p);
+  fsr_rt_entry *rt;
+  // lookup route to destination
+  rt=rtable.rt_lookup(iph->daddr());
+  if (rt && (rt->rt_dist < FSR_UNREACHABLE) &&(rt->rt_dest!=-1)) {
+      // found entry in routing Table
+      forward(rt,p,-1.0);                   //forward packet immediately
+  } else {
+      // no route available
+      drop(p,DROP_RTR_NO_ROUTE);
+  }
+}
+/*************************************************
+    METHODS CONCERNING THE RECEPTION OF PACKETS
+**************************************************/
+
+/*
+   Main Packet Reception Routine
+*/
+void
+FSR_Agent::recv (Packet * p, Handler *)
+{
+  struct hdr_ip *iph = HDR_IP(p);
+  struct hdr_cmn *cmh = HDR_CMN(p);
+
+  assert(initialized());
+
+  /*
+   *  Must be a packet I'm originating...
+   */
+  if((iph->saddr() == my_addr)&& (cmh->num_forwards() == 0) ) {
+    /*
+     * Add the IP Header
+     */
+    cmh->size() += IP_HDR_LEN;
+    if ( (u_int32_t)iph->daddr() != IP_BROADCAST ){
+        iph->ttl_ = IP_DEF_TTL;
+    }
+  }
+  /*
+   *  I received a packet that I sent.  Probably
+   *  a routing loop.
+   */
+  else if(iph->saddr() == my_addr) {
+    drop(p, DROP_RTR_ROUTE_LOOP);
+    return;
+  }
+  /*
+     Received a Link State Update
+  */
+  else if ((iph->saddr() != my_addr) && (iph->dport() == ROUTER_PORT)&& (iph->sport() == ROUTER_PORT)){
+    iph->ttl_ -=1;
+    recvLSUpdate(p);
+    return;
+  }
+  /*
+   *  Packet I'm forwarding...
+   */
+  else {
+    /*
+     *  Check the TTL.  If it is zero, then discard.
+     */
+    if(--iph->ttl_ == 0) {
+      drop(p, DROP_RTR_TTL);
+      return;
+    }
+
+  }
+  if ( (u_int32_t) iph->daddr() != IP_BROADCAST){
+     rt_resolve(p);                    // search route to destination
+     return;
+  } else{
+     //Broadcast Packet
+     forward((fsr_rt_entry*)0,p,-1.0); //forward packet immediately
+     return;
+  }
+}
+
+/*
+  Process a LS Updated that was received
+*/
+void
+FSR_Agent::recvLSUpdate(Packet *p){
+  struct hdr_ip *iph = HDR_IP(p);
+  unsigned char *pktDataPtr;
+  FSR_Neighbor *nbr;
+  fsr_tt_entry *tt;
+  nsaddr_t destAddr;
+  nsaddr_t nbAddr;
+  u_int32_t destseq;
+  int numOfNodes;
+  bool newDst;
+  //Sanity Checks
+  assert(iph->sport() == ROUTER_PORT);
+  assert(iph->dport() == ROUTER_PORT);
+  //Check whether sender is known neighbor
+  nbr=nbr_lookup(iph->saddr());
+  if(nbr==0){
+    //new neighbor => insert into list
+    nbr_insert(iph->saddr());
+    // set Flag for Update of Own Entry in Topology Table
+    nbrsChanged=true;
+  } else {
+    //knwon neighbor => update lastRecvTime
+    nbr->nbr_lastRecvTime=NOW;
+  }
+  // Get LS Information from packet
+  // 1. Packet Length
+  pktDataPtr=p->accessdata();
+  int pktLength= *(pktDataPtr++);
+  pktLength= pktLength << 8 | *(pktDataPtr++);
+  //Skip Reserved (16 Bit)
+  pktDataPtr+=2;
+  pktLength-=4;
+  while(pktLength > 0){
+    // Destination Address (32 Bit)
+    destAddr = *(pktDataPtr++);
+    destAddr = destAddr << 8 | *(pktDataPtr++);
+    destAddr = destAddr << 8 | *(pktDataPtr++);
+    destAddr = destAddr << 8 | *(pktDataPtr++);
+    //DEBUG
+    //fprintf(stderr,"Dest: %d \n",destAddr);
+    //search destination in Topo Table
+    tt=ttable.tt_lookup(destAddr);
+    if (tt==0){
+      // 1. Case: new destination => add new entry in Topo Table
+      tt=ttable.tt_add(destAddr);
+      newDst=true;
+      topoChanged=true;// remember that Topo Table changed
+    }
+    // Destination Sequence Number (24 Bit)
+    destseq = 0;
+    destseq = *(pktDataPtr++);
+    destseq = destseq << 8 | *(pktDataPtr++);
+    destseq = destseq << 8 | *(pktDataPtr++);
+    if ((destseq > tt->tt_destseq) || newDst){
+      // 2. Case: a) received most up to date information
+      //              => replace current Topo Table entry
+      //          b) fill entry for new destination
+      newDst=false;
+      topoChanged=true; // remember that Topo Table changed
+      tt->tt_destseq=destseq;
+      tt->tt_lstheardtime=NOW;
+      tt->tt_needtosend=true;
+      // Number of Nodes (8 Bit)
+      numOfNodes=*(pktDataPtr++);
+      pktLength-=8;
+      tt->nbr_clear();
+      for(;numOfNodes>0;numOfNodes--){
+        // Neighbor Address (32Bit)
+        nbAddr =*(pktDataPtr++);
+        nbAddr= nbAddr << 8 | *(pktDataPtr++);
+        nbAddr= nbAddr << 8 | *(pktDataPtr++);
+        nbAddr= nbAddr << 8 | *(pktDataPtr++);
+        tt->nbr_insert(nbAddr);
+        pktLength-=4;
+      }
+    } else if (destseq < tt->tt_prevseq){
+      // 3. Case: received outdated information
+      //              => send known info with next LS Update
+      tt->tt_needtosend=true;
+      tt->tt_lstheardtime=NOW;
+      numOfNodes=(*(pktDataPtr++))*4;
+      // Skip Neigbored Nodes
+      pktDataPtr+=numOfNodes;
+      pktLength-=(8+(4*numOfNodes));
+    } else {
+      //nothing to do
+      //most up to date info is already known
+      tt->tt_lstheardtime=NOW;
+      numOfNodes=(*(pktDataPtr++))*4;
+      // Skip Neigbored Nodes
+      pktDataPtr+=numOfNodes;
+      pktLength-=(8+numOfNodes);
+    }
+  }
+  Packet::free(p); // free routing packet
+  if (topoChanged) {
+      //RECOMPUTE ROUTING TABLE IF TOPOLOGY TABLE CHANGED
+      rt_replace();
+      topoChanged=false;
+  }
+}
+
+
+/*************************************************
+    METHODS CONCERNING THE TRANSMISISION OF PACKETS
+**************************************************/
+
+/*
+    Forward data packet
+*/
+void
+FSR_Agent::forward(fsr_rt_entry *rt,Packet *p, double delay){
+  struct hdr_cmn *cmh = HDR_CMN(p);
+  struct hdr_ip  *iph = HDR_IP(p);
+  //check TTL
+  if(iph->ttl_ == 0){
+    //drop packet
+    drop(p,DROP_RTR_TTL);
+    return;
+  } else {
+    if (cmh->ptype() !=PT_MESSAGE && cmh->direction()==hdr_cmn::UP &&
+          ( (u_int32_t) iph->daddr() == IP_BROADCAST)
+              || ((u_int32_t)iph->daddr() == here_.addr_)){
+        port_dmux_->recv(p,0);  // deliver broadcast packet or
+                                // packet to me
+        return;
+    } else {
+        if (rt) {
+          // route to destination is available
+          cmh->next_hop_    = rt->rt_nexthop;   //add next hop info to packet
+          cmh->addr_type()  = NS_AF_INET;
+          cmh->direction()  = hdr_cmn::DOWN;    // change direction of packet
+          // FORWARD PACKET
+          if (delay > 0.0){
+              Scheduler::instance().schedule(target_,p,delay);
+          } else {
+              Scheduler::instance().schedule(target_,p,0.0);
+          }
+        } else {
+          // packet is broadcast packet
+          assert(iph->daddr() = (nsaddr_t) IP_BRAODCAST);
+          cmh->addr_type()    = NS_AF_NONE;
+          cmh->direction()    = hdr_cmn::DOWN;  // change direction od packet
+          // FORWARD BROADCAST PACKET
+          // use jitter to avoid synchonization
+          Scheduler::instance().schedule(target_,p,FSR_BROADCAST_JITTER*Random::uniform());          
+        }
+    }
+  }
+}
+
+/*
+    Create and send a LS Update to all neighbors
+*/
+void
+FSR_Agent::sendLSUpdate(int lowerBound, int upperBound){
+ unsigned char *pktDataPtr;
+ nsaddr_t sizeLimitAddr=-1;
+ bool     sizeLimit=false;
+ //counter for necessary data amount of update
+ // initilized with 4 (PacketLength+Reserved);
+ int dataAmount=4;
+ int tmpAmount=0;
+ fsr_tt_entry *tt;
+ fsr_rt_entry *rt;
+ FSR_Neighbor *nbr;
+ Packet *p = Packet::alloc();
+ struct hdr_ip  *iph = HDR_IP(p);
+ struct hdr_cmn *cmh = HDR_CMN(p);
+ //fill packet headers
+ cmh->next_hop_    = IP_BROADCAST;
+ cmh->addr_type()  = NS_AF_NONE;
+ cmh->ptype()      = PT_MESSAGE;
+ iph->saddr()      = my_addr;
+ iph->daddr()      = IP_BROADCAST;
+ iph->sport()      = RT_PORT;
+ iph->dport()      = RT_PORT;
+ iph->ttl_         = 1;
+ if (lowerBound==0){
+   //Update own entry first when it belongs to current scope
+   tt_updateOwnEntry();
+ }
+ // remove stale entries from topology table
+ tt_purge();
+ //Determine amount of Data to be send
+ tt=ttable.head();
+ for(;tt;tt=tt->tt_link.le_next){
+  if(tt->tt_needtosend){
+    if (rt=rtable.rt_lookup(tt->tt_dest)){
+      if (rt->rt_dist >= lowerBound && rt->rt_dist<=upperBound){
+        tmpAmount=8;//(Dst Addr + DST Seq Nr + num Neighbors)
+        tmpAmount+=(tt->nbr_size()*4); //32bit per Neighbor
+        sizeLimitAddr=tt->tt_dest;
+        if ((dataAmount+tmpAmount) > FSR_MAX_PKT_SIZE){
+          sizeLimit=true;
+          break;
+        } else {
+          dataAmount+=tmpAmount;
+        }
+      }
+    }
+  }
+ }
+ //set size of packet
+ 
+ p->allocdata(dataAmount);
+ pktDataPtr = p->accessdata();
+
+ //bulid LS Update byte by byte
+ // 1. Packet Length (16 Bit)
+ u_int16_t pktLength=dataAmount;
+ *(pktDataPtr++)= (pktLength >> 8) & 0xFF;
+ *(pktDataPtr++)= (pktLength >> 0) & 0xFF;
+ // 2. Reserved  (16 Bit)
+ *(pktDataPtr++) = 0xFF;
+ *(pktDataPtr++) = 0xFF;
+ tt=ttable.head();
+ for(;tt;tt=tt->tt_link.le_next){
+  if (sizeLimit && sizeLimitAddr==tt->tt_dest){
+    //break building of Update Msg here due to
+    //limitation of packet size in FSR
+    break;
+  } else {
+    if (tt->tt_needtosend){
+      if (rt=rtable.rt_lookup(tt->tt_dest)){
+        if (rt->rt_dist >= lowerBound && rt->rt_dist<=upperBound){
+            // Destination Address (32 Bit)
+            *(pktDataPtr++)= (tt->tt_dest >> 24) & 0xFF;  
+            *(pktDataPtr++)= (tt->tt_dest >> 16) & 0xFF;
+            *(pktDataPtr++)= (tt->tt_dest >> 8) & 0xFF;
+            *(pktDataPtr++)= (tt->tt_dest >> 0) & 0xFF;
+            // Destination Sequence Number (24 Bit)
+            // stored in u_int32_t
+            *(pktDataPtr++)= (tt->tt_destseq >> 16) & 0xFF;
+            *(pktDataPtr++)= (tt->tt_destseq >> 8) & 0xFF;
+            *(pktDataPtr++)= (tt->tt_destseq >> 0) & 0xFF;
+            // Number of Neighbors (8 Bit)
+            *(pktDataPtr++)=tt->nbr_size();
+            FSR_Neighbor *nbr=tt->tt_nbrlist.lh_first;
+            for(;nbr;nbr=nbr->nbr_link.le_next){
+                //Neighbor Address (32 Bit)
+                *(pktDataPtr++)= (nbr->nbr_addr >> 24) & 0xFF;
+                *(pktDataPtr++)= (nbr->nbr_addr >> 16) & 0xFF;
+                *(pktDataPtr++)= (nbr->nbr_addr >> 8) & 0xFF;
+                *(pktDataPtr++)= (nbr->nbr_addr >> 0) & 0xFF;
+            }
+            //reset flag
+            tt->tt_needtosend=false;
+            //replace prev. seq.-nr. with curr. seq.-nr
+            tt->tt_prevseq=tt->tt_destseq;
+        }
+      }
+    }
+  }
+ }
+ //set Size of Packet
+ cmh->size()      = IP_HDR_LEN+dataAmount;
+ Scheduler::instance().schedule(target_,p,LS_UPDATE_JITTER*Random::uniform());
+ // create further packet when limit of packet lenght was reached
+ if (sizeLimit){
+    sendLSUpdate(lowerBound,upperBound);
+ }
+}
+
+/*************************************************
+    METHODS FOR DEBUGGING PUROPSES
+**************************************************/
+/*
+    show entries of FSR Neighbor List
+*/
+void
+FSR_Agent::show_nbrlist(){
+ FSR_Neighbor *nbr=nbrhead.lh_first;
+ printf("\nNeighbors of: %d\n",my_addr);
+ printf("-------------\n");
+ for( ; nbr ; nbr=nbr->nbr_link.le_next){
+  printf("NB: %d TIME: %f\n",nbr->nbr_addr,nbr->nbr_lastRecvTime);
+ }
+ printf("Current Size: %d",nbrlist_size);
+}
+
+/*
+    show entries of FSR Topology Table
+*/
+void
+FSR_Agent::show_ttable(){
+ fsr_tt_entry *tt=ttable.tthead.lh_first;
+ printf("\nTopo Info of: %d\n",my_addr);
+ printf("-------------\n");
+ for( ; tt ; tt=tt->tt_link.le_next){
+  printf("ID: %d SEQ: %d TIME: %f\n",tt->tt_dest,tt->tt_destseq,tt->tt_lstheardtime);
+ }
+}
+
+/*
+    show entries of FSR Routing Table
+*/
+void
+FSR_Agent::show_rtable(){
+ fsr_rt_entry *rt=rtable.head();
+ printf("\nRT Info of: %d\n",my_addr);
+ printf("-------------\n");
+ for( ; rt ; rt=rt->rt_link.le_next){
+  printf("ID: %d DIST: %d NXT: %d\n",rt->rt_dest,rt->rt_dist,rt->rt_nexthop);
+ }
+}
+
+/*
+    show entries of findSP() iteration list
+*/
+void
+FSR_Agent::show_wlist(){
+ fsr_wlist_entry *node=whead.lh_first;
+ printf("W LIST of: %d\n",my_addr);
+ printf("-------------\n");
+ for( ; node ; node=node->node_link.le_next){
+  printf("ID: %d \n",node->node_addr);
+ }
+}
diff -urN ns-2.34.original/fsr/fsr.h ns-2.34/fsr/fsr.h
--- ns-2.34.original/fsr/fsr.h	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/fsr/fsr.h	2005-01-11 17:50:24.000000000 +0800
@@ -0,0 +1,248 @@
+/***************************************************************************
+                  fsr.h  -  Header File of FSR_Agent/Timers
+                             -------------------
+    purpose              : Implementation of a Fisheye State Routing (FSR)
+                            module for ns-2 (vers. 2.27)
+    reference            : draft-ietf-manet-fsr-03.txt
+    begin                : Thu Jul 29 2004
+    copyright            : (C) 2004 by Sven Jaap
+		    			   Institute of Operating Systems
+		    			   and Computer Networks
+		    			   Technical University of Braunschweig
+		    			   Germany
+    email                : jaap@ibr.cs.tu-bs.de
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef __fsr_h_
+#define __fsr_h_
+
+#include <priqueue.h>
+#include <cmu-trace.h>
+#include <fsr/fsr_rtable.h>
+#include <fsr/fsr_ttable.h>
+#include <fsr/fsr_nbrlist.h>
+#include <fsr/fsr_wlist.h>
+#include <classifier/classifier-port.h>
+#include <scheduler.h>
+
+#define MAX_QUEUE_LENGTH      5
+#define ROUTER_PORT           0xff
+
+#define FSR_UNREACHABLE       0xFFFF
+
+//Weight of a link (here: 1, but might be complex function)
+#define FSR_WEIGHT            1
+
+//Jitter to avoid synchronization
+#define LS_UPDATE_JITTER      0.1
+#define FSR_BROADCAST_JITTER  0.01
+
+//Parameters of the fisheye scopes
+#define NUM_OF_SCOPES         2
+#define SCOPE1_INTERVAL       5       //[sec]
+#define SCOPE2_INTERVAL       15      //[sec]
+#define SCOPE1_HOPS           2       //[hops]
+#define SCOPE2_HOPS           0xFFFF  //[hops]
+
+//Multiplier for Topology Table timeout
+#define TOPO_TIMEOUT_MUL      3     // Timeout[sec] = x * SCOPE(i)_INTERVAL
+
+// Timeout interval for neighbored nodes
+#define NEIGHBOR_TIMEOUT      15  //[sec]
+// Max. number of considered neighbors per node
+//   => limited by field length in LS Update Msg
+#define FSR_MAX_NBRS         255  //[nodes] (255==8 Bit)
+// Max. Packet Size for LSUpdate
+#define FSR_MAX_PKT_SIZE     65535// [bytes] (65535==16 Bit)
+
+#define NOW Scheduler::instance().clock()
+
+class FSR_Agent;
+
+/*************************************************************
+    TIMERS
+**************************************************************/
+
+/*
+  Timer for FSR Link State Updates (Scope 1)
+*/
+class LSUpdateTimerS1: public Handler {
+public:
+        LSUpdateTimerS1(FSR_Agent* a) : agent(a) {}
+        void handle(Event*);
+        void init();
+private:
+        FSR_Agent   *agent;
+        Event       intr;
+
+};
+
+#ifdef SCOPE2_INTERVAL
+/*
+  Timer for FSR Link State Updates (Scope 2)
+*/
+class LSUpdateTimerS2: public Handler {
+public:
+        LSUpdateTimerS2(FSR_Agent* a) : agent(a) {}
+        void handle(Event*);
+        void init();
+private:
+        FSR_Agent   *agent;
+        Event       intr;
+
+};
+#endif
+
+#ifdef SCOPE3_INTERVAL
+/*
+  Timer for FSR Link State Updates (Scope 3)
+*/
+class LSUpdateTimerS3: public Handler {
+public:
+        LSUpdateTimerS3(FSR_Agent* a) : agent(a) {}
+        void handle(Event*);
+        void init();
+private:
+        FSR_Agent   *agent;
+        Event       intr;
+
+};
+#endif
+/*
+  Timer for removing stale entries from the neigbor list
+*/
+class NbrPurgeTimer: public Handler {
+public:
+        NbrPurgeTimer(FSR_Agent* a) : agent(a) {}
+        void handle(Event*);
+private:
+        FSR_Agent   *agent;
+        Event       intr;
+
+};
+/*
+
+/*************************************************************
+  FSR Routing Agent
+**************************************************************/
+class FSR_Agent : public Agent {
+      friend class fsr_rt_entry;
+      friend class fsr_tt_entry;
+      friend class LSUpdateTimerS1;
+      friend class LSUpdateTimerS2;
+      friend class LSUpdateTimerS3;
+      friend class NbrPurgeTimer;
+      friend class TopoPurgeTimer;
+public:
+  FSR_Agent(nsaddr_t id);
+  void    recv(Packet *p, Handler *);
+protected:
+  int     command(int argc, const char * const * argv);
+  int     initialized() {return 1 && target_;}
+  void    initialize_node(void);
+
+  /*
+     Packet Transmission Methods
+  */
+  void    sendLSUpdate(int lowerBound, int upperBound);       //send new LS Update
+  void    forward(fsr_rt_entry *rt,Packet *p, double delay);  //forward packet
+
+  /*
+    Packet Reception Methods
+  */
+  void            recvLSUpdate(Packet *p);
+
+
+  /*
+    Variables
+  */
+  Trace           *tracetarget;    // Trace Target
+  PriQueue        *ifqueue;        // link level output queue
+  u_int32_t       curr_seqno;      // Sequence number to advertise with...
+  nsaddr_t        my_addr;         // node's own address
+  bool            nbrsChanged;     // flag to determine changes in the neighbor list
+  bool            topoChanged;     // flag to determine changes in the topo table
+  /*
+    FSR LISTS
+  */
+  fsr_nbrlist     nbrhead;           // FSR neighbor list
+  fsr_wlist       whead;             // Iterationlist for FSR_Agent::findSP()
+
+  /*
+    Management of the FSR neighbor list
+  */
+  void            nbr_insert(nsaddr_t addr); //insert new neighbor into list
+  void            nbr_delete(nsaddr_t addr); //delete neighbor from list
+  int             nbr_size(void);            //get number of neighbors
+  void            nbr_purge(void);           //delete expired neighbors
+  FSR_Neighbor*   nbr_lookup(nsaddr_t addr); //get neighbor from list
+  int             nbrlist_size;              //contains current number of neighbors
+  /*
+    Management of the findSP() iteration list
+  */
+  void            w_insert(nsaddr_t addr, fsr_tt_entry*, fsr_rt_entry*);   //insert new node into list
+  void            w_delete(nsaddr_t addr);   //delete node from list
+  void            w_clear(void);             //remove all nodes from list
+  int             w_size(void);              //get number of nodes
+  fsr_wlist_entry*   w_lookup(nsaddr_t addr);   //get node from list
+  int             wlist_size;                //contains current size of list
+  /*
+    TABLES
+  */
+
+  fsr_ttable      ttable;
+  fsr_rtable      rtable;
+
+  /*
+    TOPO TABLE MANAGEMENT
+  */
+
+  void            tt_addOwnEntry(void);       //add own entry to Topology Table
+  void            tt_updateOwnEntry(void);    //update own entry in Topo Table
+  void            tt_purge(void);             //remove stale entries from topo table
+  /*
+    RT TABLE MANAGEMENT
+  */
+  void               rt_addOwnEntry(void);                   //add own entry to Routing Table
+  void               rt_initnbrnode(fsr_rt_entry*,nsaddr_t); //init entry for neighbored node
+  void               rt_initothernode(fsr_rt_entry*);        //init entry for other node
+  void               rt_replace(void);                       //calculate new RT Table
+  void               rt_findSP(void);                        //create shortest path tree
+  void               rt_resolve(Packet *p);                  //resolve route to destination
+  fsr_wlist_entry*   rt_getnxtentry(void);                   //get next entry for calculation in findSP()
+
+
+  /*
+    TIMERS
+  */
+
+  LSUpdateTimerS1 lstimerS1;
+  #ifdef SCOPE2_INTERVAL
+  LSUpdateTimerS2 lstimerS2;
+  #endif
+  #ifdef SCOPE3_INTERVAL
+  LSUpdateTimerS3 lstimerS3;
+  #endif
+  NbrPurgeTimer nbrtimer;
+
+  PortClassifier *port_dmux_;    // port dmux of wireless ns-2 node
+
+  /*
+    METHODS FOR DEBUGGING PURPOSES
+  */
+  void            show_nbrlist(void);
+  void            show_ttable(void);
+  void            show_rtable(void);
+  void            show_wlist(void);
+};
+
+#endif
diff -urN ns-2.34.original/fsr/fsr_nbrlist.h ns-2.34/fsr/fsr_nbrlist.h
--- ns-2.34.original/fsr/fsr_nbrlist.h	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/fsr/fsr_nbrlist.h	2005-01-11 18:12:14.000000000 +0800
@@ -0,0 +1,50 @@
+/***************************************************************************
+                    fsr_nbrlist.h  -  FSR Neighbor List
+                             -------------------
+    purpose              : Implementation of a Fisheye State Routing (FSR)
+                            module for ns-2 (vers. 2.27)
+    reference            : draft-ietf-manet-fsr-03.txt
+    begin                : Mon Aug 2 2004
+    copyright            : (C) 2004 by Sven Jaap
+      			   Institute of Operating Systems
+    			   and Computer Networks
+    			   Technical University of Braunschweig
+    			   Germany
+email                : jaap@ibr.cs.tu-bs.de
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ #ifndef __fsr_nbrlist_h__
+ #define __fsr_nbrlist_h__
+
+ #include <lib/bsd-list.h>
+ #include <sys/types.h>
+ #include <assert.h>
+ #include <scheduler.h>
+ #include <config.h>
+ #include <fsr/fsr_rtable.h>
+
+ /**
+    Entry of the neighbor list
+ **/
+
+class FSR_Neighbor {
+    friend class FSR_Agent;
+    friend class fsr_tt_entry;
+ public:
+    FSR_Neighbor(u_int32_t a) {nbr_addr = a;}
+ protected:
+    LIST_ENTRY(FSR_Neighbor)  nbr_link;
+    nsaddr_t                  nbr_addr;             // Address of neighbored node
+    double                    nbr_lastRecvTime;     // Last time a packet was received from neighbor
+};
+
+LIST_HEAD(fsr_nbrlist, FSR_Neighbor);
+#endif /* __fsr_nblist_h__ */
diff -urN ns-2.34.original/fsr/fsr_rtable.cc ns-2.34/fsr/fsr_rtable.cc
--- ns-2.34.original/fsr/fsr_rtable.cc	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/fsr/fsr_rtable.cc	2005-01-11 18:26:36.000000000 +0800
@@ -0,0 +1,116 @@
+/***************************************************************************
+                    fsr_rtable.cc  -  FSR Routing Table
+                             -------------------
+    purpose              : Implementation of a Fisheye State Routing (FSR)
+                            module for ns-2 (vers. 2.27)
+    reference            : draft-ietf-manet-fsr-03.txt
+    begin                : Thu Jul 29 2004
+    copyright            : (C) 2004 by Sven Jaap
+    			   Institute of Operating Systems
+    			   and Computer Networks
+    			   Technical University of Braunschweig
+    			   Germany
+    email                : jaap@ibr.cs.tu-bs.de
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+ #include <fsr/fsr_rtable.h>
+
+/*********************
+  Enry of the FSR routing table
+
+**********************/ 
+
+fsr_rt_entry::fsr_rt_entry(){
+
+
+}   
+
+/************************************
+   METHODS OF FSR_TTABLE
+*************************************/
+
+/****
+  Lookup entry of specific destination in table
+*****/
+fsr_rt_entry*
+fsr_rtable::rt_lookup(nsaddr_t addr)
+{
+  fsr_rt_entry *entry = rthead.lh_first;
+  for (;entry;entry = entry->rt_link.le_next){
+      if (entry->rt_dest == addr){
+         break;
+      }
+  }
+  return entry;
+}
+
+/****
+  Delete entry of specific destination in table
+*****/
+void
+fsr_rtable::rt_delete(nsaddr_t addr)
+{
+  fsr_rt_entry *entry = rt_lookup(addr);
+  if (entry){
+    LIST_REMOVE(entry, rt_link);
+    delete entry;
+  }
+}
+
+/****
+  Remove all entries from routing table (except own)
+*****/
+void
+fsr_rtable::rt_clear(nsaddr_t my_addr)
+{
+  fsr_rt_entry *entry;
+  while((entry = rthead.lh_first)){
+    LIST_REMOVE(entry, rt_link);
+    delete entry;
+  }
+  //rtable must always contain entry of own node
+  entry=rt_add(my_addr);
+  entry->rt_dist=0;
+  entry->rt_nexthop=my_addr;
+}
+
+/****
+  Remove unreachable destinations from table
+*****/
+void
+fsr_rtable::rt_purge()
+{
+  fsr_rt_entry *entry = rthead.lh_first;
+  fsr_rt_entry *next_entry;
+  for (;entry;entry = next_entry){
+      next_entry=entry->rt_link.le_next;
+      if (entry->rt_nexthop == -1){
+        //Destination is unreachable => remove it
+        rt_delete(entry->rt_dest);
+      }
+  }
+}
+
+
+/****
+  Add entry to the table
+*****/
+fsr_rt_entry*
+fsr_rtable::rt_add(nsaddr_t addr)
+{
+  fsr_rt_entry *entry;
+  entry = new fsr_rt_entry;
+  assert(entry);
+  entry->rt_dest=addr;
+  LIST_INSERT_HEAD(&rthead, entry, rt_link);
+  return entry;
+}
diff -urN ns-2.34.original/fsr/fsr_rtable.h ns-2.34/fsr/fsr_rtable.h
--- ns-2.34.original/fsr/fsr_rtable.h	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/fsr/fsr_rtable.h	2005-01-11 18:11:46.000000000 +0800
@@ -0,0 +1,74 @@
+/***************************************************************************
+              fsr_rtable.h  -  Header File of FSR Routing Table
+                             -------------------
+    purpose              : Implementation of a Fisheye State Routing (FSR)
+                            module for ns-2 (vers. 2.27)
+    reference            : draft-ietf-manet-fsr-03.txt
+    begin                : Thu Jul 29 2004
+    copyright            : (C) 2004 by Sven Jaap
+    			   Institute of Operating Systems
+    			   and Computer Networks
+    			   Technical University of Braunschweig
+    			   Germany
+    email                : jaap@ibr.cs.tu-bs.de
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+ #ifndef __fsr_rtable_h__
+ #define __fsr_rtable_h__
+
+ #include <lib/bsd-list.h>
+ #include <sys/types.h>
+ #include <assert.h>
+ #include <scheduler.h>
+ #include <config.h>
+
+ #define NOW  Scheduler::instance().clock()
+ #define UNREACHABLE2 0xff
+
+
+ /**
+    Entry of the routing table
+ **/
+
+ class fsr_rt_entry {
+        friend class fsr_rtable;
+        friend class FSR_Agent;
+ public:
+           fsr_rt_entry();
+ protected:
+           nsaddr_t   rt_dest;    //address of destination node
+           nsaddr_t   rt_nexthop; //address of the next hop node
+           u_int16_t  rt_dist;    //distance to the destination (hops)
+
+           LIST_ENTRY(fsr_rt_entry) rt_link;
+ };
+
+ /**
+    Representation of the FSR routing table
+ **/
+
+ class fsr_rtable {
+        friend class FSR_Agent;
+  public:
+          fsr_rtable()  { LIST_INIT(&rthead); }
+
+          fsr_rt_entry* head() { return rthead.lh_first; } 	//returns head of table (list)
+          fsr_rt_entry* rt_add(nsaddr_t addr);        	    // add entry to table
+          void          rt_delete(nsaddr_t addr);        	// remove entry form table
+          void          rt_clear(nsaddr_t my_addr);     	// remove all entries except own
+          void          rt_purge(void);             		// remove unreachable dest from table
+          fsr_rt_entry* rt_lookup(nsaddr_t addr);   	 	// lookup entry in table
+  private:
+          LIST_HEAD(fsr_rthead, fsr_rt_entry) rthead;
+ };
+
+#endif /* __fsr_rtable_h__ */
diff -urN ns-2.34.original/fsr/fsr_ttable.cc ns-2.34/fsr/fsr_ttable.cc
--- ns-2.34.original/fsr/fsr_ttable.cc	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/fsr/fsr_ttable.cc	2005-01-11 17:59:56.000000000 +0800
@@ -0,0 +1,150 @@
+/***************************************************************************
+                    fsr_ttable.cc  -  FSR Topology Table
+                             -------------------
+    purpose              : Implementation of a Fisheye State Routing (FSR)
+                            module for ns-2 (vers. 2.27)
+    reference            : draft-ietf-manet-fsr-03.txt
+    begin                : Mon Aug 2 2004
+    copyright            : (C) 2004 by Sven Jaap
+    			   Institute of Operating Systems
+    			   and Computer Networks
+    			   Technical University of Braunschweig
+    			   Germany
+    email                : jaap@ibr.cs.tu-bs.de
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+ #include <fsr/fsr_ttable.h>
+ 
+/***************************************
+  Enry of the FSR topology table
+***************************************/
+
+/*
+  Constructor
+*/
+fsr_tt_entry::fsr_tt_entry(){
+  //Initialize entry of Topo Table
+  tt_dest=0;
+  tt_destseq=0;
+  tt_lstheardtime=0;
+  tt_prevseq=0;
+  tt_needtosend=false;
+  LIST_INIT(&tt_nbrlist);
+  nbrlist_size=0;
+}
+/*
+  Destructor
+*/
+fsr_tt_entry::~fsr_tt_entry(){
+  FSR_Neighbor *nbr;
+  //remove all entries from the neighbor list
+  while((nbr=tt_nbrlist.lh_first)){
+    LIST_REMOVE(nbr,nbr_link);
+    delete nbr;
+  }
+}
+/********************************************
+   MANAGEMENT OF A DESTINATION's NEIGHBORS
+********************************************/
+
+/*
+  Insert new neighbor
+*/
+void
+fsr_tt_entry::nbr_insert(nsaddr_t addr){
+ FSR_Neighbor *nbr = new FSR_Neighbor(addr);
+ assert(nbr);
+ nbr->nbr_lastRecvTime=0; //not needed in Topo Table
+ LIST_INSERT_HEAD(&tt_nbrlist, nbr, nbr_link);
+ nbrlist_size++;
+}
+/*
+  Get neighbor from List
+*/
+FSR_Neighbor*
+fsr_tt_entry::nbr_lookup(nsaddr_t addr){
+ FSR_Neighbor *nbr = tt_nbrlist.lh_first;
+ for(;nbr;nbr=nbr->nbr_link.le_next){
+    if(nbr->nbr_addr==addr){
+      break;
+    }
+ }
+ return nbr;
+}
+/*
+    Get number of neighbors
+*/
+int
+fsr_tt_entry::nbr_size(){
+ return nbrlist_size;
+}
+/*
+    Clears the list of neighbors
+*/
+void
+fsr_tt_entry::nbr_clear(){
+ FSR_Neighbor *nbr;
+ //remove all entries from the neighbor list
+ while((nbr=tt_nbrlist.lh_first)){
+    LIST_REMOVE(nbr,nbr_link);
+    delete nbr;
+ }
+ nbrlist_size=0;
+}
+
+/***************************************
+   METHODS OF FSR_TTABLE
+***************************************/
+
+/****
+  Lookup entry of specific destination in table
+*****/
+fsr_tt_entry*
+fsr_ttable::tt_lookup(nsaddr_t addr)
+{
+  fsr_tt_entry *entry = tthead.lh_first;
+  for (;entry;entry = entry->tt_link.le_next){
+      if (entry->tt_dest == addr){
+         break;
+      }
+  }
+  return entry;
+}
+
+/****
+  Delete entry of specific destination in table
+*****/
+void
+fsr_ttable::tt_delete(nsaddr_t addr)
+{
+  fsr_tt_entry *entry = tt_lookup(addr);
+  if (entry){
+    LIST_REMOVE(entry, tt_link);
+    delete entry;
+  }
+}
+
+/****
+  Add entry to the table
+*****/
+fsr_tt_entry*
+fsr_ttable::tt_add(nsaddr_t addr)
+{
+  fsr_tt_entry *entry;
+  //ensure that destination is unknown so far
+  entry = new fsr_tt_entry;
+  assert(entry);
+  entry->tt_dest=addr;
+  entry->tt_needtosend=true;
+  LIST_INSERT_HEAD(&tthead, entry, tt_link);
+  return entry;
+}
diff -urN ns-2.34.original/fsr/fsr_ttable.h ns-2.34/fsr/fsr_ttable.h
--- ns-2.34.original/fsr/fsr_ttable.h	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/fsr/fsr_ttable.h	2005-01-11 18:11:56.000000000 +0800
@@ -0,0 +1,85 @@
+/***************************************************************************
+              fsr_ttable.h  -  Header File of FSR Topology Table
+                             -------------------
+    purpose              : Implementation of a Fisheye State Routing (FSR)
+                            module for ns-2 (vers. 2.27)
+    reference            : draft-ietf-manet-fsr-03.txt
+    begin                : Mon Aug 2 2004
+    copyright            : (C) 2004 by Sven Jaap
+    			   Institute of Operating Systems
+    			   and Computer Networks
+    			   Technical University of Braunschweig
+    			   Germany
+    email                : jaap@ibr.cs.tu-bs.de
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+ #ifndef __fsr_ttable_h__
+ #define __fsr_ttable_h__
+
+ #include <lib/bsd-list.h>
+ #include <sys/types.h>
+ #include <assert.h>
+ #include <scheduler.h>
+ #include <config.h>
+ #include <fsr/fsr_nbrlist.h>
+ #define NOW  Scheduler::instance().clock()
+
+
+
+ /**
+    Entry of the topology table
+ **/
+
+ class fsr_tt_entry {
+        friend class fsr_ttable;
+        friend class FSR_Agent;
+ public:
+           fsr_tt_entry();
+           ~fsr_tt_entry();
+
+           /*
+             Management of destination's neighbors
+           */
+           void           nbr_insert(nsaddr_t addr);
+           FSR_Neighbor*  nbr_lookup(nsaddr_t addr);
+           int            nbr_size(void);             //returns number of neighbors
+           void           nbr_clear(void);            //clears list of neigbors
+ protected:
+           nsaddr_t       tt_dest;        //address of destination node
+           u_int32_t      tt_destseq;     //destination sequence number
+           double         tt_lstheardtime;//last heard time
+           fsr_nbrlist    tt_nbrlist;     //list of destination's neighbors
+           int            nbrlist_size;   //contains number of node's neighbors
+           u_int32_t      tt_prevseq;     //previous sequence number
+           bool           tt_needtosend;  // "NeedToSend" Flag
+
+           LIST_ENTRY(fsr_tt_entry) tt_link;
+ };
+
+ /**
+    Representation of the FSR topology table
+ **/
+
+ class fsr_ttable {
+  friend class FSR_Agent;
+  public:
+          fsr_ttable()  { LIST_INIT(&tthead); }
+
+          fsr_tt_entry* head() { return tthead.lh_first; }  // returns head of table (list)
+          fsr_tt_entry* tt_add(nsaddr_t addr);              // add new entry to table
+          void          tt_delete(nsaddr_t addr);           // remove entry from table
+          fsr_tt_entry* tt_lookup(nsaddr_t addr);           // lookup entry in table
+  private:
+          LIST_HEAD(fsr_tthead, fsr_tt_entry) tthead;
+ };
+
+#endif /* __fsr_ttable_h__ */
diff -urN ns-2.34.original/fsr/fsr_wlist.h ns-2.34/fsr/fsr_wlist.h
--- ns-2.34.original/fsr/fsr_wlist.h	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/fsr/fsr_wlist.h	2005-01-11 18:12:30.000000000 +0800
@@ -0,0 +1,54 @@
+/***************************************************************************
+                    fsr_wlist.h  -  FSR Iteration List for findSP()
+                             -------------------
+    purpose              : Implementation of a Fisheye State Routing (FSR)
+                            module for ns-2 (vers. 2.27)
+    reference            : draft-ietf-manet-fsr-03.txt
+    begin                : Mon Aug 2 2004
+    copyright            : (C) 2004 by Sven Jaap
+    			   Institute of Operating Systems
+    			   and Computer Networks
+    			   Technical University of Braunschweig
+    			   Germany
+    email                : jaap@ibr.cs.tu-bs.de
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ #ifndef __fsr_wlist_h__
+ #define __fsr_wlist_h__
+
+ #include <lib/bsd-list.h>
+ #include <sys/types.h>
+ #include <assert.h>
+ #include <scheduler.h>
+ #include <config.h>
+ #include <fsr/fsr_rtable.h>
+ #include <fsr/fsr_ttable.h>
+ /**
+    Entry of the iteration list
+ **/
+
+class fsr_wlist_entry {
+    friend class FSR_Agent;
+    friend class fsr_tt_entry;
+    friend class fsr_rt_entry;
+ public:
+    fsr_wlist_entry(u_int32_t a, fsr_tt_entry* tt_ent, fsr_rt_entry* rt_ent) {node_addr = a;
+                            tt=tt_ent;
+                            rt=rt_ent;}
+ protected:
+    LIST_ENTRY(fsr_wlist_entry)  node_link;
+    nsaddr_t                     node_addr;             // Address of the node
+    fsr_tt_entry* tt;                                   // corresponding Topo Table entry
+    fsr_rt_entry* rt;                                   // corresponding Routing Table entry
+};
+
+LIST_HEAD(fsr_wlist, fsr_wlist_entry);
+#endif /* __fsr_wlist_h__ */
diff -urN ns-2.34.original/tcl/lib/ns-lib.tcl ns-2.34/tcl/lib/ns-lib.tcl
--- ns-2.34.original/tcl/lib/ns-lib.tcl	2009-06-15 01:35:42.000000000 +0800
+++ ns-2.34/tcl/lib/ns-lib.tcl	2012-08-08 16:38:22.296375000 +0800
@@ -1,2273 +1,2284 @@
-# -*-	Mode:tcl; tcl-indent-level:8; tab-width:8; indent-tabs-mode:t -*-
-#
-# Copyright (c) 1996 Regents of the University of California.
-# All rights reserved.
-# 
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions
-# are met:
-# 1. Redistributions of source code must retain the above copyright
-#    notice, this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright
-#    notice, this list of conditions and the following disclaimer in the
-#    documentation and/or other materials provided with the distribution.
-# 3. All advertising materials mentioning features or use of this software
-#    must display the following acknowledgement:
-# 	This product includes software developed by the MASH Research
-# 	Group at the University of California Berkeley.
-# 4. Neither the name of the University nor of the Research Group may be
-#    used to endorse or promote products derived from this software without
-#    specific prior written permission.
-# 
-# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
-# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
-# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-# SUCH DAMAGE.
-#
-
-# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/lib/ns-lib.tcl,v 1.277 2009/01/15 06:23:49 tom_henderson Exp $
-
-
-#
-# Word of warning to developers:
-# this code (and all it sources) is compiled into the
-# ns executable.  You need to rebuild ns or explicitly
-# source this code to see changes take effect.
-#
-
-
-
-proc warn {msg} {
-	global warned_
-	if {![info exists warned_($msg)]} {
-		puts stderr "warning: $msg"
-		set warned_($msg) 1
-	}
-}
-
-if {[info commands debug] == ""} {
-	proc debug args {
-		warn {Script debugging disabled.  Reconfigure with --with-tcldebug, and recompile.}
-	}
-}
-
-proc assert args {
-        if [catch "expr $args" ret] {
-                set ret [eval expr $args]
-        }
-        if {! $ret} {
-                error "assertion failed: $args"
-        }
-}
-
-proc find-max list {
-	set max 0
-	foreach val $list {
-		if {$val > $max} {
-			set max $val
-		}
-	}
-	return $max
-}
-
-proc bw_parse { bspec } {
-	if { [scan $bspec "%f%s" b unit] == 1 } {
-		set unit bps
-	}
-	regsub {[/p]s(ec)?$} $unit {} unit
-	if [string match {*B} $unit] {
-		set b [expr $b*8]
-		set unit "[string trimright $unit B]b"
-	}
-	switch $unit {
-		b { return $b }
-		kb { return [expr $b*1000] }
-		Mb { return [expr $b*1000000] }
-		Gb { return [expr $b*1000000000] }
-		default { 
-			puts "error: bw_parse: unknown unit `$unit'" 
-			exit 1
-		}
-	}
-}
-
-proc time_parse { spec } {
-	if { [scan $spec "%f%s" t unit] == 1 } {
-		set unit s
-	}
-	regsub {sec$} $unit {s} unit
-	switch $unit {
-		s { return $t }
-		ms { return [expr $t*1e-3] }
-		us { return [expr $t*1e-6] }
-		ns { return [expr $t*1e-9] }
-		ps { return [expr $t*1e-12] }
-		default { 
-			puts "error: time_parse: unknown unit `$unit'" 
-			exit 1
-		}
-	}
-}
-
-proc delay_parse { spec } {
-	return [time_parse $spec]
-}
-
-
-#
-# Create the core OTcl class called "Simulator".
-# This is the principal interface to the simulation engine.
-#
-#Class Simulator
-
-#
-# XXX Whenever you modify the source list below, please also change the
-# OTcl script dependency list in Makefile.in
-#
-source ns-autoconf.tcl
-source ns-address.tcl
-source ns-node.tcl
-source ns-rtmodule.tcl
-source ns-hiernode.tcl
-source ns-mobilenode.tcl
-source ns-bsnode.tcl
-source ns-link.tcl
-source ns-source.tcl
-source ns-compat.tcl
-source ns-packet.tcl
-source ns-queue.tcl
-source ns-trace.tcl
-source ns-random.tcl
-source ns-agent.tcl
-source ns-route.tcl
-source ns-errmodel.tcl
-source ns-intserv.tcl
-source ns-cmutrace.tcl
-source ns-mip.tcl
-source ns-sat.tcl
-#source ns-nix.tcl
-source ns-diffusion.tcl
-source ../rtp/session-rtp.tcl
-source ../interface/ns-iface.tcl
-source ../lan/ns-mac.tcl
-
-# Added by Sushmita to support event tracing for mac-simple and 802.11
-source ../lan/ns-mac-simple.tcl
-source ../lan/ns-mac-802_11.tcl
-
-source ../lan/ns-ll.tcl
-source ../lan/vlan.tcl
-source ../lan/abslan.tcl
-source ../mcast/timer.tcl
-source ../mcast/ns-mcast.tcl
-source ns-srcrt.tcl
-source ../mcast/McastProto.tcl
-source ../mcast/DM.tcl
-source ../ctr-mcast/CtrMcast.tcl
-source ../ctr-mcast/CtrMcastComp.tcl
-source ../ctr-mcast/CtrRPComp.tcl
-source ../mcast/BST.tcl
-source ../mcast/srm.tcl
-source ../mcast/srm-ssm.tcl
-# These files removed due to licensing conflicts
-# source ../mcast/mftp_snd.tcl
-# source ../mcast/mftp_rcv.tcl
-# source ../mcast/mftp_rcv_stat.tcl
-source ../mcast/McastMonitor.tcl
-source ../rlm/rlm.tcl
-source ../rlm/rlm-ns.tcl
-source ../session/session.tcl
-source ../webcache/http-server.tcl
-source ../webcache/http-cache.tcl
-source ../webcache/http-agent.tcl
-source ../webcache/http-mcache.tcl
-source ../webcache/webtraf.tcl
-source ../webcache/empweb.tcl
-source ns-namsupp.tcl
-source ../mobility/dsdv.tcl
-source ../mobility/dsr.tcl
-source ../mobility/com.tcl
-
-source ../plm/plm.tcl
-source ../plm/plm-ns.tcl
-source ../plm/plm-topo.tcl
-
-# MPLS
-source ../mpls/ns-mpls-simulator.tcl
-source ../mpls/ns-mpls-node.tcl
-source ../mpls/ns-mpls-ldpagent.tcl
-source ../mpls/ns-mpls-classifier.tcl
-
-source ns-default.tcl
-source ../emulate/ns-emulate.tcl
-
-#pushback
-source ns-pushback.tcl
-
-# PGM
-#source ../pgm/ns-pgm.tcl
-
-#LMS
-source ../mcast/ns-lms.tcl
-
-# STL dependent modules get included
-# ONLY when STL is found
-
-if {[ns-hasSTL] == 1} {
-source ns-nix.tcl
-source ../pgm/ns-pgm.tcl
-source ../rtglib/ns-rtProtoLS.tcl
-source ../delaybox/delaybox.tcl
-source ../packmime/packmime.tcl
-}
-
-source ns-qsnode.tcl
-
-# Obsolete modules
-#source ns-wireless-mip.tcl
-#source ns-nam.tcl
-
-Simulator instproc init args {
-
-	# Debojyoti added this for asim 
-
-	$self instvar useasim_
-	$self instvar slinks_
-	$self instvar nconn_
-	$self instvar sflows_
-	$self instvar nsflows_
-		
-	set slinks_(0:0) 0
-	set nconn_ 0
-	set conn_ ""
-	# for short flows stuff
-	set sflows_ "" 
-	set nsflows_ 0
-	set useasim_ 0
-
-	$self create_packetformat
-	$self use-scheduler Calendar
-	#$self use-scheduler List
-	$self set nullAgent_ [new Agent/Null]
-	$self set-address-format def
-	if {[lindex $args 0] == "-multicast"} {
-		$self multicast $args
-	}
-	eval $self next $args
-}
-
-Simulator instproc nullagent {} {
-	$self instvar nullAgent_
-	return $nullAgent_
-}
-
-Simulator instproc use-scheduler type {
-	$self instvar scheduler_
-	if [info exists scheduler_] {
-		if { [$scheduler_ info class] == "Scheduler/$type" } {
-			return
-		} else {
-			delete $scheduler_
-		}
-	}
-	set scheduler_ [new Scheduler/$type]
-	$scheduler_ now
-}
-
-Simulator instproc delay_parse { spec } {
-	return [time_parse $spec]
-}
-
-Simulator instproc bw_parse { spec } {
-	return [bw_parse $spec]
-}
-
-#
-# A simple method to wrap any object around
-# a trace object that dumps to stdout
-#
-Simulator instproc dumper obj {
-	set t [$self alloc-trace hop stdout]
-	$t target $obj
-	return $t
-}
-
-# New node structure
-#
-# Add APT to support multi-interface: user can specified multiple channels
-# when config nod. Still need modifications in routing agents to make
-# multi-interfaces really work.   -chen xuan  07/21/00
-#
-# Define global node configuration
-# $ns_ node-config -addressType flat/hierarchical
-#                  -adhocRouting   DSDV/DSR/TORA
-#                  -llType
-#                  -macType
-#                  -propType
-#                  -ifqType
-#                  -ifqLen
-#                  -phyType
-#                  -antType
-#		   -channel
-#                  -channelType
-#                  -topologyInstance
-#                  -wiredRouting   ON/OFF
-#                  -mobileIP       ON/OFF
-#                  -energyModel    "EnergyModel"
-#                  -initialEnergy  (in Joules)
-#                  -rxPower        (in W)
-#                  -txPower        (in W)
-#                  -idlePower      (in W)
-#
-#                  -sleepPower 	   (in W)
-#		   -sleepTime	   (in sec indicating when the node can start sleeping)
-#                  -agentTrace  ON
-#                  -routerTrace ON 
-#                  -macTrace OFF 
-#                  -phyTrace OFF 
-#                  -toraDebug OFF                
-#                  -movementTrace OFF
-# change wrt Mike's code
-#                  -eotTrace OFF
-#                  -diffusionFilter "GradientFilter/OnePhasePullFilter/GeoRoutingFilter/RmstFilter/SourceRouteFilter/LogFilter/TagFilter"
-
-
-Simulator instproc addressType  {val} { $self set addressType_  $val }
-Simulator instproc adhocRouting  {val} { $self set routingAgent_  $val }
-Simulator instproc llType  {val} { $self set llType_  $val }
-Simulator instproc macType  {val} { $self set macType_  $val }
-Simulator instproc propType  {val} { $self set propType_  $val }
-Simulator instproc propInstance  {val} { $self set propInstance_  $val }
-Simulator instproc ifqType  {val} { $self set ifqType_  $val }
-Simulator instproc ifqLen  {val} { $self set ifqlen_  $val }
-Simulator instproc phyType  {val} { $self set phyType_  $val }
-Simulator instproc antType  {val} { $self set antType_  $val }
-Simulator instproc channel {val} {$self set channel_ $val}
-Simulator instproc channelType {val} {$self set channelType_ $val}
-Simulator instproc topoInstance {val} {$self set topoInstance_ $val}
-Simulator instproc wiredRouting {val} {$self set wiredRouting_ $val}
-Simulator instproc mobileIP {val} {$self set mobileIP_ $val}
-Simulator instproc energyModel  {val} { $self set energyModel_  $val }
-Simulator instproc initialEnergy  {val} { $self set initialEnergy_  $val }
-Simulator instproc txPower  {val} { $self set txPower_  $val }
-Simulator instproc rxPower  {val} { $self set rxPower_  $val }
-Simulator instproc idlePower  {val} { $self set idlePower_  $val }
-#
-Simulator instproc sleepPower  {val} { $self set sleepPower_  $val }
-Simulator instproc sleepTime  {val} { $self set sleepTime_  $val }
-Simulator instproc transitionPower  {val} { $self set transitionPower_  $val }
-Simulator instproc transitionTime  {val} { $self set transitionTime_  $val }
-#
-Simulator instproc IncomingErrProc  {val} { $self set inerrProc_  $val }
-Simulator instproc OutgoingErrProc  {val} { $self set outerrProc_  $val }
-Simulator instproc FECProc  {val} { $self set FECProc_  $val }
-Simulator instproc agentTrace  {val} { $self set agentTrace_  $val }
-Simulator instproc routerTrace  {val} { $self set routerTrace_  $val }
-Simulator instproc macTrace  {val} { $self set macTrace_  $val }
-Simulator instproc phyTrace  {val} { $self set phyTrace_  $val }
-Simulator instproc movementTrace  {val} { $self set movementTrace_  $val }
-Simulator instproc toraDebug {val} {$self set toraDebug_ $val }
-Simulator instproc satNodeType {val} {$self set satNodeType_ $val}
-Simulator instproc downlinkBW {val} {$self set downlinkBW_ $val}
-Simulator instproc stopTime {val} {$self set stopTime_ $val}
-
-# This method is needed so that new Routing Agents can be implemented in a dynamic
-# library and used without having to modify Simulator::create-wireless-node
-Simulator instproc rtAgentFunction {val} {$self set rtAgentFunction_ $val}
-
-
-# change wrt Mike's code
-Simulator instproc eotTrace  {val} { $self set eotTrace_  $val }
-Simulator instproc diffusionFilter {val} {$self set diffFilter_ $val}
-
-Simulator instproc MPLS { val } { 
-	if { $val == "ON" } {
-		Node enable-module "MPLS"
-	} else {
-		Node disable-module "MPLS"
-	}
-}
-
-
-Simulator instproc PGM { val } { 
-        if { $val == "ON" } {
-                Node enable-module "PGM"
-        } else {
-                Node disable-module "PGM"
-        }
-}
-Simulator instproc LMS { val } {
-	if { $val == "ON" } {
-		Node enable-module "LMS"
-	} else {
-		Node disable-module "LMS"
-	}
-}
-
-Simulator instproc get-nodetype {} {
-	$self instvar addressType_ routingAgent_ wiredRouting_ 
-	set val ""
-
-	if { [info exists addressType_] && $addressType_ == "hierarchical" } {
-		set val Hier
-	}
-	if { [info exists routingAgent_] && $routingAgent_ != "" } {
-		set val Mobile
-	}
-	if { [info exists wiredRouting_] && $wiredRouting_ == "ON" } {
-		set val Base
-	}
-	if { [info exists wiredRouting_] && $wiredRouting_ == "OFF"} {
-		set val Base
-	}
-	if { [Simulator set mobile_ip_] } {
-		if { $val == "Base" && $wiredRouting_ == "ON" } {
-			set val MIPBS
-		}
-		if { $val == "Base" && $wiredRouting_ == "OFF" } {
-			set val MIPMH
-		}
-	}
-	return $val
-}
-
-Simulator instproc node-config args {
-        # Object::init-vars{} is defined in ~tclcl/tcl-object.tcl.
-        # It initializes all default variables in the following way:
-        #  1.  Look for pairs of {-cmd val} in args
-        #  2.  If "$self $cmd $val" is not valid then put it in a list of 
-        #      arguments to be returned to the caller.
-        # 
-        # Since we do not handle undefined {-cmd val} pairs, we ignore 
-        # return value from init-vars{}.
-        set args [eval $self init-vars $args]
-
-        $self instvar addressType_  routingAgent_ propType_  macTrace_ \
-	    routerTrace_ agentTrace_ movementTrace_ channelType_ channel_ \
-	    chan topoInstance_ propInstance_ mobileIP_ \
-	    rxPower_ txPower_ idlePower_ sleepPower_ sleepTime_ transitionPower_ \
-	    transitionTime_ satNodeType_ eotTrace_ phyTrace_
-
-	if [info exists phyTrace_] {
-		Simulator set PhyTrace_ $phyTrace_
-	}
-
-
-        if [info exists macTrace_] {
-		Simulator set MacTrace_ $macTrace_
-	}
-        if [info exists routerTrace_] {
-		Simulator set RouterTrace_ $routerTrace_
-	}
-        if [info exists agentTrace_] {
-		Simulator set AgentTrace_ $agentTrace_
-	}
-        if [info exists movementTrace_] {
-		Simulator set MovementTrace_ $movementTrace_
-	}
-
-	# change wrt Mike's code
-	if [info exists eotTrace_] {
-                Simulator set EotTrace_ $eotTrace_
-        }
-
-        # hacking for matching old cmu add-interface
-        # not good style, for back-compability ONLY
-	#
-	# Only create 1 instance of prop
-	if {[info exists propInstance_]} {
-		if {[info exists propType_] && [Simulator set propInstCreated_] == 0} {
-			warn "Both propType and propInstance are set. propType is ignored."
-		}
-	} else {
-		if {[info exists propType_]} {
-			set propInstance_ [new $propType_]
-			Simulator set propInstCreated_ 1
-		}
-	}
-	
-	# Add multi-interface support:
- 	# User can only specify either channelType_ (single_interface as 
-	# before) or channel_ (multi_interface)
- 	# If both variables are specified, error!
- 	if {[info exists channelType_] && [info exists channel_]} { 
-		error "Can't specify both channel and channelType, error!"
-	} elseif {[info exists channelType_] && ![info exists satNodeType_]} {
-		# Single channel, single interface
-		warn "Please use -channel as shown in tcl/ex/wireless-mitf.tcl"
-		if {![info exists chan]} {
-			set chan [new $channelType_]
-		}
- 	} elseif {[info exists channel_]} {
-		# Multiple channel, multiple interfaces
-		set chan $channel_
- 	}
-	if [info exists topoInstance_] {
-		$propInstance_  topography $topoInstance_
-	}
-	# set address type, hierarchical or expanded
-	if {[string compare $addressType_ ""] != 0} {
-		$self set-address-format $addressType_ 
-	}
-	# set mobileIP flag
-	if { [info exists mobileIP_] && $mobileIP_ == "ON"} {
-		Simulator set mobile_ip_  1
-	} else {
-		if { [info exists mobileIP_] } {
-			Simulator set mobile_ip_ 0
-		}
-	}
-}
-
-# Default behavior is changed: consider nam as not initialized if 
-# no shape OR color parameter is given
-Simulator instproc node args {
-	$self instvar Node_ routingAgent_ wiredRouting_ satNodeType_
-        if { [Simulator info vars EnableMcast_] != "" } {
-                warn "Flag variable Simulator::EnableMcast_ discontinued.\n\t\
-                      Use multicast methods as:\n\t\t\
-                        % set ns \[new Simulator -multicast on]\n\t\t\
-                        % \$ns multicast"
-                $self multicast
-                Simulator unset EnableMcast_
-        }
-        if { [Simulator info vars NumberInterfaces_] != "" } {
-                warn "Flag variable Simulator::NumberInterfaces_ discontinued.\n\t\
-                      Setting this variable will not affect simulations."
-                Simulator unset NumberInterfaces_
-        }
-
-	# Satellite node
-	if { [info exists satNodeType_] } {
-		set node [eval $self create-satnode]
-		#simulator's nodelist in C++ space
-		if {[info exists wiredRouting_] && $wiredRouting_ == "ON"} {
-			# add node to simulator's nodelist in C++ space
-			$self add-node $node [$node id]
-			# Want to keep global state of wiredRouting info
-			SatRouteObject set wiredRouting_ true
-		}
-		return $node
-	}
-	
-	# wireless-ready node
-	if { [info exists routingAgent_] && ($routingAgent_ != "") } {
-		set node [eval $self create-wireless-node $args]
-		# for base node
-		if {[info exists wiredRouting_] && $wiredRouting_ == "ON"} {
-			set Node_([$node id]) $node
-			#simulator's nodelist in C++ space
-			$self add-node $node [$node id] 
-		}
-		return $node
-	}
-	
-
-	# Enable-mcast is now done automatically inside Node::init{}
-	# 
-	# XXX node_factory_ is deprecated, HOWEVER, since it's still used by
-	# mobile IP, algorithmic routing, manual routing, and backward 
-	# compability tests of hierarchical routing, we should keep it around
-	# before all related code are wiped out.
-	set node [eval new [Simulator set node_factory_] $args]
-	set Node_([$node id]) $node
-	
-	#add to simulator's nodelist in C++ space
-	$self add-node $node [$node id] 
-
-	#set the nodeid in c++ Node - ratul
-	$node nodeid [$node id]
-
-	$node set ns_ $self
-	$self check-node-num
-	return $node
-}
-
-# XXX This is stupid hack. When old code (not using node-config) is used, 
-# create-wireless-node{} will not be called, and IMEPFlag_ will remain empty
-# (as set in ns-default.tcl), then Node/MobileNode will use global proc 
-# cmu-trace to create trace objects; otherwise mobility-trace{} will be 
-# triggered.
-Simulator instproc imep-support {} {
-	return [Simulator set IMEPFlag_]
-}
-
-# XXX This should be moved into the node initialization procedure instead 
-# of standing here in ns-lib.tcl.
-Simulator instproc create-wireless-node args {
-        $self instvar routingAgent_ wiredRouting_ propInstance_ llType_ \
-	    macType_ ifqType_ ifqlen_ phyType_ chan antType_ \
-	    energyModel_ initialEnergy_ txPower_ rxPower_ \
-	    idlePower_ sleepPower_ sleepTime_ transitionPower_ transitionTime_ \
-	    topoInstance_ level1_ level2_ inerrProc_ outerrProc_ FECProc_ rtAgentFunction_
-
-	Simulator set IMEPFlag_ OFF
-
-        # create node instance
-        set node [eval $self create-node-instance $args]
-        
-        # basestation address setting
-        if { [info exist wiredRouting_] && $wiredRouting_ == "ON" } {
-		$node base-station [AddrParams addr2id [$node node-addr]]
-    	}
-        if {$rtAgentFunction_ != ""} {
-		set ragent [$self $rtAgentFunction_ $node]
-	} else {
-		switch -exact $routingAgent_ {
-		    DSDV {
-			    set ragent [$self create-dsdv-agent $node]
-		    }
-		    DSR {
-			    $self at 0.0 "$node start-dsr"
-		    }
-		    AODV {
-			    set ragent [$self create-aodv-agent $node]
-		    }
-		    AOMDV {
-			    set ragent [$self create-aomdv-agent $node]
-		    }
-		    TORA {
-			    Simulator set IMEPFlag_ ON
-			    set ragent [$self create-tora-agent $node]
-		    }
-		    DIFFUSION/RATE {
-			    eval $node addr $args
-			    set ragent [$self create-diffusion-rate-agent $node]
-		    }
-		    DIFFUSION/PROB {
-			    eval $node addr $args
-			    set ragent [$self create-diffusion-probability-agent $node]
-		    }
-		    Directed_Diffusion {
-			    eval $node addr $args
-			    set ragent [$self create-core-diffusion-rtg-agent $node]
-		    }
-		    FLOODING {
-			    eval $node addr $args
-			    set ragent [$self create-flooding-agent $node]
-		    }
-		    OMNIMCAST {
-			    eval $node addr $args
-			    set ragent [$self create-omnimcast-agent $node]
-		    }
-		    DumbAgent {
-			    set ragent [$self create-dumb-agent $node]
-		    }
-		    ManualRtg {
-			    set ragent [$self create-manual-rtg-agent $node]
-		    }
-		    default {
-			    eval $node addr $args
-			    puts "Wrong node routing agent!"
-			    exit
-		    }
-		}
-	}
-
-	# errProc_ and FECProc_ are an option unlike other 
-        # parameters for node interface
-	if ![info exist inerrProc_] {
-		set inerrProc_ ""
-	}
-	if ![info exist outerrProc_] {
-		set outerrProc_ ""
-	}
-	if ![info exist FECProc_] {
-		set FECProc_ ""
-	}
-
-	
-
-	# Add main node interface
-	$node add-interface $chan $propInstance_ $llType_ $macType_ \
-	    $ifqType_ $ifqlen_ $phyType_ $antType_ $topoInstance_ \
-			$inerrProc_ $outerrProc_ $FECProc_
-	# Attach agent
-	if {$routingAgent_ != "DSR"} {
-		$node attach $ragent [Node set rtagent_port_]
-	}
-	if {$routingAgent_ == "DIFFUSION/RATE" ||
-            $routingAgent_ == "DIFFUSION/PROB" ||
-            $routingAgent_ == "FLOODING" ||
-            $routingAgent_ == "OMNIMCAST" ||
-	    $routingAgent_ == "Directed_Diffusion" } {
-		$ragent port-dmux [$node demux]
-		$node instvar ll_
-		$ragent add-ll $ll_(0)
-	}
-	if { $routingAgent_ == "DumbAgent" } {
-		$ragent port-dmux [$node demux]
-	}
-	
-
-	# Bind routing agent and mip agent if existing basestation 
-	# address setting
-        if { [info exist wiredRouting_] && $wiredRouting_ == "ON" } {
-		if { $routingAgent_ != "DSR" } {
-			$node mip-call $ragent
-		}
-	}
-	#
-        # This Trace Target is used to log changes in direction
-        # and velocity for the mobile node.
-        #
-	set tracefd [$self get-ns-traceall]
-        if {$tracefd != "" } {
-		$node nodetrace $tracefd
-		$node agenttrace $tracefd
-	}
-	set namtracefd [$self get-nam-traceall]
-	if {$namtracefd != "" } {
-		$node namattach $namtracefd
-	}
-	if [info exists energyModel_] {
-		if  [info exists level1_] {
-			set l1 $level1_
-		} else {
-			set l1 0.5
-		}
-		if  [info exists level2_] {
-			set l2 $level2_
-		} else {
-			set l2 0.2
-		}
-		$node addenergymodel [new $energyModel_ $node \
-				$initialEnergy_ $l1 $l2]
-        }
-        if [info exists txPower_] {
-		$node setPt $txPower_
-        }
-        if [info exists rxPower_] {
-		$node setPr $rxPower_
-        }
-        if [info exists idlePower_] {
-		$node setPidle $idlePower_
-        }
-#
-	if [info exists sleepPower_] {
-		$node setPsleep $sleepPower_
-        }
-	if [info exists sleepTime_] {
-		$node setTSleep $sleepTime_
-        }
-	if [info exists transitionPower_] {
-		$node setPtransition $transitionPower_
-        }
-	if [info exists transitionTime_] {
-		$node setTtransition $transitionTime_
-        }	
-#
-	$node topography $topoInstance_
-	
-	return $node
-}
-
-Simulator instproc create-node-instance args {
-	$self instvar routingAgent_
-	# DSR is a special case
-	if {$routingAgent_ == "DSR"} {
-		set nodeclass [$self set-dsr-nodetype]
-	} else {
-		set nodeclass Node/MobileNode
-	}
-	return [eval new $nodeclass $args]
-}
-
-Simulator instproc set-dsr-nodetype {} {
-	$self instvar wiredRouting_ 
-	set nodetype SRNodeNew
-	# MIP mobilenode
-	if [Simulator set mobile_ip_] {
-		set nodetype SRNodeNew/MIPMH
-	} 
-	# basestation dsr node
-	if { [info exists wiredRouting_] && $wiredRouting_ == "ON"} {
-		set nodetype Node/MobileNode/BaseStationNode
-	}
-	return $nodetype
-}
-
-Simulator instproc create-tora-agent { node } {
-        set ragent [new Agent/TORA [$node id]]
-	$node set ragent_ $ragent
-	return $ragent
-}
-
-Simulator instproc create-dsdv-agent { node } {
-	# Create a dsdv routing agent for this node
-	set ragent [new Agent/DSDV]
-	# Setup address (supports hier-addr) for dsdv agent
-	# and mobilenode
-	set addr [$node node-addr]
-	$ragent addr $addr
-	$ragent node $node
-	if [Simulator set mobile_ip_] {
-		$ragent port-dmux [$node demux]
-	}
-	$node addr $addr
-	$node set ragent_ $ragent
-	$self at 0.0 "$ragent start-dsdv"    ;# start updates
-	return $ragent
-}
-
-
-Simulator instproc create-dumb-agent { node } {
-	
-	# create a simple wireless agent
-	# that only forwards packets
-	# used for testing single hop brdcast/unicast mode 
-	# for wireless macs
-
-	set ragent [new Agent/DumbAgent]
-	$node set ragent_ $ragent
-	
-	return $ragent
-}
-
-Simulator instproc create-manual-rtg-agent { node } {
-	
-	# create a simple wireless agent
-	# that only forwards packets
-	# used for testing single hop brdcast/unicast mode 
-	# for wireless macs
-
-	set ragent [new Agent/ManualRtgAgent]
-	$node set ragent_ $ragent
-	$node attach $ragent [Node set rtagent_port_]
-	
-	return $ragent
-}
-
-Simulator instproc create-aodv-agent { node } {
-        #  Create AODV routing agent
-	set ragent [new Agent/AODV [$node node-addr]]
-        $self at 0.0 "$ragent start"     ;# start BEACON/HELLO Messages
-        $node set ragent_ $ragent
-        return $ragent
-}
-
-# AOMDV patch
-Simulator instproc create-aomdv-agent { node } {
-	set ragent [new Agent/AOMDV [$node node-addr]]
-	$self at 0.0 "$ragent start"
-	$node set ragent_ $ragent
-	return $ragent
-}
-
-Simulator instproc use-newtrace {} {
-	Simulator set WirelessNewTrace_ 1
-} 
-
-Simulator instproc use-taggedtrace { {tag ON} } {
-	Simulator set TaggedTrace_ $tag
-}
-
-Simulator instproc hier-node haddr {
- 	error "hier-nodes should be created with [$ns_ node $haddr]"
-}
-
-Simulator instproc now {} {
-	$self instvar scheduler_
-	return [$scheduler_ now]
-}
-
-Simulator instproc at args {
-	$self instvar scheduler_
-	return [eval $scheduler_ at $args]
-}
-
-Simulator instproc at-now args {
-	$self instvar scheduler_
-	return [eval $scheduler_ at-now $args]
-}
-
-Simulator instproc cancel args {
-	$self instvar scheduler_
-	return [eval $scheduler_ cancel $args]
-}
-
-Simulator instproc after {ival args} {
-        eval $self at [expr [$self now] + $ival] $args
-}
-
-#
-# check if total num of nodes exceed 2 to the power n 
-# where <n=node field size in address>
-#
-Simulator instproc check-node-num {} {
-	if {[Node set nn_] > [expr pow(2, [AddrParams nodebits])]} {
-		error "Number of nodes exceeds node-field-size of [AddrParams nodebits] bits"
-	}
-}
-
-#
-# Check if number of items at each hier level (num of nodes, or clusters or
-# domains) exceed size of that hier level field size (in bits). should be 
-# modified to support n-level of hierarchies
-#
-Simulator instproc chk-hier-field-lengths {} {
-	AddrParams instvar domain_num_ cluster_num_ nodes_num_
-	if [info exists domain_num_] {
-		if {[expr $domain_num_ - 1]> [AddrParams NodeMask 1]} {
-			error "\# of domains exceed dom-field-size "
-		}
-	} 
-	if [info exists cluster_num_] {
-		set maxval [expr [find-max $cluster_num_] - 1] 
-		if {$maxval > [expr pow(2, [AddrParams NodeMask 2])]} {
-			error "\# of clusters exceed clus-field-size "
-		}
-	}
-	if [info exists nodes_num_] {
-		set maxval [expr [find-max $nodes_num_] -1]
-		if {$maxval > [expr pow(2, [AddrParams NodeMask 3])]} {
-			error "\# of nodess exceed node-field-size"
-		}
-	}
-}
-
-
-Simulator instproc check-smac {} {
-	$self instvar macType_
-	if { [info exist macType_] && $macType_ == "Mac/SMAC" } {
-		if { [$macType_ set syncFlag_] } {
-			puts "\nNOTE: SMAC is running with sleep-wakeup cycles on. Please make sure to run yr applications AFTER the nodes get sync'ed which is about 40sec for the default settings.\n"
-		}
-	}
-}
-			
-
-Simulator instproc run {} {
-	# NIXVECTOR?
-	# global runstart
-	# set runstart [clock seconds]
-	$self check-smac                      ;# print warning if in sleep/wakeup cycle
-	$self check-node-num
-	$self rtmodel-configure			;# in case there are any
-	[$self get-routelogic] configure
-	$self instvar scheduler_ Node_ link_ started_ 
-	
-	set started_ 1
-	
-	#
-	# Reset every node, which resets every agent.
-	#
-
-	foreach nn [array names Node_] {
-		$Node_($nn) reset
-		# GFR Additions for NixVector Routing
-		if { [Simulator set nix-routing] } {
-			$Node_($nn) populate-objects
-		}
-	}
-
-	#
-	# Also reset every queue
-	#
-
-	foreach qn [array names link_] {
-		set q [$link_($qn) queue]
-		$q reset
-	}
-
-	# Do all nam-related initialization here
-	$self init-nam
-
-	# NIXVECTOR xxx?
-	# global simstart
-	# set simstart [clock seconds]
-	return [$scheduler_ run]
-}
-
-# johnh xxx?
-Simulator instproc log-simstart { } {
-        # GFR Modification to log actual start
-        global simstart
-        puts "Starting Actual Simulation"
-        set simstart [clock seconds]
-}
-
-Simulator instproc halt {} {
-	$self instvar scheduler_
-	#puts "time: [clock format [clock seconds] -format %X]"
-	$scheduler_ halt
-}
-
-Simulator instproc dumpq {} {
-	$self instvar scheduler_
-	$scheduler_ dumpq
-}
-
-Simulator instproc is-started {} {
-	$self instvar started_
-	return [info exists started_]
-}
-
-Simulator instproc clearMemTrace {} {
-	$self instvar scheduler_
-	$scheduler_ clearMemTrace
-}
-
-Simulator instproc simplex-link { n1 n2 bw delay qtype args } {
-	$self instvar link_ queueMap_ nullAgent_ useasim_
-	set sid [$n1 id]
-	set did [$n2 id]
-
-	# Debo
-	if { $useasim_ == 1 } {
-		set slink_($sid:$did) $self
-	}
-
-	if [info exists queueMap_($qtype)] {
-		set qtype $queueMap_($qtype)
-	}
-	# construct the queue
-	set qtypeOrig $qtype
-	switch -exact $qtype {
-		ErrorModule {
-			if { [llength $args] > 0 } {
-				set q [eval new $qtype $args]
-			} else {
-				set q [new $qtype Fid]
-			}
-		}
-		intserv {
-			set qtype [lindex $args 0]
-			set q [new Queue/$qtype]
-		}
-		default {
-			if { [llength $args] == 0} {
-				set q [new Queue/$qtype]
-			} else {
-				set q [new Queue/$qtype $args]
-			}
-		}
-	}
-	# Now create the link
-	switch -exact $qtypeOrig {
-		RTM {
-                        set c [lindex $args 1]
-                        set link_($sid:$did) [new CBQLink       \
-                                        $n1 $n2 $bw $delay $q $c]
-                }
-                CBQ -
-                CBQ/WRR {
-                        # assume we have a string of form "linktype linkarg"
-                        if {[llength $args] == 0} {
-                                # default classifier for cbq is just Fid type
-                                set c [new Classifier/Hash/Fid 33]
-                        } else {
-                                set c [lindex $args 0]
-                        }
-                        set link_($sid:$did) [new CBQLink       \
-                                        $n1 $n2 $bw $delay $q $c]
-                }
-		FQ      {
-			set link_($sid:$did) [new FQLink $n1 $n2 $bw $delay $q]
-		}
-                intserv {
-                        #XX need to clean this up
-                        set link_($sid:$did) [new IntServLink   \
-                                        $n1 $n2 $bw $delay $q	\
-						[concat $qtypeOrig $args]]
-                }
-                default {
-                        set link_($sid:$did) [new SimpleLink    \
-                                        $n1 $n2 $bw $delay $q]
-                }
-        }
-	if {$qtype == "RED/Pushback"} {
-		set pushback 1
-	} else {
-		set pushback 0
-	}
-	$n1 add-neighbor $n2 $pushback
-	
-	#XXX yuck
-	if {[string first "RED" $qtype] != -1 || 
-	    [string first "PI" $qtype] != -1 || 
-	    [string first "Vq" $qtype] != -1 ||
-	    [string first "REM" $qtype] != -1 ||  
-	    [string first "GK" $qtype] != -1 ||  
-	    [string first "RIO" $qtype] != -1 ||
-	    [string first "XCP" $qtype] != -1} {
-		$q link [$link_($sid:$did) set link_]
-	}
-
-	set trace [$self get-ns-traceall]
-	if {$trace != ""} {
-		$self trace-queue $n1 $n2 $trace
-	}
-	set trace [$self get-nam-traceall]
-	if {$trace != ""} {
-		$self namtrace-queue $n1 $n2 $trace
-	}
-	
-	# Register this simplex link in nam link list. Treat it as 
-	# a duplex link in nam
-	$self register-nam-linkconfig $link_($sid:$did)
-}
-
-#
-# This is used by Link::orient to register/update the order in which links 
-# should created in nam. This is important because different creation order
-# may result in different layout.
-#
-# A poor hack. :( Any better ideas?
-#
-Simulator instproc register-nam-linkconfig link {
-	$self instvar linkConfigList_ link_
-	if [info exists linkConfigList_] {
-		# Check whether the reverse simplex link is registered,
-		# if so, don't register this link again.
-		# We should have a separate object for duplex link.
-		set i1 [[$link src] id]
-		set i2 [[$link dst] id]
-		if [info exists link_($i2:$i1)] {
-			set pos [lsearch $linkConfigList_ $link_($i2:$i1)]
-			if {$pos >= 0} {
-				set a1 [$link_($i2:$i1) get-attribute \
-						"ORIENTATION"]
-				set a2 [$link get-attribute "ORIENTATION"]
-				if {$a1 == "" && $a2 != ""} {
-					# If this duplex link has not been 
-					# assigned an orientation, do it.
-					set linkConfigList_ [lreplace \
-						$linkConfigList_ $pos $pos]
-				} else {
-					return
-				}
-			}
-		}
-		# Remove $link from list if it's already there
-		set pos [lsearch $linkConfigList_ $link]
-		if {$pos >= 0} {
-			set linkConfigList_ \
-					[lreplace $linkConfigList_ $pos $pos]
-		}
-	}
-	lappend linkConfigList_ $link
-}
-
-#
-# GT-ITM may occasionally generate duplicate links, so we need this check
-# to ensure duplicated links do not appear in nam trace files.
-#
-Simulator instproc remove-nam-linkconfig {i1 i2} {
-	$self instvar linkConfigList_ link_
-	if ![info exists linkConfigList_] {
-		return
-	}
-	set pos [lsearch $linkConfigList_ $link_($i1:$i2)]
-	if {$pos >= 0} {
-		set linkConfigList_ [lreplace $linkConfigList_ $pos $pos]
-		return
-	}
-	set pos [lsearch $linkConfigList_ $link_($i2:$i1)]
-	if {$pos >= 0} {
-		set linkConfigList_ [lreplace $linkConfigList_ $pos $pos]
-	}
-}
-
-# Armando L. Caro Jr. <acaro@@cis,udel,edu> 10/22/2001
-#
-# we create a simplex link (NOT duplex) from the core to the interface. we can
-# use arbitrary params (bw, delay, etc) since we'll never actually transmit
-# data on these links. they are only used for routing (ie, to determine which 
-# interface a packet should go out from)
-#
-Simulator instproc multihome-add-interface { core if } {
-  	$self instvar link_
-  	set coreId [$core id]
-  	set ifId [$if id]
-
-	# arbitrary values (doesn't matter since link will NEVER be used!)
-	set bw 1Mb
-	set delay 100ms
-	set type DropTail
-
-	if [info exists link_($coreId:$ifId)] {
-		$self remove-nam-linkconfig $coreId $ifId
-	}
-	eval $self simplex-link $core $if $bw $delay $type 
-	# Modified by GFR for nix-vector routing
-	if { [Simulator set nix-routing] } {
-		# Inform nodes of neighbors
-		$n1 set-neighbor [$core id]
-		$n2 set-neighbor [$if id]
-	}
-
-
-    	$core instvar multihome_interfaces_ num_interfaces_
-    	set interface_ {}
-
-    	# interface node
-    	lappend interface_ $if
-
-    	# link from interface node to core node
-    	lappend interface_ [$link_($coreId:$ifId) set head_]
-
-    	lappend multihome_interfaces_ $interface_
-}
-
-Simulator instproc duplex-link { n1 n2 bw delay type args } {
-	$self instvar link_
-	set i1 [$n1 id]
-	set i2 [$n2 id]
-	if [info exists link_($i1:$i2)] {
-		$self remove-nam-linkconfig $i1 $i2
-	}
-	eval $self simplex-link $n1 $n2 $bw $delay $type $args
-	eval $self simplex-link $n2 $n1 $bw $delay $type $args
-	# Modified by GFR for nix-vector routing
-	if { [Simulator set nix-routing] } {
-		# Inform nodes of neighbors
-		$n1 set-neighbor [$n2 id]
-		$n2 set-neighbor [$n1 id]
-	}
-}
-
-Simulator instproc duplex-intserv-link { n1 n2 bw pd sched signal adc args } {
-	eval $self duplex-link $n1 $n2 $bw $pd intserv $sched $signal $adc $args
-}
-
-Simulator instproc simplex-link-op { n1 n2 op args } {
-	$self instvar link_
-	eval $link_([$n1 id]:[$n2 id]) $op $args
-}
-
-Simulator instproc duplex-link-op { n1 n2 op args } {
-	$self instvar link_
-	eval $link_([$n1 id]:[$n2 id]) $op $args
-	eval $link_([$n2 id]:[$n1 id]) $op $args
-}
-
-Simulator instproc flush-trace {} {
-	$self instvar alltrace_
-	if [info exists alltrace_] {
-		foreach trace $alltrace_ {
-			$trace flush
-		}
-	}
-}
-
-Simulator instproc namtrace-all file   {
-	$self instvar namtraceAllFile_
-	if {$file != ""} {
-		set namtraceAllFile_ $file
-	} else {
-		unset namtraceAllFile_
-	}
-}
-
-Simulator instproc energy-color-change {level1 level2} {
-	$self instvar level1_ level2_
- 	set level1_ $level1
- 	set level2_ $level2
-}
-
-Simulator instproc namtrace-all-wireless {file optx opty} {
-        $self instvar namtraceAllFile_
-
-	# indicate that we need a W event written to the trace
-	$self set namNeedsW_ 1
-	if { $optx != "" && $opty != "" } {
-		$self set namWx_ $optx
-		$self set namWy_ $opty
-	}
-
-	$self namtrace-all $file
-}
-
-Simulator instproc nam-end-wireless {stoptime} {
-        $self instvar namtraceAllFile_
-
-        if {$namtraceAllFile_ != ""} {
-		$self puts-nam-config "W -t $stoptime"
-        }
-}
-
-Simulator instproc namtrace-some file {
-	$self instvar namtraceSomeFile_
-	set namtraceSomeFile_ $file
-}
-
-# Support for event-tracing
-        
-Simulator instproc eventtrace-all {{file ""}} {
-	$self instvar eventTraceAll_ eventtraceAllFile_ traceAllFile_
-	set eventTraceAll_ 1
-	if {$file != ""} {
-		set eventtraceAllFile_ $file
-	} else {
-		set eventtraceAllFile_ $traceAllFile_
-	}
-	
-}
-
-
-
-Simulator instproc initial_node_pos {nodep size} {
-	$self instvar addressType_
-	$self instvar energyModel_ 
-
-	if [info exists energyModel_] {  
-		set nodeColor "green"
-	} else {
-		set nodeColor "black"
-	}
-	if { [info exists addressType_] && $addressType_ == "hierarchical" } {
-		# Hierarchical addressing
-		$self puts-nam-config "n -t * -a [$nodep set address_] \
--s [$nodep id] -x [$nodep set X_] -y [$nodep set Y_] -Z [$nodep set Z_] \
--z $size -v circle -c $nodeColor"
-	} else { 
-		# Flat addressing
-		$self puts-nam-config "n -t * -s [$nodep id] \
--x [$nodep set X_] -y [$nodep set Y_] -Z [$nodep set Z_] -z $size \
--v circle -c $nodeColor"
-	}
-}
-
-Simulator instproc trace-all file {
-	$self instvar traceAllFile_
-	set traceAllFile_ $file
-}
-
-Simulator instproc get-nam-traceall {} {
-	$self instvar namtraceAllFile_
-	if [info exists namtraceAllFile_] {
-		return $namtraceAllFile_
-	} else {
-		return ""
-	}
-}
-
-Simulator instproc get-ns-traceall {} {
-	$self instvar traceAllFile_
-	if [info exists traceAllFile_] {
-		return $traceAllFile_
-	} else {
-		return ""
-	}
-}
-
-# If exists a traceAllFile_, print $str to $traceAllFile_
-Simulator instproc puts-ns-traceall { str } {
-	$self instvar traceAllFile_
-	if [info exists traceAllFile_] {
-		puts $traceAllFile_ $str
-	}
-}
-
-# If exists a traceAllFile_, print $str to $traceAllFile_
-Simulator instproc puts-nam-traceall { str } {
-	$self instvar namtraceAllFile_
-	if [info exists namtraceAllFile_] {
-		puts $namtraceAllFile_ $str
-	} elseif [info exists namtraceSomeFile_] {
-		puts $namtraceSomeFile_ $str
-	}
-}
-
-# namConfigFile is used for writing color/link/node/queue/annotations. 
-# XXX It cannot co-exist with namtraceAll.
-Simulator instproc namtrace-config { f } {
-	$self instvar namConfigFile_
-	set namConfigFile_ $f
-}
-
-Simulator instproc get-nam-config {} {
-	$self instvar namConfigFile_
-	if [info exists namConfigFile_] {
-		return $namConfigFile_
-	} else {
-		return ""
-	}
-}
-
-# Used only for writing nam configurations to trace file(s). This is different
-# from puts-nam-traceall because we may want to separate configuration 
-# informations and actual tracing information
-Simulator instproc puts-nam-config { str } {
-	$self instvar namtraceAllFile_ namConfigFile_
-	
-	if [info exists namConfigFile_] {
-		puts $namConfigFile_ $str
-	} elseif [info exists namtraceAllFile_] {
-		puts $namtraceAllFile_ $str
-	} elseif [info exists namtraceSomeFile_] {
-		puts $namtraceSomeFile_ $str
-	}
-}
-
-Simulator instproc color { id name } {
-	$self instvar color_
-	set color_($id) $name
-}
-
-Simulator instproc get-color { id } {
-	$self instvar color_
-	return $color_($id)
-}
-
-# you can pass in {} as a null file
-Simulator instproc create-trace { type file src dst {op ""} } {
-	$self instvar alltrace_
-	set p [new Trace/$type]
-	$p tagged [Simulator set TaggedTrace_]
-	if [catch {$p set src_ [$src id]}] {
-		$p set src_ $src
-	}
-	if [catch {$p set dst_ [$dst id]}] {
-		$p set dst_ $dst
-	}
-	lappend alltrace_ $p
-	if {$file != ""} {
-		$p ${op}attach $file		
-	}
-	return $p
-}
-
-
-Simulator instproc create-eventtrace {type owner } {
-	$self instvar alltrace_ 
-	$self instvar eventTraceAll_ eventtraceAllFile_ namtraceAllFile_
-	
-	if ![info exists eventTraceAll_] return
-
-	if { $eventTraceAll_ == 1 } {
-		
-		set et [new BaseTrace/$type]
-		$owner cmd eventtrace $et
-		
-		lappend alltrace_ $et
-		$et attach $eventtraceAllFile_
-		if [info exists namtraceAllFile_] {
-			$et namattach $namtraceAllFile_
-		}
-	}
-}
-
-
-Simulator instproc namtrace-queue { n1 n2 {file ""} } {
-	$self instvar link_ namtraceAllFile_
-	if {$file == ""} {
-		if ![info exists namtraceAllFile_] return
-		set file $namtraceAllFile_
-	}
-	$link_([$n1 id]:[$n2 id]) nam-trace $self $file
-    
-	# Added later for queue specific tracing events other than enque, 
-	# deque and drop as of now nam does not understand special events. 
-	# Changes will have to be made to nam for it to understand events 
-	# like early drops if they are prefixed differently than "d". - ratul
-	set queue [$link_([$n1 id]:[$n2 id]) queue]
-	$queue attach-nam-traces $n1 $n2 $file
-}
-
-Simulator instproc trace-queue { n1 n2 {file ""} } {
-	$self instvar link_ traceAllFile_
-	if {$file == ""} {
-		if ![info exists traceAllFile_] return
-		set file $traceAllFile_
-	}
-	$link_([$n1 id]:[$n2 id]) trace $self $file
-	
-	# Added later for queue specific tracing events other than enque, 
-	# deque and drop - ratul
-	set queue [$link_([$n1 id]:[$n2 id]) queue]
-	$queue attach-traces $n1 $n2 $file
-}
-
-#
-# arrange for queue length of link between nodes n1 and n2
-# to be tracked and return object that can be queried
-# to learn average q size etc.  XXX this API still rough
-#
-Simulator instproc monitor-queue { n1 n2 qtrace { sampleInterval 0.1 } } {
-	$self instvar link_
-	return [$link_([$n1 id]:[$n2 id]) init-monitor $self $qtrace $sampleInterval]
-}
-
-Simulator instproc queue-limit { n1 n2 limit } {
-	$self instvar link_
-	[$link_([$n1 id]:[$n2 id]) queue] set limit_ $limit
-	if {[[$link_([$n1 id]:[$n2 id]) queue] info class] == "Queue/XCP"} {
-		[$link_([$n1 id]:[$n2 id]) queue] queue-limit $limit
-	}
-}
-
-Simulator instproc drop-trace { n1 n2 trace } {
-	$self instvar link_
-	[$link_([$n1 id]:[$n2 id]) queue] drop-target $trace
-}
-
-Simulator instproc cost {n1 n2 c} {
-	$self instvar link_
-	$link_([$n1 id]:[$n2 id]) cost $c
-}
-
-# Armando L. Caro Jr. <acaro@@cis,udel,edu> 10/22/2001
-Simulator instproc multihome-attach-agent { core agent } {
-      	$agent set-multihome-core [$core entry]
-
-      	foreach interface [$core set multihome_interfaces_] {
-  		set ifNode [lindex $interface 0]
-		set coreLink [lindex $interface 1]
-
-      		# attach agent to the node for each interface
-      		$ifNode attach $agent
-      		set addr [$agent set agent_addr_]
-      		set port [$agent set agent_port_]
-      		set entry [$ifNode entry]
-
-      		# give the interface info to the agent
-		$agent add-multihome-interface $addr $port $entry $coreLink
-			
-      		$agent instvar multihome_bindings_
-      		set binding_ {}
-      		lappend binding_ $addr
-      		lappend binding_ $port
-      		lappend multihome_bindings_ $binding_
-      	}
-}
-
-Simulator instproc attach-agent { node agent } {
-	$node attach $agent
-	# $agent set nodeid_ [$node id]
-
-        # Armando L. Caro Jr. <acaro@@cis,udel,edu> 10/22/2001 
-	#
-	# list of tuples (addr, port)
-	# This is NEEDED so that single homed agents can play with multihomed
-	# ones!
-	# multihoming only for SCTP agents -Padma H.
-	if {[lindex [split [$agent info class] "/"] 1] == "SCTP"} {
-		$agent instvar multihome_bindings_
-		set binding_ {}
-		set addr [$agent set agent_addr_]
-		set port [$agent set agent_port_]
-		lappend binding_ $addr
-		lappend binding_ $port
-		lappend multihome_bindings_ $binding_
-	}
-}
-
-Simulator instproc attach-tbf-agent { node agent tbf } {
-	$node attach $agent
-	$agent attach-tbf $tbf
-}
-
-
-Simulator instproc detach-agent { node agent } {
-
-	# Debo added this
-	$self instvar conn_ nconn_ sflows_ nsflows_ useasim_
-
-	if {$useasim_ == 1} {
-		set list "" 
-		set s [$node id]
-		set d [[$self get-node-by-addr [$agent set dst_addr_]] id]
-		foreach x $conn_ {
-			set t [split $x ":"] 
-			if {[string compare [lindex $t 0]:[lindex $t 1] $s:$d] != 0} {
-				lappend list_ $x
-			}
-		}
-		set conn_ list
-		set nconn_ [expr $nconn_ -1]
-		# ---------------------------------------
-	}
-
-	$self instvar nullAgent_
-	$node detach $agent $nullAgent_
-}
-
-#
-#   Helper proc for setting delay on an existing link
-#
-Simulator instproc delay { n1 n2 delay {type simplex} } {
-	$self instvar link_
-	set sid [$n1 id]
-	set did [$n2 id]
-	if [info exists link_($sid:$did)] {
-		set d [$link_($sid:$did) link]
-		$d set delay_ $delay
-	}
-	if {$type == "duplex"} {
-		if [info exists link_($did:$sid)] {
-			set d [$link_($did:$sid) link]
-			$d set delay_ $delay
-		}
-	}
-}
-
-# 
-#   Helper proc for setting bandwidth on an existing link
-#
-Simulator instproc bandwidth { n1 n2 bandwidth {type simplex} } {
-        $self instvar link_
-        set sid [$n1 id]
-        set did [$n2 id]
-        if [info exists link_($sid:$did)] {
-                set d [$link_($sid:$did) link]
-                $d set bandwidth_ $bandwidth
-        } 
-        if {$type == "duplex"} {
-                if [info exists link_($did:$sid)] {
-                        set d [$link_($did:$sid) link]
-                        $d set bandwidth_ $bandwidth
-                }
-        }
-}
-
-
-#XXX need to check that agents are attached to nodes already
-Simulator instproc connect {src dst} {
-
-	$self instvar conn_ nconn_ sflows_ nsflows_ useasim_
-
-        # Armando L. Caro Jr. <acaro@@cis,udel,edu>
-	# does the agent type support multihoming??
-	# @@@ do we need to worry about $useasim_ below?? (wasn't in 2.1b8)
-    	if {[lindex [split [$src info class] "/"] 1] == "SCTP"} {
-    		$self multihome-connect $src $dst
-    	}
-
-	$self simplex-connect $src $dst
-	$self simplex-connect $dst $src
-
-
-	# Debo
-
-	if {$useasim_ == 1} {
-		set sid [$src nodeid]
-		set sport [$src set agent_port_]
-		set did [$dst nodeid]
-		set dport [$dst set agent_port_]
-		
-		if {[lindex [split [$src info class] "/"] 1] == "TCP"} {
-			lappend conn_ $sid:$did:$sport:$dport
-			incr nconn_
-			# set $nconn_ [expr $nconn_ + 1]
-			# puts "Set a connection with id $nconn_ between $sid and $did"
-		}
-	}
-
-	return $src
-}
-
-# Armando L. Caro Jr. <acaro@@cis,udel,edu> 10/12/2001
-Simulator instproc multihome-connect {src dst} {
-	
-        set destNum 0
-	foreach binding [$src set multihome_bindings_] {
-		incr destNum
-  		set addr [lindex $binding 0]
-  		set port [lindex $binding 1]
-      		$dst add-multihome-destination $addr $port
-    	}
-	if {$destNum == 0} {
-	        # src isn't multihomed, so make sure we do an
-		# add-multihome-destination
-		$dst add-multihome-destination \
-				[$src set agent_addr_] [$src set agent_port_]
-	}
-	
-        set destNum 0
-	foreach binding [$dst set multihome_bindings_] {
-		incr destNum
-  		set addr [lindex $binding 0]
-  		set port [lindex $binding 1]
-      		$src add-multihome-destination $addr $port
-    	}
-	if {$destNum == 0} {
-	        # dst isn't multihomed, so make sure we do an
-		# add-multihome-destination
-		$src add-multihome-destination \
-				[$dst set agent_addr_] [$dst set agent_port_]
-	}
-}
-
-Simulator instproc simplex-connect { src dst } {
-	$src set dst_addr_ [$dst set agent_addr_] 
-	$src set dst_port_ [$dst set agent_port_]
-
-
-        # Polly Huang: to support abstract TCP simulations
-        if {[lindex [split [$src info class] "/"] 1] == "AbsTCP"} {
-	    $self at [$self now] "$self rtt $src $dst"
-	    $dst set class_ [$src set class_]
-        }
-
-	return $src
-}
-
-#
-# Here are a bunch of helper methods.
-#
-
-Simulator proc instance {} {
-	set ns [Simulator info instances]
-	if { $ns != "" } {
-		return $ns
-	}
-	foreach sim [Simulator info subclass] {
-		set ns [$sim info instances]
-		if { $ns != "" } {
-			return $ns
-		}
-	}
-	error "Cannot find instance of simulator"
-}
-
-Simulator instproc get-number-of-nodes {} {
-	return  [$self array size Node_]
-}
-
-Simulator instproc get-node-by-id id {
-	$self instvar Node_
-	return $Node_($id)
-}
-
-# Given an node's address, Return the node-id
-Simulator instproc get-node-id-by-addr address {
-	$self instvar Node_
-	set n [Node set nn_]
-	for {set q 0} {$q < $n} {incr q} {
-		set nq $Node_($q)
-		if {[string compare [$nq node-addr] $address] == 0} {
-			return $q
-		}
-	}
-	error "get-node-id-by-addr:Cannot find node with given address"
-}
-
-# Given an node's address, return the node 
-Simulator instproc get-node-by-addr address {
-	return [$self get-node-by-id [$self get-node-id-by-addr $address]]
-}
-
-Simulator instproc all-nodes-list {} {
-	$self instvar Node_
-	set nodes ""
-	foreach n [lsort -dictionary [array names Node_]] {
-		lappend nodes $Node_($n)
-	}
-	return $nodes
-}
-
-Simulator instproc link { n1 n2 } {
-        $self instvar Node_ link_
-        if { ![catch "$n1 info class Node"] } {
-		set n1 [$n1 id]
-	}
-        if { ![catch "$n2 info class Node"] } {
-		set n2 [$n2 id]
-	}
-	if [info exists link_($n1:$n2)] {
-		return $link_($n1:$n2)
-	}
-	return ""
-}
-
-# Creates connection. First creates a source agent of type s_type and binds
-# it to source.  Next creates a destination agent of type d_type and binds
-# it to dest.  Finally creates bindings for the source and destination agents,
-# connects them, and  returns the source agent.
-Simulator instproc create-connection {s_type source d_type dest pktClass} {
-	set s_agent [new Agent/$s_type]
-	set d_agent [new Agent/$d_type]
-	$s_agent set fid_ $pktClass
-	$d_agent set fid_ $pktClass
-	$self attach-agent $source $s_agent
-	$self attach-agent $dest $d_agent
-	$self connect $s_agent $d_agent
-	
-	return $s_agent
-}
-
-# Creates a highspeed connection. Similar to create-connection 
-# above except the sink agent requires additional work -- Sylvia
-Simulator instproc create-highspeed-connection {s_type source d_type dest pktClass} {
-        set s_agent [new Agent/$s_type]
-        set d_agent [new Agent/$d_type]
-        $d_agent resize_buffers
-        $s_agent set fid_ $pktClass
-        $d_agent set fid_ $pktClass
-        $self attach-agent $source $s_agent
-        $self attach-agent $dest $d_agent
-        $self connect $s_agent $d_agent
-
-        return $s_agent
-}
-
-# Creates connection. First creates a source agent of type s_type and binds
-# it to source.  Next creates a destination agent of type d_type and binds
-# it to dest.  Finally creates bindings for the source and destination agents,
-# connects them, and  returns a list of source agent and destination agent.
-Simulator instproc create-connection-list {s_type source d_type dest pktClass} {
-    set s_agent [new Agent/$s_type]
-    set d_agent [new Agent/$d_type]
-    $s_agent set fid_ $pktClass
-    $d_agent set fid_ $pktClass
-    $self attach-agent $source $s_agent
-    $self attach-agent $dest $d_agent
-    $self connect $s_agent $d_agent
-
-    return [list $s_agent $d_agent]
-}   
-
-# Creates connection. First creates a source agent of type s_type and binds
-# it to source.  Next creates a destination agent of type d_type and binds
-# it to dest.  Finally creates bindings for the source and destination agents,
-# connects them, and  returns the source agent. 
-# The destination agent is set to listen, for full-tcp.
-Simulator instproc create-connection-listen {s_type source d_type dest pktClass} {
-    set s_agent [new Agent/$s_type]
-    set d_agent [new Agent/$d_type]
-    $s_agent set fid_ $pktClass
-    $d_agent set fid_ $pktClass
-    $self attach-agent $source $s_agent
-    $self attach-agent $dest $d_agent
-    $self connect $s_agent $d_agent
-    $d_agent listen
-
-    return $s_agent 
-}   
-
-# This seems to be an obsolete procedure.
-Simulator instproc create-tcp-connection {s_type source d_type dest pktClass} {
-	set s_agent [new Agent/$s_type]
-	set d_agent [new Agent/$d_type]
-	$s_agent set fid_ $pktClass
-	$d_agent set fid_ $pktClass
-	$self attach-agent $source $s_agent
-	$self attach-agent $dest $d_agent
-	return "$s_agent $d_agent"
-}
-
-#
-# Other classifier methods overload the instproc-likes to track 
-# and return the installed objects.
-#
-Classifier instproc install {slot val} {
-	$self set slots_($slot) $val
-	$self cmd install $slot $val
-}
-
-Classifier instproc installNext val {
-	set slot [$self cmd installNext $val]
-	$self set slots_($slot) $val
-	set slot
-}
-
-Classifier instproc adjacents {} {
-	$self array get slots_
-}
-
-Classifier instproc in-slot? slot {
-	$self instvar slots_
-	set ret ""
-	if {[info exists slots_($slot)]} {
-	        set ret $slots_($slot)
-	}
-	set ret
-}
-
-# For debugging
-Classifier instproc dump {} {
-	$self instvar slots_ offset_ shift_ mask_
-	puts "classifier $self"
-	puts "\t$offset_ offset"
-	puts "\t$shift_ shift"
-	puts "\t$mask_ mask"
-	puts "\t[array size slots_] slots"
-	foreach i [lsort -integer [array names slots_]] {
-		set iv $slots_($i)
-		puts "\t\tslot $i: $iv ([$iv info class])"
-	}
-}
-
-Classifier instproc no-slot slot {
-        puts stderr "--- Classfier::no-slot{} default handler (tcl/lib/ns-lib.tcl) ---"
-        puts stderr "\t$self: no target for slot $slot"
-        puts stderr "\t$self type: [$self info class]"
-        puts stderr "content dump:"
-        $self dump
-        puts stderr "---------- Finished standard no-slot{} default handler ----------"
-        # Clear output before we bail out
-        [Simulator instance] flush-trace
-        exit 1
-}
-
-Classifier/Hash instproc dump args {
-	eval $self next $args
-	$self instvar default_
-	puts "\t$default_ default"
-}
-
-Classifier/Hash instproc init nbuck {
-	# We need to make sure that port shift/mask values are there
-	# so we set them after they get their default values
-	$self next $nbuck
-	$self instvar shift_ mask_
-	set shift_ [AddrParams NodeShift 1]
-	set mask_ [AddrParams NodeMask 1]
-}
-
-Classifier/Port/Reserve instproc init args {
-        eval $self next
-        $self reserve-port 2
-}
-
-Simulator instproc makeflowmon { cltype { clslots 29 } } {
-	set flowmon [new QueueMonitor/ED/Flowmon]
-	set cl [new Classifier/Hash/$cltype $clslots]
-	
-	$cl proc unknown-flow { src dst fid }  {
-		set fdesc [new QueueMonitor/ED/Flow]
-		set dsamp [new Samples]
-		$fdesc set-delay-samples $dsamp
-		set slot [$self installNext $fdesc] 
-		$self set-hash auto $src $dst $fid $slot
-	}
-	
-	$cl proc no-slot slotnum {
-		#
-		# note: we can wind up here when a packet passes
-		# through either an Out or a Drop Snoop Queue for
-		# a queue that the flow doesn't belong to anymore.
-		# Since there is no longer hash state in the
-		# hash classifier, we get a -1 return value for the
-		# hash classifier's classify() function, and there
-		# is no node at slot_[-1].  What to do about this?
-		# Well, we are talking about flows that have already
-		# been moved and so should rightly have their stats
-		# zero'd anyhow, so for now just ignore this case..
-		# puts "classifier $self, no-slot for slotnum $slotnum"
-	}
-	$flowmon classifier $cl
-	return $flowmon
-}
-
-# attach a flow monitor to a link
-# 3rd argument dictates whether early drop support is to be used
-
-Simulator instproc attach-fmon {lnk fm { edrop 0 } } {
-	set isnoop [new SnoopQueue/In]
-	set osnoop [new SnoopQueue/Out]
-	set dsnoop [new SnoopQueue/Drop]
-	$lnk attach-monitors $isnoop $osnoop $dsnoop $fm
-	if { $edrop != 0 } {
-	    set edsnoop [new SnoopQueue/EDrop]
-	    $edsnoop set-monitor $fm
-	    [$lnk queue] early-drop-target $edsnoop
-	    $edsnoop target [$self set nullAgent_]
-	}
-	[$lnk queue] drop-target $dsnoop
-}
-
-# Added by Yun Wang
-
-Simulator instproc maketbtagger { cltype { clslots 29 } } {
-
-        set tagger [new QueueMonitor/ED/Tagger]
-        set cl [new Classifier/Hash/$cltype $clslots]
-
-        $cl proc unknown-flow { src dst fid }  {
-                set fdesc [new QueueMonitor/ED/Flow/TB]
-                set dsamp [new Samples]
-                $fdesc set-delay-samples $dsamp
-                set slot [$self installNext $fdesc]
-                $self set-hash auto $src $dst $fid $slot
-        }
-
-        $cl proc set-rate { src dst fid hashbucket rate depth init} {
-                set fdesc [new QueueMonitor/ED/Flow/TB]
-                set dsamp [new Samples]
-                $fdesc set-delay-samples $dsamp
-                $fdesc set target_rate_ $rate
-                $fdesc set bucket_depth_ $depth
-                # Initialize the bucket as full
-                $fdesc set tbucket_ $init  
-                set slot [$self installNext $fdesc]
-                $self set-hash $hashbucket $src $dst $fid $slot
-        }
-
-        $cl proc no-slot slotnum {
-                #
-                # note: we can wind up here when a packet passes
-                # through either an Out or a Drop Snoop Queue for
-                # a queue that the flow doesn't belong to anymore.
-                # Since there is no longer hash state in the
-                # hash classifier, we get a -1 return value for the
-                # hash classifier's classify() function, and there
-                # is no node at slot_[-1].  What to do about this?
-                # Well, we are talking about flows that have already
-                # been moved and so should rightly have their stats
-                # zero'd anyhow, so for now just ignore this case..
-                # puts "classifier $self, no-slot for slotnum $slotnum"
-        }
-        $tagger classifier $cl
-        return $tagger
-}
-
-# Added by Yun Wang
-
-Simulator instproc maketswtagger { cltype { clslots 29 } } {
-
-        set tagger [new QueueMonitor/ED/Tagger]
-        set cl [new Classifier/Hash/$cltype $clslots]
-
-        $cl proc unknown-flow { src dst fid hashbucket }  {
-                set fdesc [new QueueMonitor/ED/Flow/TSW]
-                set dsamp [new Samples]
-                $fdesc set-delay-samples $dsamp
-                set slot [$self installNext $fdesc]
-                $self set-hash $hashbucket $src $dst $fid $slot
-        }
-
-        $cl proc no-slot slotnum {
-                #
-                # note: we can wind up here when a packet passes
-                # through either an Out or a Drop Snoop Queue for
-                # a queue that the flow doesn't belong to anymore.
-                # Since there is no longer hash state in the
-                # hash classifier, we get a -1 return value for the
-                # hash classifier's classify() function, and there
-                # is no node at slot_[-1].  What to do about this?
-                # Well, we are talking about flows that have already
-                # been moved and so should rightly have their stats
-                # zero'd anyhow, so for now just ignore this case..
-                # puts "classifier $self, no-slot for slotnum $slotnum"
-        }
-        $tagger classifier $cl
-        return $tagger
-}
-
-# attach a Tagger to a link
-# Added by Yun Wang
-
-Simulator instproc attach-tagger {lnk fm} {
-        set isnoop [new SnoopQueue/Tagger]
-        $lnk attach-taggers $isnoop $fm
-}
-
-# Imported from session.tcl. It is deleted there.
-### to insert loss module to regular links in detailed Simulator
-Simulator instproc lossmodel {lossobj from to} {
-	set link [$self link $from $to]
-	$link errormodule $lossobj
-}
-
-# This function generates losses that can be visualized by nam.
-Simulator instproc link-lossmodel {lossobj from to} {
-	set link [$self link $from $to]
-	$link insert-linkloss $lossobj
-}
-
-
-#### Polly Huang: Simulator class instproc to support abstract tcp simulations
-
-Simulator instproc rtt { src dst } {
-	$self instvar routingTable_ delay_
-	set srcid [[$src set node_] id]
-	set dstid [[$dst set node_] id]
-	set delay 0
-	set tmpid $srcid
-	while {$tmpid != $dstid} {
-		set nextid [$routingTable_ lookup $tmpid $dstid]
-		set tmpnode [$self get-node-by-id $tmpid]
-		set nextnode [$self get-node-by-id $nextid]
-		set tmplink [[$self link $tmpnode $nextnode] link]
-		set delay [expr $delay + [expr 2 * [$tmplink set delay_]]]
-		set delay [expr $delay + [expr 8320 / [$tmplink set bandwidth_]]]
-		set tmpid $nextid
-	}
-	$src rtt $delay
-	return $delay
-}
-
-Simulator instproc abstract-tcp {} {
-	$self instvar TahoeAckfsm_ RenoAckfsm_ TahoeDelAckfsm_ RenoDelAckfsm_ dropper_ 
-	$self set TahoeAckfsm_ [new FSM/TahoeAck]
-	$self set RenoAckfsm_ [new FSM/RenoAck]
-	$self set TahoeDelAckfsm_ [new FSM/TahoeDelAck]
-	$self set RenoDelAckfsm_ [new FSM/RenoDelAck]
-	$self set nullAgent_ [new DropTargetAgent]
-}
-
-# Chalermek: For Diffusion, Flooding, and Omnicient Multicast 
-
-Simulator instproc create-diffusion-rate-agent {node} {
-	global opt
-	set diff [new Agent/Diffusion/RateGradient]
-
-	$node set diffagent_ $diff
-	$node set ragent_ $diff
-
-	$diff on-node $node
-
-	if [info exist opt(enablePos)] {
-		if {$opt(enablePos) == "true"} {
-			$diff enable-pos
-		} else {
-			$diff disable-pos
-		}
-	} 
-
-	if [info exist opt(enableNeg)] {
-		if {$opt(enableNeg) == "true"} {
-			$diff enable-neg
-		} else {
-			$diff disable-neg
-		}
-	} 
-    
-	if [info exist opt(suppression)] {
-		if {$opt(suppression) == "true"} {
-			$diff enable-suppression
-		} else {
-			$diff disable-suppression
-		}
-	} 
-
-	if [info exist opt(subTxType)] {
-		$diff set-sub-tx-type $opt(subTxType)
-	} 
-
-	if [info exist opt(orgTxType)] {
-		$diff set-org-tx-type $opt(orgTxType)
-	} 
-
-	if [info exist opt(posType)] {
-		$diff set-pos-type $opt(posType)
-	} 
-
-	if [info exist opt(posNodeType)] {
-		$diff set-pos-node-type $opt(posNodeType)
-	} 
-
-	if [info exist opt(negWinType)] {
-		$diff set-neg-win-type $opt(negWinType)
-	} 
-
-	if [info exist opt(negThrType)] {
-		$diff set-neg-thr-type $opt(negThrType)
-	} 
-
-	if [info exist opt(negMaxType)] {
-		$diff set-neg-max-type $opt(negMaxType)
-	} 
-
-	$self put-in-list $diff
-	$self at 0.0 "$diff start"
-	
-	return $diff
-}
-
-Simulator instproc create-diffusion-probability-agent {node} {
-	global opt
-	set diff [new Agent/Diffusion/ProbGradient]
-
-	$node set diffagent_ $diff
-	$node set ragent_ $diff
-
-	$diff on-node $node
-
-	if [info exist opt(enablePos)] {
-		if {$opt(enablePos) == "true"} {
-			$diff enable-pos
-		} else {
-			$diff disable-pos
-		}
-	} 
-	if [info exist opt(enableNeg)] {
-		if {$opt(enableNeg) == "true"} {
-			$diff enable-neg
-		} else {
-			$diff disable-neg
-		}
-	} 
-	
-	$self put-in-list $diff
-	$self at 0.0 "$diff start"
-
-	return $diff
-}
-
-# Diffusioncore agent (in diffusion) maps to the wireless routing agent
-# in ns
-Simulator instproc create-core-diffusion-rtg-agent {node} {
-	$self instvar stopTime_ diffFilter_
-	Node instvar ragent_ dmux_
-	set ragent [new Agent/DiffusionRouting [$node id]]
-	$node set ragent_ $ragent
-	# at stop-time core-diffusion dumps stats data
-	# see diffusion.cc for details
-	if { [info exists stopTime_] } {
-		$ragent stop-time $stopTime_
-	}
-	if { ![info exists diffFilter_] } {
-		puts stderr "Error: No filter defined for diffusion!\n"
-		exit 1
-	}
-	$node create-diffusionApp-agent $diffFilter_
-	return $ragent
-}
-
-Simulator instproc create-flooding-agent {node} {
-	set flood [new Agent/Flooding]
-
-	$node set ragent_ $flood
-
-	$flood on-node $node
-
-	$self put-in-list $flood
-	$self at 0.0 "$flood start"
-
-	return $flood
-}
-
-Simulator instproc create-omnimcast-agent {node} {
-	set omni [new Agent/OmniMcast]
-
-	$node set ragent_ $omni
-
-	$omni on-node $node
-
-	$self put-in-list $omni
-	$self at 0.0 "$omni start"
-
-	return $omni
-}
-
-# XXX These are very simulation-specific methods, why should they belong here?
-Simulator instproc put-in-list {agent} {
-	$self instvar lagent
-	lappend lagent $agent
-}
-
-Simulator instproc terminate-all-agents {} {
-	$self instvar lagent
-	foreach i $lagent {
-		$i terminate
-	}
-}
-
-Simulator instproc prepare-to-stop {} {
-	$self instvar lagent
-	foreach i $lagent {
-		$i stop
-	}
-}
-    
+# -*-	Mode:tcl; tcl-indent-level:8; tab-width:8; indent-tabs-mode:t -*-
+#
+# Copyright (c) 1996 Regents of the University of California.
+# All rights reserved.
+# 
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+# 3. All advertising materials mentioning features or use of this software
+#    must display the following acknowledgement:
+# 	This product includes software developed by the MASH Research
+# 	Group at the University of California Berkeley.
+# 4. Neither the name of the University nor of the Research Group may be
+#    used to endorse or promote products derived from this software without
+#    specific prior written permission.
+# 
+# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+
+# @(#) $Header: /cvsroot/nsnam/ns-2/tcl/lib/ns-lib.tcl,v 1.277 2009/01/15 06:23:49 tom_henderson Exp $
+
+
+#
+# Word of warning to developers:
+# this code (and all it sources) is compiled into the
+# ns executable.  You need to rebuild ns or explicitly
+# source this code to see changes take effect.
+#
+
+
+
+proc warn {msg} {
+	global warned_
+	if {![info exists warned_($msg)]} {
+		puts stderr "warning: $msg"
+		set warned_($msg) 1
+	}
+}
+
+if {[info commands debug] == ""} {
+	proc debug args {
+		warn {Script debugging disabled.  Reconfigure with --with-tcldebug, and recompile.}
+	}
+}
+
+proc assert args {
+        if [catch "expr $args" ret] {
+                set ret [eval expr $args]
+        }
+        if {! $ret} {
+                error "assertion failed: $args"
+        }
+}
+
+proc find-max list {
+	set max 0
+	foreach val $list {
+		if {$val > $max} {
+			set max $val
+		}
+	}
+	return $max
+}
+
+proc bw_parse { bspec } {
+	if { [scan $bspec "%f%s" b unit] == 1 } {
+		set unit bps
+	}
+	regsub {[/p]s(ec)?$} $unit {} unit
+	if [string match {*B} $unit] {
+		set b [expr $b*8]
+		set unit "[string trimright $unit B]b"
+	}
+	switch $unit {
+		b { return $b }
+		kb { return [expr $b*1000] }
+		Mb { return [expr $b*1000000] }
+		Gb { return [expr $b*1000000000] }
+		default { 
+			puts "error: bw_parse: unknown unit `$unit'" 
+			exit 1
+		}
+	}
+}
+
+proc time_parse { spec } {
+	if { [scan $spec "%f%s" t unit] == 1 } {
+		set unit s
+	}
+	regsub {sec$} $unit {s} unit
+	switch $unit {
+		s { return $t }
+		ms { return [expr $t*1e-3] }
+		us { return [expr $t*1e-6] }
+		ns { return [expr $t*1e-9] }
+		ps { return [expr $t*1e-12] }
+		default { 
+			puts "error: time_parse: unknown unit `$unit'" 
+			exit 1
+		}
+	}
+}
+
+proc delay_parse { spec } {
+	return [time_parse $spec]
+}
+
+
+#
+# Create the core OTcl class called "Simulator".
+# This is the principal interface to the simulation engine.
+#
+#Class Simulator
+
+#
+# XXX Whenever you modify the source list below, please also change the
+# OTcl script dependency list in Makefile.in
+#
+source ns-autoconf.tcl
+source ns-address.tcl
+source ns-node.tcl
+source ns-rtmodule.tcl
+source ns-hiernode.tcl
+source ns-mobilenode.tcl
+source ns-bsnode.tcl
+source ns-link.tcl
+source ns-source.tcl
+source ns-compat.tcl
+source ns-packet.tcl
+source ns-queue.tcl
+source ns-trace.tcl
+source ns-random.tcl
+source ns-agent.tcl
+source ns-route.tcl
+source ns-errmodel.tcl
+source ns-intserv.tcl
+source ns-cmutrace.tcl
+source ns-mip.tcl
+source ns-sat.tcl
+#source ns-nix.tcl
+source ns-diffusion.tcl
+source ../rtp/session-rtp.tcl
+source ../interface/ns-iface.tcl
+source ../lan/ns-mac.tcl
+
+# Added by Sushmita to support event tracing for mac-simple and 802.11
+source ../lan/ns-mac-simple.tcl
+source ../lan/ns-mac-802_11.tcl
+
+source ../lan/ns-ll.tcl
+source ../lan/vlan.tcl
+source ../lan/abslan.tcl
+source ../mcast/timer.tcl
+source ../mcast/ns-mcast.tcl
+source ns-srcrt.tcl
+source ../mcast/McastProto.tcl
+source ../mcast/DM.tcl
+source ../ctr-mcast/CtrMcast.tcl
+source ../ctr-mcast/CtrMcastComp.tcl
+source ../ctr-mcast/CtrRPComp.tcl
+source ../mcast/BST.tcl
+source ../mcast/srm.tcl
+source ../mcast/srm-ssm.tcl
+# These files removed due to licensing conflicts
+# source ../mcast/mftp_snd.tcl
+# source ../mcast/mftp_rcv.tcl
+# source ../mcast/mftp_rcv_stat.tcl
+source ../mcast/McastMonitor.tcl
+source ../rlm/rlm.tcl
+source ../rlm/rlm-ns.tcl
+source ../session/session.tcl
+source ../webcache/http-server.tcl
+source ../webcache/http-cache.tcl
+source ../webcache/http-agent.tcl
+source ../webcache/http-mcache.tcl
+source ../webcache/webtraf.tcl
+source ../webcache/empweb.tcl
+source ns-namsupp.tcl
+source ../mobility/dsdv.tcl
+source ../mobility/dsr.tcl
+source ../mobility/fsr.tcl
+source ../mobility/com.tcl
+
+source ../plm/plm.tcl
+source ../plm/plm-ns.tcl
+source ../plm/plm-topo.tcl
+
+# MPLS
+source ../mpls/ns-mpls-simulator.tcl
+source ../mpls/ns-mpls-node.tcl
+source ../mpls/ns-mpls-ldpagent.tcl
+source ../mpls/ns-mpls-classifier.tcl
+
+source ns-default.tcl
+source ../emulate/ns-emulate.tcl
+
+#pushback
+source ns-pushback.tcl
+
+# PGM
+#source ../pgm/ns-pgm.tcl
+
+#LMS
+source ../mcast/ns-lms.tcl
+
+# STL dependent modules get included
+# ONLY when STL is found
+
+if {[ns-hasSTL] == 1} {
+source ns-nix.tcl
+source ../pgm/ns-pgm.tcl
+source ../rtglib/ns-rtProtoLS.tcl
+source ../delaybox/delaybox.tcl
+source ../packmime/packmime.tcl
+}
+
+source ns-qsnode.tcl
+
+# Obsolete modules
+#source ns-wireless-mip.tcl
+#source ns-nam.tcl
+
+Simulator instproc init args {
+
+	# Debojyoti added this for asim 
+
+	$self instvar useasim_
+	$self instvar slinks_
+	$self instvar nconn_
+	$self instvar sflows_
+	$self instvar nsflows_
+		
+	set slinks_(0:0) 0
+	set nconn_ 0
+	set conn_ ""
+	# for short flows stuff
+	set sflows_ "" 
+	set nsflows_ 0
+	set useasim_ 0
+
+	$self create_packetformat
+	$self use-scheduler Calendar
+	#$self use-scheduler List
+	$self set nullAgent_ [new Agent/Null]
+	$self set-address-format def
+	if {[lindex $args 0] == "-multicast"} {
+		$self multicast $args
+	}
+	eval $self next $args
+}
+
+Simulator instproc nullagent {} {
+	$self instvar nullAgent_
+	return $nullAgent_
+}
+
+Simulator instproc use-scheduler type {
+	$self instvar scheduler_
+	if [info exists scheduler_] {
+		if { [$scheduler_ info class] == "Scheduler/$type" } {
+			return
+		} else {
+			delete $scheduler_
+		}
+	}
+	set scheduler_ [new Scheduler/$type]
+	$scheduler_ now
+}
+
+Simulator instproc delay_parse { spec } {
+	return [time_parse $spec]
+}
+
+Simulator instproc bw_parse { spec } {
+	return [bw_parse $spec]
+}
+
+#
+# A simple method to wrap any object around
+# a trace object that dumps to stdout
+#
+Simulator instproc dumper obj {
+	set t [$self alloc-trace hop stdout]
+	$t target $obj
+	return $t
+}
+
+# New node structure
+#
+# Add APT to support multi-interface: user can specified multiple channels
+# when config nod. Still need modifications in routing agents to make
+# multi-interfaces really work.   -chen xuan  07/21/00
+#
+# Define global node configuration
+# $ns_ node-config -addressType flat/hierarchical
+#                  -adhocRouting   DSDV/DSR/TORA
+#                  -llType
+#                  -macType
+#                  -propType
+#                  -ifqType
+#                  -ifqLen
+#                  -phyType
+#                  -antType
+#		   -channel
+#                  -channelType
+#                  -topologyInstance
+#                  -wiredRouting   ON/OFF
+#                  -mobileIP       ON/OFF
+#                  -energyModel    "EnergyModel"
+#                  -initialEnergy  (in Joules)
+#                  -rxPower        (in W)
+#                  -txPower        (in W)
+#                  -idlePower      (in W)
+#
+#                  -sleepPower 	   (in W)
+#		   -sleepTime	   (in sec indicating when the node can start sleeping)
+#                  -agentTrace  ON
+#                  -routerTrace ON 
+#                  -macTrace OFF 
+#                  -phyTrace OFF 
+#                  -toraDebug OFF                
+#                  -movementTrace OFF
+# change wrt Mike's code
+#                  -eotTrace OFF
+#                  -diffusionFilter "GradientFilter/OnePhasePullFilter/GeoRoutingFilter/RmstFilter/SourceRouteFilter/LogFilter/TagFilter"
+
+
+Simulator instproc addressType  {val} { $self set addressType_  $val }
+Simulator instproc adhocRouting  {val} { $self set routingAgent_  $val }
+Simulator instproc llType  {val} { $self set llType_  $val }
+Simulator instproc macType  {val} { $self set macType_  $val }
+Simulator instproc propType  {val} { $self set propType_  $val }
+Simulator instproc propInstance  {val} { $self set propInstance_  $val }
+Simulator instproc ifqType  {val} { $self set ifqType_  $val }
+Simulator instproc ifqLen  {val} { $self set ifqlen_  $val }
+Simulator instproc phyType  {val} { $self set phyType_  $val }
+Simulator instproc antType  {val} { $self set antType_  $val }
+Simulator instproc channel {val} {$self set channel_ $val}
+Simulator instproc channelType {val} {$self set channelType_ $val}
+Simulator instproc topoInstance {val} {$self set topoInstance_ $val}
+Simulator instproc wiredRouting {val} {$self set wiredRouting_ $val}
+Simulator instproc mobileIP {val} {$self set mobileIP_ $val}
+Simulator instproc energyModel  {val} { $self set energyModel_  $val }
+Simulator instproc initialEnergy  {val} { $self set initialEnergy_  $val }
+Simulator instproc txPower  {val} { $self set txPower_  $val }
+Simulator instproc rxPower  {val} { $self set rxPower_  $val }
+Simulator instproc idlePower  {val} { $self set idlePower_  $val }
+#
+Simulator instproc sleepPower  {val} { $self set sleepPower_  $val }
+Simulator instproc sleepTime  {val} { $self set sleepTime_  $val }
+Simulator instproc transitionPower  {val} { $self set transitionPower_  $val }
+Simulator instproc transitionTime  {val} { $self set transitionTime_  $val }
+#
+Simulator instproc IncomingErrProc  {val} { $self set inerrProc_  $val }
+Simulator instproc OutgoingErrProc  {val} { $self set outerrProc_  $val }
+Simulator instproc FECProc  {val} { $self set FECProc_  $val }
+Simulator instproc agentTrace  {val} { $self set agentTrace_  $val }
+Simulator instproc routerTrace  {val} { $self set routerTrace_  $val }
+Simulator instproc macTrace  {val} { $self set macTrace_  $val }
+Simulator instproc phyTrace  {val} { $self set phyTrace_  $val }
+Simulator instproc movementTrace  {val} { $self set movementTrace_  $val }
+Simulator instproc toraDebug {val} {$self set toraDebug_ $val }
+Simulator instproc satNodeType {val} {$self set satNodeType_ $val}
+Simulator instproc downlinkBW {val} {$self set downlinkBW_ $val}
+Simulator instproc stopTime {val} {$self set stopTime_ $val}
+
+# This method is needed so that new Routing Agents can be implemented in a dynamic
+# library and used without having to modify Simulator::create-wireless-node
+Simulator instproc rtAgentFunction {val} {$self set rtAgentFunction_ $val}
+
+
+# change wrt Mike's code
+Simulator instproc eotTrace  {val} { $self set eotTrace_  $val }
+Simulator instproc diffusionFilter {val} {$self set diffFilter_ $val}
+
+Simulator instproc MPLS { val } { 
+	if { $val == "ON" } {
+		Node enable-module "MPLS"
+	} else {
+		Node disable-module "MPLS"
+	}
+}
+
+
+Simulator instproc PGM { val } { 
+        if { $val == "ON" } {
+                Node enable-module "PGM"
+        } else {
+                Node disable-module "PGM"
+        }
+}
+Simulator instproc LMS { val } {
+	if { $val == "ON" } {
+		Node enable-module "LMS"
+	} else {
+		Node disable-module "LMS"
+	}
+}
+
+Simulator instproc get-nodetype {} {
+	$self instvar addressType_ routingAgent_ wiredRouting_ 
+	set val ""
+
+	if { [info exists addressType_] && $addressType_ == "hierarchical" } {
+		set val Hier
+	}
+	if { [info exists routingAgent_] && $routingAgent_ != "" } {
+		set val Mobile
+	}
+	if { [info exists wiredRouting_] && $wiredRouting_ == "ON" } {
+		set val Base
+	}
+	if { [info exists wiredRouting_] && $wiredRouting_ == "OFF"} {
+		set val Base
+	}
+	if { [Simulator set mobile_ip_] } {
+		if { $val == "Base" && $wiredRouting_ == "ON" } {
+			set val MIPBS
+		}
+		if { $val == "Base" && $wiredRouting_ == "OFF" } {
+			set val MIPMH
+		}
+	}
+	return $val
+}
+
+Simulator instproc node-config args {
+        # Object::init-vars{} is defined in ~tclcl/tcl-object.tcl.
+        # It initializes all default variables in the following way:
+        #  1.  Look for pairs of {-cmd val} in args
+        #  2.  If "$self $cmd $val" is not valid then put it in a list of 
+        #      arguments to be returned to the caller.
+        # 
+        # Since we do not handle undefined {-cmd val} pairs, we ignore 
+        # return value from init-vars{}.
+        set args [eval $self init-vars $args]
+
+        $self instvar addressType_  routingAgent_ propType_  macTrace_ \
+	    routerTrace_ agentTrace_ movementTrace_ channelType_ channel_ \
+	    chan topoInstance_ propInstance_ mobileIP_ \
+	    rxPower_ txPower_ idlePower_ sleepPower_ sleepTime_ transitionPower_ \
+	    transitionTime_ satNodeType_ eotTrace_ phyTrace_
+
+	if [info exists phyTrace_] {
+		Simulator set PhyTrace_ $phyTrace_
+	}
+
+
+        if [info exists macTrace_] {
+		Simulator set MacTrace_ $macTrace_
+	}
+        if [info exists routerTrace_] {
+		Simulator set RouterTrace_ $routerTrace_
+	}
+        if [info exists agentTrace_] {
+		Simulator set AgentTrace_ $agentTrace_
+	}
+        if [info exists movementTrace_] {
+		Simulator set MovementTrace_ $movementTrace_
+	}
+
+	# change wrt Mike's code
+	if [info exists eotTrace_] {
+                Simulator set EotTrace_ $eotTrace_
+        }
+
+        # hacking for matching old cmu add-interface
+        # not good style, for back-compability ONLY
+	#
+	# Only create 1 instance of prop
+	if {[info exists propInstance_]} {
+		if {[info exists propType_] && [Simulator set propInstCreated_] == 0} {
+			warn "Both propType and propInstance are set. propType is ignored."
+		}
+	} else {
+		if {[info exists propType_]} {
+			set propInstance_ [new $propType_]
+			Simulator set propInstCreated_ 1
+		}
+	}
+	
+	# Add multi-interface support:
+ 	# User can only specify either channelType_ (single_interface as 
+	# before) or channel_ (multi_interface)
+ 	# If both variables are specified, error!
+ 	if {[info exists channelType_] && [info exists channel_]} { 
+		error "Can't specify both channel and channelType, error!"
+	} elseif {[info exists channelType_] && ![info exists satNodeType_]} {
+		# Single channel, single interface
+		warn "Please use -channel as shown in tcl/ex/wireless-mitf.tcl"
+		if {![info exists chan]} {
+			set chan [new $channelType_]
+		}
+ 	} elseif {[info exists channel_]} {
+		# Multiple channel, multiple interfaces
+		set chan $channel_
+ 	}
+	if [info exists topoInstance_] {
+		$propInstance_  topography $topoInstance_
+	}
+	# set address type, hierarchical or expanded
+	if {[string compare $addressType_ ""] != 0} {
+		$self set-address-format $addressType_ 
+	}
+	# set mobileIP flag
+	if { [info exists mobileIP_] && $mobileIP_ == "ON"} {
+		Simulator set mobile_ip_  1
+	} else {
+		if { [info exists mobileIP_] } {
+			Simulator set mobile_ip_ 0
+		}
+	}
+}
+
+# Default behavior is changed: consider nam as not initialized if 
+# no shape OR color parameter is given
+Simulator instproc node args {
+	$self instvar Node_ routingAgent_ wiredRouting_ satNodeType_
+        if { [Simulator info vars EnableMcast_] != "" } {
+                warn "Flag variable Simulator::EnableMcast_ discontinued.\n\t\
+                      Use multicast methods as:\n\t\t\
+                        % set ns \[new Simulator -multicast on]\n\t\t\
+                        % \$ns multicast"
+                $self multicast
+                Simulator unset EnableMcast_
+        }
+        if { [Simulator info vars NumberInterfaces_] != "" } {
+                warn "Flag variable Simulator::NumberInterfaces_ discontinued.\n\t\
+                      Setting this variable will not affect simulations."
+                Simulator unset NumberInterfaces_
+        }
+
+	# Satellite node
+	if { [info exists satNodeType_] } {
+		set node [eval $self create-satnode]
+		#simulator's nodelist in C++ space
+		if {[info exists wiredRouting_] && $wiredRouting_ == "ON"} {
+			# add node to simulator's nodelist in C++ space
+			$self add-node $node [$node id]
+			# Want to keep global state of wiredRouting info
+			SatRouteObject set wiredRouting_ true
+		}
+		return $node
+	}
+	
+	# wireless-ready node
+	if { [info exists routingAgent_] && ($routingAgent_ != "") } {
+		set node [eval $self create-wireless-node $args]
+		# for base node
+		if {[info exists wiredRouting_] && $wiredRouting_ == "ON"} {
+			set Node_([$node id]) $node
+			#simulator's nodelist in C++ space
+			$self add-node $node [$node id] 
+		}
+		return $node
+	}
+	
+
+	# Enable-mcast is now done automatically inside Node::init{}
+	# 
+	# XXX node_factory_ is deprecated, HOWEVER, since it's still used by
+	# mobile IP, algorithmic routing, manual routing, and backward 
+	# compability tests of hierarchical routing, we should keep it around
+	# before all related code are wiped out.
+	set node [eval new [Simulator set node_factory_] $args]
+	set Node_([$node id]) $node
+	
+	#add to simulator's nodelist in C++ space
+	$self add-node $node [$node id] 
+
+	#set the nodeid in c++ Node - ratul
+	$node nodeid [$node id]
+
+	$node set ns_ $self
+	$self check-node-num
+	return $node
+}
+
+# XXX This is stupid hack. When old code (not using node-config) is used, 
+# create-wireless-node{} will not be called, and IMEPFlag_ will remain empty
+# (as set in ns-default.tcl), then Node/MobileNode will use global proc 
+# cmu-trace to create trace objects; otherwise mobility-trace{} will be 
+# triggered.
+Simulator instproc imep-support {} {
+	return [Simulator set IMEPFlag_]
+}
+
+# XXX This should be moved into the node initialization procedure instead 
+# of standing here in ns-lib.tcl.
+Simulator instproc create-wireless-node args {
+        $self instvar routingAgent_ wiredRouting_ propInstance_ llType_ \
+	    macType_ ifqType_ ifqlen_ phyType_ chan antType_ \
+	    energyModel_ initialEnergy_ txPower_ rxPower_ \
+	    idlePower_ sleepPower_ sleepTime_ transitionPower_ transitionTime_ \
+	    topoInstance_ level1_ level2_ inerrProc_ outerrProc_ FECProc_ rtAgentFunction_
+
+	Simulator set IMEPFlag_ OFF
+
+        # create node instance
+        set node [eval $self create-node-instance $args]
+        
+        # basestation address setting
+        if { [info exist wiredRouting_] && $wiredRouting_ == "ON" } {
+		$node base-station [AddrParams addr2id [$node node-addr]]
+    	}
+        if {$rtAgentFunction_ != ""} {
+		set ragent [$self $rtAgentFunction_ $node]
+	} else {
+		switch -exact $routingAgent_ {
+		    DSDV {
+			    set ragent [$self create-dsdv-agent $node]
+		    }
+		    DSR {
+			    $self at 0.0 "$node start-dsr"
+		    }
+		    AODV {
+			    set ragent [$self create-aodv-agent $node]
+		    }
+		    AOMDV {
+			    set ragent [$self create-aomdv-agent $node]
+		    }
+		    TORA {
+			    Simulator set IMEPFlag_ ON
+			    set ragent [$self create-tora-agent $node]
+		    }
+		    DIFFUSION/RATE {
+			    eval $node addr $args
+			    set ragent [$self create-diffusion-rate-agent $node]
+		    }
+		    DIFFUSION/PROB {
+			    eval $node addr $args
+			    set ragent [$self create-diffusion-probability-agent $node]
+		    }
+		    Directed_Diffusion {
+			    eval $node addr $args
+			    set ragent [$self create-core-diffusion-rtg-agent $node]
+		    }
+		    FLOODING {
+			    eval $node addr $args
+			    set ragent [$self create-flooding-agent $node]
+		    }
+		    OMNIMCAST {
+			    eval $node addr $args
+			    set ragent [$self create-omnimcast-agent $node]
+		    }
+		    DumbAgent {
+			    set ragent [$self create-dumb-agent $node]
+		    }
+		    ManualRtg {
+			    set ragent [$self create-manual-rtg-agent $node]
+		    }
+		    FSR {
+			    set ragent [$self create-fsr-agent $node]
+		    }
+		    default {
+			    eval $node addr $args
+			    puts "Wrong node routing agent!"
+			    exit
+		    }
+		}
+	}
+
+	# errProc_ and FECProc_ are an option unlike other 
+        # parameters for node interface
+	if ![info exist inerrProc_] {
+		set inerrProc_ ""
+	}
+	if ![info exist outerrProc_] {
+		set outerrProc_ ""
+	}
+	if ![info exist FECProc_] {
+		set FECProc_ ""
+	}
+
+	
+
+	# Add main node interface
+	$node add-interface $chan $propInstance_ $llType_ $macType_ \
+	    $ifqType_ $ifqlen_ $phyType_ $antType_ $topoInstance_ \
+			$inerrProc_ $outerrProc_ $FECProc_
+	# Attach agent
+	if {$routingAgent_ != "DSR"} {
+		$node attach $ragent [Node set rtagent_port_]
+	}
+	if {$routingAgent_ == "DIFFUSION/RATE" ||
+            $routingAgent_ == "DIFFUSION/PROB" ||
+            $routingAgent_ == "FLOODING" ||
+            $routingAgent_ == "OMNIMCAST" ||
+	    $routingAgent_ == "Directed_Diffusion" } {
+		$ragent port-dmux [$node demux]
+		$node instvar ll_
+		$ragent add-ll $ll_(0)
+	}
+	if { $routingAgent_ == "DumbAgent" } {
+		$ragent port-dmux [$node demux]
+	}
+	
+
+	# Bind routing agent and mip agent if existing basestation 
+	# address setting
+        if { [info exist wiredRouting_] && $wiredRouting_ == "ON" } {
+		if { $routingAgent_ != "DSR" } {
+			$node mip-call $ragent
+		}
+	}
+	#
+        # This Trace Target is used to log changes in direction
+        # and velocity for the mobile node.
+        #
+	set tracefd [$self get-ns-traceall]
+        if {$tracefd != "" } {
+		$node nodetrace $tracefd
+		$node agenttrace $tracefd
+	}
+	set namtracefd [$self get-nam-traceall]
+	if {$namtracefd != "" } {
+		$node namattach $namtracefd
+	}
+	if [info exists energyModel_] {
+		if  [info exists level1_] {
+			set l1 $level1_
+		} else {
+			set l1 0.5
+		}
+		if  [info exists level2_] {
+			set l2 $level2_
+		} else {
+			set l2 0.2
+		}
+		$node addenergymodel [new $energyModel_ $node \
+				$initialEnergy_ $l1 $l2]
+        }
+        if [info exists txPower_] {
+		$node setPt $txPower_
+        }
+        if [info exists rxPower_] {
+		$node setPr $rxPower_
+        }
+        if [info exists idlePower_] {
+		$node setPidle $idlePower_
+        }
+#
+	if [info exists sleepPower_] {
+		$node setPsleep $sleepPower_
+        }
+	if [info exists sleepTime_] {
+		$node setTSleep $sleepTime_
+        }
+	if [info exists transitionPower_] {
+		$node setPtransition $transitionPower_
+        }
+	if [info exists transitionTime_] {
+		$node setTtransition $transitionTime_
+        }	
+#
+	$node topography $topoInstance_
+	
+	return $node
+}
+
+Simulator instproc create-node-instance args {
+	$self instvar routingAgent_
+	# DSR is a special case
+	if {$routingAgent_ == "DSR"} {
+		set nodeclass [$self set-dsr-nodetype]
+	} else {
+		set nodeclass Node/MobileNode
+	}
+	return [eval new $nodeclass $args]
+}
+
+Simulator instproc set-dsr-nodetype {} {
+	$self instvar wiredRouting_ 
+	set nodetype SRNodeNew
+	# MIP mobilenode
+	if [Simulator set mobile_ip_] {
+		set nodetype SRNodeNew/MIPMH
+	} 
+	# basestation dsr node
+	if { [info exists wiredRouting_] && $wiredRouting_ == "ON"} {
+		set nodetype Node/MobileNode/BaseStationNode
+	}
+	return $nodetype
+}
+
+Simulator instproc create-tora-agent { node } {
+        set ragent [new Agent/TORA [$node id]]
+	$node set ragent_ $ragent
+	return $ragent
+}
+
+Simulator instproc create-dsdv-agent { node } {
+	# Create a dsdv routing agent for this node
+	set ragent [new Agent/DSDV]
+	# Setup address (supports hier-addr) for dsdv agent
+	# and mobilenode
+	set addr [$node node-addr]
+	$ragent addr $addr
+	$ragent node $node
+	if [Simulator set mobile_ip_] {
+		$ragent port-dmux [$node demux]
+	}
+	$node addr $addr
+	$node set ragent_ $ragent
+	$self at 0.0 "$ragent start-dsdv"    ;# start updates
+	return $ragent
+}
+
+
+Simulator instproc create-dumb-agent { node } {
+	
+	# create a simple wireless agent
+	# that only forwards packets
+	# used for testing single hop brdcast/unicast mode 
+	# for wireless macs
+
+	set ragent [new Agent/DumbAgent]
+	$node set ragent_ $ragent
+	
+	return $ragent
+}
+
+Simulator instproc create-manual-rtg-agent { node } {
+	
+	# create a simple wireless agent
+	# that only forwards packets
+	# used for testing single hop brdcast/unicast mode 
+	# for wireless macs
+
+	set ragent [new Agent/ManualRtgAgent]
+	$node set ragent_ $ragent
+	$node attach $ragent [Node set rtagent_port_]
+	
+	return $ragent
+}
+
+Simulator instproc create-aodv-agent { node } {
+        #  Create AODV routing agent
+	set ragent [new Agent/AODV [$node node-addr]]
+        $self at 0.0 "$ragent start"     ;# start BEACON/HELLO Messages
+        $node set ragent_ $ragent
+        return $ragent
+}
+
+# AOMDV patch
+Simulator instproc create-aomdv-agent { node } {
+	set ragent [new Agent/AOMDV [$node node-addr]]
+	$self at 0.0 "$ragent start"
+	$node set ragent_ $ragent
+	return $ragent
+}
+
+Simulator instproc use-newtrace {} {
+	Simulator set WirelessNewTrace_ 1
+} 
+
+Simulator instproc use-taggedtrace { {tag ON} } {
+	Simulator set TaggedTrace_ $tag
+}
+
+Simulator instproc hier-node haddr {
+ 	error "hier-nodes should be created with [$ns_ node $haddr]"
+}
+
+Simulator instproc now {} {
+	$self instvar scheduler_
+	return [$scheduler_ now]
+}
+
+Simulator instproc at args {
+	$self instvar scheduler_
+	return [eval $scheduler_ at $args]
+}
+
+Simulator instproc at-now args {
+	$self instvar scheduler_
+	return [eval $scheduler_ at-now $args]
+}
+
+Simulator instproc cancel args {
+	$self instvar scheduler_
+	return [eval $scheduler_ cancel $args]
+}
+
+Simulator instproc after {ival args} {
+        eval $self at [expr [$self now] + $ival] $args
+}
+
+#
+# check if total num of nodes exceed 2 to the power n 
+# where <n=node field size in address>
+#
+Simulator instproc check-node-num {} {
+	if {[Node set nn_] > [expr pow(2, [AddrParams nodebits])]} {
+		error "Number of nodes exceeds node-field-size of [AddrParams nodebits] bits"
+	}
+}
+
+#
+# Check if number of items at each hier level (num of nodes, or clusters or
+# domains) exceed size of that hier level field size (in bits). should be 
+# modified to support n-level of hierarchies
+#
+Simulator instproc chk-hier-field-lengths {} {
+	AddrParams instvar domain_num_ cluster_num_ nodes_num_
+	if [info exists domain_num_] {
+		if {[expr $domain_num_ - 1]> [AddrParams NodeMask 1]} {
+			error "\# of domains exceed dom-field-size "
+		}
+	} 
+	if [info exists cluster_num_] {
+		set maxval [expr [find-max $cluster_num_] - 1] 
+		if {$maxval > [expr pow(2, [AddrParams NodeMask 2])]} {
+			error "\# of clusters exceed clus-field-size "
+		}
+	}
+	if [info exists nodes_num_] {
+		set maxval [expr [find-max $nodes_num_] -1]
+		if {$maxval > [expr pow(2, [AddrParams NodeMask 3])]} {
+			error "\# of nodess exceed node-field-size"
+		}
+	}
+}
+
+
+Simulator instproc check-smac {} {
+	$self instvar macType_
+	if { [info exist macType_] && $macType_ == "Mac/SMAC" } {
+		if { [$macType_ set syncFlag_] } {
+			puts "\nNOTE: SMAC is running with sleep-wakeup cycles on. Please make sure to run yr applications AFTER the nodes get sync'ed which is about 40sec for the default settings.\n"
+		}
+	}
+}
+			
+
+Simulator instproc run {} {
+	# NIXVECTOR?
+	# global runstart
+	# set runstart [clock seconds]
+	$self check-smac                      ;# print warning if in sleep/wakeup cycle
+	$self check-node-num
+	$self rtmodel-configure			;# in case there are any
+	[$self get-routelogic] configure
+	$self instvar scheduler_ Node_ link_ started_ 
+	
+	set started_ 1
+	
+	#
+	# Reset every node, which resets every agent.
+	#
+
+	foreach nn [array names Node_] {
+		$Node_($nn) reset
+		# GFR Additions for NixVector Routing
+		if { [Simulator set nix-routing] } {
+			$Node_($nn) populate-objects
+		}
+	}
+
+	#
+	# Also reset every queue
+	#
+
+	foreach qn [array names link_] {
+		set q [$link_($qn) queue]
+		$q reset
+	}
+
+	# Do all nam-related initialization here
+	$self init-nam
+
+	# NIXVECTOR xxx?
+	# global simstart
+	# set simstart [clock seconds]
+	return [$scheduler_ run]
+}
+
+# johnh xxx?
+Simulator instproc log-simstart { } {
+        # GFR Modification to log actual start
+        global simstart
+        puts "Starting Actual Simulation"
+        set simstart [clock seconds]
+}
+
+Simulator instproc halt {} {
+	$self instvar scheduler_
+	#puts "time: [clock format [clock seconds] -format %X]"
+	$scheduler_ halt
+}
+
+Simulator instproc dumpq {} {
+	$self instvar scheduler_
+	$scheduler_ dumpq
+}
+
+Simulator instproc is-started {} {
+	$self instvar started_
+	return [info exists started_]
+}
+
+Simulator instproc clearMemTrace {} {
+	$self instvar scheduler_
+	$scheduler_ clearMemTrace
+}
+
+Simulator instproc simplex-link { n1 n2 bw delay qtype args } {
+	$self instvar link_ queueMap_ nullAgent_ useasim_
+	set sid [$n1 id]
+	set did [$n2 id]
+
+	# Debo
+	if { $useasim_ == 1 } {
+		set slink_($sid:$did) $self
+	}
+
+	if [info exists queueMap_($qtype)] {
+		set qtype $queueMap_($qtype)
+	}
+	# construct the queue
+	set qtypeOrig $qtype
+	switch -exact $qtype {
+		ErrorModule {
+			if { [llength $args] > 0 } {
+				set q [eval new $qtype $args]
+			} else {
+				set q [new $qtype Fid]
+			}
+		}
+		intserv {
+			set qtype [lindex $args 0]
+			set q [new Queue/$qtype]
+		}
+		default {
+			if { [llength $args] == 0} {
+				set q [new Queue/$qtype]
+			} else {
+				set q [new Queue/$qtype $args]
+			}
+		}
+	}
+	# Now create the link
+	switch -exact $qtypeOrig {
+		RTM {
+                        set c [lindex $args 1]
+                        set link_($sid:$did) [new CBQLink       \
+                                        $n1 $n2 $bw $delay $q $c]
+                }
+                CBQ -
+                CBQ/WRR {
+                        # assume we have a string of form "linktype linkarg"
+                        if {[llength $args] == 0} {
+                                # default classifier for cbq is just Fid type
+                                set c [new Classifier/Hash/Fid 33]
+                        } else {
+                                set c [lindex $args 0]
+                        }
+                        set link_($sid:$did) [new CBQLink       \
+                                        $n1 $n2 $bw $delay $q $c]
+                }
+		FQ      {
+			set link_($sid:$did) [new FQLink $n1 $n2 $bw $delay $q]
+		}
+                intserv {
+                        #XX need to clean this up
+                        set link_($sid:$did) [new IntServLink   \
+                                        $n1 $n2 $bw $delay $q	\
+						[concat $qtypeOrig $args]]
+                }
+                default {
+                        set link_($sid:$did) [new SimpleLink    \
+                                        $n1 $n2 $bw $delay $q]
+                }
+        }
+	if {$qtype == "RED/Pushback"} {
+		set pushback 1
+	} else {
+		set pushback 0
+	}
+	$n1 add-neighbor $n2 $pushback
+	
+	#XXX yuck
+	if {[string first "RED" $qtype] != -1 || 
+	    [string first "PI" $qtype] != -1 || 
+	    [string first "Vq" $qtype] != -1 ||
+	    [string first "REM" $qtype] != -1 ||  
+	    [string first "GK" $qtype] != -1 ||  
+	    [string first "RIO" $qtype] != -1 ||
+	    [string first "XCP" $qtype] != -1} {
+		$q link [$link_($sid:$did) set link_]
+	}
+
+	set trace [$self get-ns-traceall]
+	if {$trace != ""} {
+		$self trace-queue $n1 $n2 $trace
+	}
+	set trace [$self get-nam-traceall]
+	if {$trace != ""} {
+		$self namtrace-queue $n1 $n2 $trace
+	}
+	
+	# Register this simplex link in nam link list. Treat it as 
+	# a duplex link in nam
+	$self register-nam-linkconfig $link_($sid:$did)
+}
+
+#
+# This is used by Link::orient to register/update the order in which links 
+# should created in nam. This is important because different creation order
+# may result in different layout.
+#
+# A poor hack. :( Any better ideas?
+#
+Simulator instproc register-nam-linkconfig link {
+	$self instvar linkConfigList_ link_
+	if [info exists linkConfigList_] {
+		# Check whether the reverse simplex link is registered,
+		# if so, don't register this link again.
+		# We should have a separate object for duplex link.
+		set i1 [[$link src] id]
+		set i2 [[$link dst] id]
+		if [info exists link_($i2:$i1)] {
+			set pos [lsearch $linkConfigList_ $link_($i2:$i1)]
+			if {$pos >= 0} {
+				set a1 [$link_($i2:$i1) get-attribute \
+						"ORIENTATION"]
+				set a2 [$link get-attribute "ORIENTATION"]
+				if {$a1 == "" && $a2 != ""} {
+					# If this duplex link has not been 
+					# assigned an orientation, do it.
+					set linkConfigList_ [lreplace \
+						$linkConfigList_ $pos $pos]
+				} else {
+					return
+				}
+			}
+		}
+		# Remove $link from list if it's already there
+		set pos [lsearch $linkConfigList_ $link]
+		if {$pos >= 0} {
+			set linkConfigList_ \
+					[lreplace $linkConfigList_ $pos $pos]
+		}
+	}
+	lappend linkConfigList_ $link
+}
+
+#
+# GT-ITM may occasionally generate duplicate links, so we need this check
+# to ensure duplicated links do not appear in nam trace files.
+#
+Simulator instproc remove-nam-linkconfig {i1 i2} {
+	$self instvar linkConfigList_ link_
+	if ![info exists linkConfigList_] {
+		return
+	}
+	set pos [lsearch $linkConfigList_ $link_($i1:$i2)]
+	if {$pos >= 0} {
+		set linkConfigList_ [lreplace $linkConfigList_ $pos $pos]
+		return
+	}
+	set pos [lsearch $linkConfigList_ $link_($i2:$i1)]
+	if {$pos >= 0} {
+		set linkConfigList_ [lreplace $linkConfigList_ $pos $pos]
+	}
+}
+
+# Armando L. Caro Jr. <acaro@@cis,udel,edu> 10/22/2001
+#
+# we create a simplex link (NOT duplex) from the core to the interface. we can
+# use arbitrary params (bw, delay, etc) since we'll never actually transmit
+# data on these links. they are only used for routing (ie, to determine which 
+# interface a packet should go out from)
+#
+Simulator instproc multihome-add-interface { core if } {
+  	$self instvar link_
+  	set coreId [$core id]
+  	set ifId [$if id]
+
+	# arbitrary values (doesn't matter since link will NEVER be used!)
+	set bw 1Mb
+	set delay 100ms
+	set type DropTail
+
+	if [info exists link_($coreId:$ifId)] {
+		$self remove-nam-linkconfig $coreId $ifId
+	}
+	eval $self simplex-link $core $if $bw $delay $type 
+	# Modified by GFR for nix-vector routing
+	if { [Simulator set nix-routing] } {
+		# Inform nodes of neighbors
+		$n1 set-neighbor [$core id]
+		$n2 set-neighbor [$if id]
+	}
+
+
+    	$core instvar multihome_interfaces_ num_interfaces_
+    	set interface_ {}
+
+    	# interface node
+    	lappend interface_ $if
+
+    	# link from interface node to core node
+    	lappend interface_ [$link_($coreId:$ifId) set head_]
+
+    	lappend multihome_interfaces_ $interface_
+}
+
+Simulator instproc duplex-link { n1 n2 bw delay type args } {
+	$self instvar link_
+	set i1 [$n1 id]
+	set i2 [$n2 id]
+	if [info exists link_($i1:$i2)] {
+		$self remove-nam-linkconfig $i1 $i2
+	}
+	eval $self simplex-link $n1 $n2 $bw $delay $type $args
+	eval $self simplex-link $n2 $n1 $bw $delay $type $args
+	# Modified by GFR for nix-vector routing
+	if { [Simulator set nix-routing] } {
+		# Inform nodes of neighbors
+		$n1 set-neighbor [$n2 id]
+		$n2 set-neighbor [$n1 id]
+	}
+}
+
+Simulator instproc duplex-intserv-link { n1 n2 bw pd sched signal adc args } {
+	eval $self duplex-link $n1 $n2 $bw $pd intserv $sched $signal $adc $args
+}
+
+Simulator instproc simplex-link-op { n1 n2 op args } {
+	$self instvar link_
+	eval $link_([$n1 id]:[$n2 id]) $op $args
+}
+
+Simulator instproc duplex-link-op { n1 n2 op args } {
+	$self instvar link_
+	eval $link_([$n1 id]:[$n2 id]) $op $args
+	eval $link_([$n2 id]:[$n1 id]) $op $args
+}
+
+Simulator instproc flush-trace {} {
+	$self instvar alltrace_
+	if [info exists alltrace_] {
+		foreach trace $alltrace_ {
+			$trace flush
+		}
+	}
+}
+
+Simulator instproc namtrace-all file   {
+	$self instvar namtraceAllFile_
+	if {$file != ""} {
+		set namtraceAllFile_ $file
+	} else {
+		unset namtraceAllFile_
+	}
+}
+
+Simulator instproc energy-color-change {level1 level2} {
+	$self instvar level1_ level2_
+ 	set level1_ $level1
+ 	set level2_ $level2
+}
+
+Simulator instproc namtrace-all-wireless {file optx opty} {
+        $self instvar namtraceAllFile_
+
+	# indicate that we need a W event written to the trace
+	$self set namNeedsW_ 1
+	if { $optx != "" && $opty != "" } {
+		$self set namWx_ $optx
+		$self set namWy_ $opty
+	}
+
+	$self namtrace-all $file
+}
+
+Simulator instproc nam-end-wireless {stoptime} {
+        $self instvar namtraceAllFile_
+
+        if {$namtraceAllFile_ != ""} {
+		$self puts-nam-config "W -t $stoptime"
+        }
+}
+
+Simulator instproc namtrace-some file {
+	$self instvar namtraceSomeFile_
+	set namtraceSomeFile_ $file
+}
+
+# Support for event-tracing
+        
+Simulator instproc eventtrace-all {{file ""}} {
+	$self instvar eventTraceAll_ eventtraceAllFile_ traceAllFile_
+	set eventTraceAll_ 1
+	if {$file != ""} {
+		set eventtraceAllFile_ $file
+	} else {
+		set eventtraceAllFile_ $traceAllFile_
+	}
+	
+}
+
+
+
+Simulator instproc initial_node_pos {nodep size} {
+	$self instvar addressType_
+	$self instvar energyModel_ 
+
+	if [info exists energyModel_] {  
+		set nodeColor "green"
+	} else {
+		set nodeColor "black"
+	}
+	if { [info exists addressType_] && $addressType_ == "hierarchical" } {
+		# Hierarchical addressing
+		$self puts-nam-config "n -t * -a [$nodep set address_] \
+-s [$nodep id] -x [$nodep set X_] -y [$nodep set Y_] -Z [$nodep set Z_] \
+-z $size -v circle -c $nodeColor"
+	} else { 
+		# Flat addressing
+		$self puts-nam-config "n -t * -s [$nodep id] \
+-x [$nodep set X_] -y [$nodep set Y_] -Z [$nodep set Z_] -z $size \
+-v circle -c $nodeColor"
+	}
+}
+
+Simulator instproc trace-all file {
+	$self instvar traceAllFile_
+	set traceAllFile_ $file
+}
+
+Simulator instproc get-nam-traceall {} {
+	$self instvar namtraceAllFile_
+	if [info exists namtraceAllFile_] {
+		return $namtraceAllFile_
+	} else {
+		return ""
+	}
+}
+
+Simulator instproc get-ns-traceall {} {
+	$self instvar traceAllFile_
+	if [info exists traceAllFile_] {
+		return $traceAllFile_
+	} else {
+		return ""
+	}
+}
+
+# If exists a traceAllFile_, print $str to $traceAllFile_
+Simulator instproc puts-ns-traceall { str } {
+	$self instvar traceAllFile_
+	if [info exists traceAllFile_] {
+		puts $traceAllFile_ $str
+	}
+}
+
+# If exists a traceAllFile_, print $str to $traceAllFile_
+Simulator instproc puts-nam-traceall { str } {
+	$self instvar namtraceAllFile_
+	if [info exists namtraceAllFile_] {
+		puts $namtraceAllFile_ $str
+	} elseif [info exists namtraceSomeFile_] {
+		puts $namtraceSomeFile_ $str
+	}
+}
+
+# namConfigFile is used for writing color/link/node/queue/annotations. 
+# XXX It cannot co-exist with namtraceAll.
+Simulator instproc namtrace-config { f } {
+	$self instvar namConfigFile_
+	set namConfigFile_ $f
+}
+
+Simulator instproc get-nam-config {} {
+	$self instvar namConfigFile_
+	if [info exists namConfigFile_] {
+		return $namConfigFile_
+	} else {
+		return ""
+	}
+}
+
+# Used only for writing nam configurations to trace file(s). This is different
+# from puts-nam-traceall because we may want to separate configuration 
+# informations and actual tracing information
+Simulator instproc puts-nam-config { str } {
+	$self instvar namtraceAllFile_ namConfigFile_
+	
+	if [info exists namConfigFile_] {
+		puts $namConfigFile_ $str
+	} elseif [info exists namtraceAllFile_] {
+		puts $namtraceAllFile_ $str
+	} elseif [info exists namtraceSomeFile_] {
+		puts $namtraceSomeFile_ $str
+	}
+}
+
+Simulator instproc color { id name } {
+	$self instvar color_
+	set color_($id) $name
+}
+
+Simulator instproc get-color { id } {
+	$self instvar color_
+	return $color_($id)
+}
+
+# you can pass in {} as a null file
+Simulator instproc create-trace { type file src dst {op ""} } {
+	$self instvar alltrace_
+	set p [new Trace/$type]
+	$p tagged [Simulator set TaggedTrace_]
+	if [catch {$p set src_ [$src id]}] {
+		$p set src_ $src
+	}
+	if [catch {$p set dst_ [$dst id]}] {
+		$p set dst_ $dst
+	}
+	lappend alltrace_ $p
+	if {$file != ""} {
+		$p ${op}attach $file		
+	}
+	return $p
+}
+
+
+Simulator instproc create-eventtrace {type owner } {
+	$self instvar alltrace_ 
+	$self instvar eventTraceAll_ eventtraceAllFile_ namtraceAllFile_
+	
+	if ![info exists eventTraceAll_] return
+
+	if { $eventTraceAll_ == 1 } {
+		
+		set et [new BaseTrace/$type]
+		$owner cmd eventtrace $et
+		
+		lappend alltrace_ $et
+		$et attach $eventtraceAllFile_
+		if [info exists namtraceAllFile_] {
+			$et namattach $namtraceAllFile_
+		}
+	}
+}
+
+
+Simulator instproc namtrace-queue { n1 n2 {file ""} } {
+	$self instvar link_ namtraceAllFile_
+	if {$file == ""} {
+		if ![info exists namtraceAllFile_] return
+		set file $namtraceAllFile_
+	}
+	$link_([$n1 id]:[$n2 id]) nam-trace $self $file
+    
+	# Added later for queue specific tracing events other than enque, 
+	# deque and drop as of now nam does not understand special events. 
+	# Changes will have to be made to nam for it to understand events 
+	# like early drops if they are prefixed differently than "d". - ratul
+	set queue [$link_([$n1 id]:[$n2 id]) queue]
+	$queue attach-nam-traces $n1 $n2 $file
+}
+
+Simulator instproc trace-queue { n1 n2 {file ""} } {
+	$self instvar link_ traceAllFile_
+	if {$file == ""} {
+		if ![info exists traceAllFile_] return
+		set file $traceAllFile_
+	}
+	$link_([$n1 id]:[$n2 id]) trace $self $file
+	
+	# Added later for queue specific tracing events other than enque, 
+	# deque and drop - ratul
+	set queue [$link_([$n1 id]:[$n2 id]) queue]
+	$queue attach-traces $n1 $n2 $file
+}
+
+#
+# arrange for queue length of link between nodes n1 and n2
+# to be tracked and return object that can be queried
+# to learn average q size etc.  XXX this API still rough
+#
+Simulator instproc monitor-queue { n1 n2 qtrace { sampleInterval 0.1 } } {
+	$self instvar link_
+	return [$link_([$n1 id]:[$n2 id]) init-monitor $self $qtrace $sampleInterval]
+}
+
+Simulator instproc queue-limit { n1 n2 limit } {
+	$self instvar link_
+	[$link_([$n1 id]:[$n2 id]) queue] set limit_ $limit
+	if {[[$link_([$n1 id]:[$n2 id]) queue] info class] == "Queue/XCP"} {
+		[$link_([$n1 id]:[$n2 id]) queue] queue-limit $limit
+	}
+}
+
+Simulator instproc drop-trace { n1 n2 trace } {
+	$self instvar link_
+	[$link_([$n1 id]:[$n2 id]) queue] drop-target $trace
+}
+
+Simulator instproc cost {n1 n2 c} {
+	$self instvar link_
+	$link_([$n1 id]:[$n2 id]) cost $c
+}
+
+# Armando L. Caro Jr. <acaro@@cis,udel,edu> 10/22/2001
+Simulator instproc multihome-attach-agent { core agent } {
+      	$agent set-multihome-core [$core entry]
+
+      	foreach interface [$core set multihome_interfaces_] {
+  		set ifNode [lindex $interface 0]
+		set coreLink [lindex $interface 1]
+
+      		# attach agent to the node for each interface
+      		$ifNode attach $agent
+      		set addr [$agent set agent_addr_]
+      		set port [$agent set agent_port_]
+      		set entry [$ifNode entry]
+
+      		# give the interface info to the agent
+		$agent add-multihome-interface $addr $port $entry $coreLink
+			
+      		$agent instvar multihome_bindings_
+      		set binding_ {}
+      		lappend binding_ $addr
+      		lappend binding_ $port
+      		lappend multihome_bindings_ $binding_
+      	}
+}
+
+Simulator instproc attach-agent { node agent } {
+	$node attach $agent
+	# $agent set nodeid_ [$node id]
+
+        # Armando L. Caro Jr. <acaro@@cis,udel,edu> 10/22/2001 
+	#
+	# list of tuples (addr, port)
+	# This is NEEDED so that single homed agents can play with multihomed
+	# ones!
+	# multihoming only for SCTP agents -Padma H.
+	if {[lindex [split [$agent info class] "/"] 1] == "SCTP"} {
+		$agent instvar multihome_bindings_
+		set binding_ {}
+		set addr [$agent set agent_addr_]
+		set port [$agent set agent_port_]
+		lappend binding_ $addr
+		lappend binding_ $port
+		lappend multihome_bindings_ $binding_
+	}
+}
+
+Simulator instproc attach-tbf-agent { node agent tbf } {
+	$node attach $agent
+	$agent attach-tbf $tbf
+}
+
+
+Simulator instproc detach-agent { node agent } {
+
+	# Debo added this
+	$self instvar conn_ nconn_ sflows_ nsflows_ useasim_
+
+	if {$useasim_ == 1} {
+		set list "" 
+		set s [$node id]
+		set d [[$self get-node-by-addr [$agent set dst_addr_]] id]
+		foreach x $conn_ {
+			set t [split $x ":"] 
+			if {[string compare [lindex $t 0]:[lindex $t 1] $s:$d] != 0} {
+				lappend list_ $x
+			}
+		}
+		set conn_ list
+		set nconn_ [expr $nconn_ -1]
+		# ---------------------------------------
+	}
+
+	$self instvar nullAgent_
+	$node detach $agent $nullAgent_
+}
+
+#
+#   Helper proc for setting delay on an existing link
+#
+Simulator instproc delay { n1 n2 delay {type simplex} } {
+	$self instvar link_
+	set sid [$n1 id]
+	set did [$n2 id]
+	if [info exists link_($sid:$did)] {
+		set d [$link_($sid:$did) link]
+		$d set delay_ $delay
+	}
+	if {$type == "duplex"} {
+		if [info exists link_($did:$sid)] {
+			set d [$link_($did:$sid) link]
+			$d set delay_ $delay
+		}
+	}
+}
+
+# 
+#   Helper proc for setting bandwidth on an existing link
+#
+Simulator instproc bandwidth { n1 n2 bandwidth {type simplex} } {
+        $self instvar link_
+        set sid [$n1 id]
+        set did [$n2 id]
+        if [info exists link_($sid:$did)] {
+                set d [$link_($sid:$did) link]
+                $d set bandwidth_ $bandwidth
+        } 
+        if {$type == "duplex"} {
+                if [info exists link_($did:$sid)] {
+                        set d [$link_($did:$sid) link]
+                        $d set bandwidth_ $bandwidth
+                }
+        }
+}
+
+
+#XXX need to check that agents are attached to nodes already
+Simulator instproc connect {src dst} {
+
+	$self instvar conn_ nconn_ sflows_ nsflows_ useasim_
+
+        # Armando L. Caro Jr. <acaro@@cis,udel,edu>
+	# does the agent type support multihoming??
+	# @@@ do we need to worry about $useasim_ below?? (wasn't in 2.1b8)
+    	if {[lindex [split [$src info class] "/"] 1] == "SCTP"} {
+    		$self multihome-connect $src $dst
+    	}
+
+	$self simplex-connect $src $dst
+	$self simplex-connect $dst $src
+
+
+	# Debo
+
+	if {$useasim_ == 1} {
+		set sid [$src nodeid]
+		set sport [$src set agent_port_]
+		set did [$dst nodeid]
+		set dport [$dst set agent_port_]
+		
+		if {[lindex [split [$src info class] "/"] 1] == "TCP"} {
+			lappend conn_ $sid:$did:$sport:$dport
+			incr nconn_
+			# set $nconn_ [expr $nconn_ + 1]
+			# puts "Set a connection with id $nconn_ between $sid and $did"
+		}
+	}
+
+	return $src
+}
+
+# Armando L. Caro Jr. <acaro@@cis,udel,edu> 10/12/2001
+Simulator instproc multihome-connect {src dst} {
+	
+        set destNum 0
+	foreach binding [$src set multihome_bindings_] {
+		incr destNum
+  		set addr [lindex $binding 0]
+  		set port [lindex $binding 1]
+      		$dst add-multihome-destination $addr $port
+    	}
+	if {$destNum == 0} {
+	        # src isn't multihomed, so make sure we do an
+		# add-multihome-destination
+		$dst add-multihome-destination \
+				[$src set agent_addr_] [$src set agent_port_]
+	}
+	
+        set destNum 0
+	foreach binding [$dst set multihome_bindings_] {
+		incr destNum
+  		set addr [lindex $binding 0]
+  		set port [lindex $binding 1]
+      		$src add-multihome-destination $addr $port
+    	}
+	if {$destNum == 0} {
+	        # dst isn't multihomed, so make sure we do an
+		# add-multihome-destination
+		$src add-multihome-destination \
+				[$dst set agent_addr_] [$dst set agent_port_]
+	}
+}
+
+Simulator instproc simplex-connect { src dst } {
+	$src set dst_addr_ [$dst set agent_addr_] 
+	$src set dst_port_ [$dst set agent_port_]
+
+
+        # Polly Huang: to support abstract TCP simulations
+        if {[lindex [split [$src info class] "/"] 1] == "AbsTCP"} {
+	    $self at [$self now] "$self rtt $src $dst"
+	    $dst set class_ [$src set class_]
+        }
+
+	return $src
+}
+
+#
+# Here are a bunch of helper methods.
+#
+
+Simulator proc instance {} {
+	set ns [Simulator info instances]
+	if { $ns != "" } {
+		return $ns
+	}
+	foreach sim [Simulator info subclass] {
+		set ns [$sim info instances]
+		if { $ns != "" } {
+			return $ns
+		}
+	}
+	error "Cannot find instance of simulator"
+}
+
+Simulator instproc get-number-of-nodes {} {
+	return  [$self array size Node_]
+}
+
+Simulator instproc get-node-by-id id {
+	$self instvar Node_
+	return $Node_($id)
+}
+
+# Given an node's address, Return the node-id
+Simulator instproc get-node-id-by-addr address {
+	$self instvar Node_
+	set n [Node set nn_]
+	for {set q 0} {$q < $n} {incr q} {
+		set nq $Node_($q)
+		if {[string compare [$nq node-addr] $address] == 0} {
+			return $q
+		}
+	}
+	error "get-node-id-by-addr:Cannot find node with given address"
+}
+
+# Given an node's address, return the node 
+Simulator instproc get-node-by-addr address {
+	return [$self get-node-by-id [$self get-node-id-by-addr $address]]
+}
+
+Simulator instproc all-nodes-list {} {
+	$self instvar Node_
+	set nodes ""
+	foreach n [lsort -dictionary [array names Node_]] {
+		lappend nodes $Node_($n)
+	}
+	return $nodes
+}
+
+Simulator instproc link { n1 n2 } {
+        $self instvar Node_ link_
+        if { ![catch "$n1 info class Node"] } {
+		set n1 [$n1 id]
+	}
+        if { ![catch "$n2 info class Node"] } {
+		set n2 [$n2 id]
+	}
+	if [info exists link_($n1:$n2)] {
+		return $link_($n1:$n2)
+	}
+	return ""
+}
+
+# Creates connection. First creates a source agent of type s_type and binds
+# it to source.  Next creates a destination agent of type d_type and binds
+# it to dest.  Finally creates bindings for the source and destination agents,
+# connects them, and  returns the source agent.
+Simulator instproc create-connection {s_type source d_type dest pktClass} {
+	set s_agent [new Agent/$s_type]
+	set d_agent [new Agent/$d_type]
+	$s_agent set fid_ $pktClass
+	$d_agent set fid_ $pktClass
+	$self attach-agent $source $s_agent
+	$self attach-agent $dest $d_agent
+	$self connect $s_agent $d_agent
+	
+	return $s_agent
+}
+
+# Creates a highspeed connection. Similar to create-connection 
+# above except the sink agent requires additional work -- Sylvia
+Simulator instproc create-highspeed-connection {s_type source d_type dest pktClass} {
+        set s_agent [new Agent/$s_type]
+        set d_agent [new Agent/$d_type]
+        $d_agent resize_buffers
+        $s_agent set fid_ $pktClass
+        $d_agent set fid_ $pktClass
+        $self attach-agent $source $s_agent
+        $self attach-agent $dest $d_agent
+        $self connect $s_agent $d_agent
+
+        return $s_agent
+}
+
+# Creates connection. First creates a source agent of type s_type and binds
+# it to source.  Next creates a destination agent of type d_type and binds
+# it to dest.  Finally creates bindings for the source and destination agents,
+# connects them, and  returns a list of source agent and destination agent.
+Simulator instproc create-connection-list {s_type source d_type dest pktClass} {
+    set s_agent [new Agent/$s_type]
+    set d_agent [new Agent/$d_type]
+    $s_agent set fid_ $pktClass
+    $d_agent set fid_ $pktClass
+    $self attach-agent $source $s_agent
+    $self attach-agent $dest $d_agent
+    $self connect $s_agent $d_agent
+
+    return [list $s_agent $d_agent]
+}   
+
+# Creates connection. First creates a source agent of type s_type and binds
+# it to source.  Next creates a destination agent of type d_type and binds
+# it to dest.  Finally creates bindings for the source and destination agents,
+# connects them, and  returns the source agent. 
+# The destination agent is set to listen, for full-tcp.
+Simulator instproc create-connection-listen {s_type source d_type dest pktClass} {
+    set s_agent [new Agent/$s_type]
+    set d_agent [new Agent/$d_type]
+    $s_agent set fid_ $pktClass
+    $d_agent set fid_ $pktClass
+    $self attach-agent $source $s_agent
+    $self attach-agent $dest $d_agent
+    $self connect $s_agent $d_agent
+    $d_agent listen
+
+    return $s_agent 
+}   
+
+# This seems to be an obsolete procedure.
+Simulator instproc create-tcp-connection {s_type source d_type dest pktClass} {
+	set s_agent [new Agent/$s_type]
+	set d_agent [new Agent/$d_type]
+	$s_agent set fid_ $pktClass
+	$d_agent set fid_ $pktClass
+	$self attach-agent $source $s_agent
+	$self attach-agent $dest $d_agent
+	return "$s_agent $d_agent"
+}
+
+#
+# Other classifier methods overload the instproc-likes to track 
+# and return the installed objects.
+#
+Classifier instproc install {slot val} {
+	$self set slots_($slot) $val
+	$self cmd install $slot $val
+}
+
+Classifier instproc installNext val {
+	set slot [$self cmd installNext $val]
+	$self set slots_($slot) $val
+	set slot
+}
+
+Classifier instproc adjacents {} {
+	$self array get slots_
+}
+
+Classifier instproc in-slot? slot {
+	$self instvar slots_
+	set ret ""
+	if {[info exists slots_($slot)]} {
+	        set ret $slots_($slot)
+	}
+	set ret
+}
+
+# For debugging
+Classifier instproc dump {} {
+	$self instvar slots_ offset_ shift_ mask_
+	puts "classifier $self"
+	puts "\t$offset_ offset"
+	puts "\t$shift_ shift"
+	puts "\t$mask_ mask"
+	puts "\t[array size slots_] slots"
+	foreach i [lsort -integer [array names slots_]] {
+		set iv $slots_($i)
+		puts "\t\tslot $i: $iv ([$iv info class])"
+	}
+}
+
+Classifier instproc no-slot slot {
+        puts stderr "--- Classfier::no-slot{} default handler (tcl/lib/ns-lib.tcl) ---"
+        puts stderr "\t$self: no target for slot $slot"
+        puts stderr "\t$self type: [$self info class]"
+        puts stderr "content dump:"
+        $self dump
+        puts stderr "---------- Finished standard no-slot{} default handler ----------"
+        # Clear output before we bail out
+        [Simulator instance] flush-trace
+        exit 1
+}
+
+Classifier/Hash instproc dump args {
+	eval $self next $args
+	$self instvar default_
+	puts "\t$default_ default"
+}
+
+Classifier/Hash instproc init nbuck {
+	# We need to make sure that port shift/mask values are there
+	# so we set them after they get their default values
+	$self next $nbuck
+	$self instvar shift_ mask_
+	set shift_ [AddrParams NodeShift 1]
+	set mask_ [AddrParams NodeMask 1]
+}
+
+Classifier/Port/Reserve instproc init args {
+        eval $self next
+        $self reserve-port 2
+}
+
+Simulator instproc makeflowmon { cltype { clslots 29 } } {
+	set flowmon [new QueueMonitor/ED/Flowmon]
+	set cl [new Classifier/Hash/$cltype $clslots]
+	
+	$cl proc unknown-flow { src dst fid }  {
+		set fdesc [new QueueMonitor/ED/Flow]
+		set dsamp [new Samples]
+		$fdesc set-delay-samples $dsamp
+		set slot [$self installNext $fdesc] 
+		$self set-hash auto $src $dst $fid $slot
+	}
+	
+	$cl proc no-slot slotnum {
+		#
+		# note: we can wind up here when a packet passes
+		# through either an Out or a Drop Snoop Queue for
+		# a queue that the flow doesn't belong to anymore.
+		# Since there is no longer hash state in the
+		# hash classifier, we get a -1 return value for the
+		# hash classifier's classify() function, and there
+		# is no node at slot_[-1].  What to do about this?
+		# Well, we are talking about flows that have already
+		# been moved and so should rightly have their stats
+		# zero'd anyhow, so for now just ignore this case..
+		# puts "classifier $self, no-slot for slotnum $slotnum"
+	}
+	$flowmon classifier $cl
+	return $flowmon
+}
+
+# attach a flow monitor to a link
+# 3rd argument dictates whether early drop support is to be used
+
+Simulator instproc attach-fmon {lnk fm { edrop 0 } } {
+	set isnoop [new SnoopQueue/In]
+	set osnoop [new SnoopQueue/Out]
+	set dsnoop [new SnoopQueue/Drop]
+	$lnk attach-monitors $isnoop $osnoop $dsnoop $fm
+	if { $edrop != 0 } {
+	    set edsnoop [new SnoopQueue/EDrop]
+	    $edsnoop set-monitor $fm
+	    [$lnk queue] early-drop-target $edsnoop
+	    $edsnoop target [$self set nullAgent_]
+	}
+	[$lnk queue] drop-target $dsnoop
+}
+
+# Added by Yun Wang
+
+Simulator instproc maketbtagger { cltype { clslots 29 } } {
+
+        set tagger [new QueueMonitor/ED/Tagger]
+        set cl [new Classifier/Hash/$cltype $clslots]
+
+        $cl proc unknown-flow { src dst fid }  {
+                set fdesc [new QueueMonitor/ED/Flow/TB]
+                set dsamp [new Samples]
+                $fdesc set-delay-samples $dsamp
+                set slot [$self installNext $fdesc]
+                $self set-hash auto $src $dst $fid $slot
+        }
+
+        $cl proc set-rate { src dst fid hashbucket rate depth init} {
+                set fdesc [new QueueMonitor/ED/Flow/TB]
+                set dsamp [new Samples]
+                $fdesc set-delay-samples $dsamp
+                $fdesc set target_rate_ $rate
+                $fdesc set bucket_depth_ $depth
+                # Initialize the bucket as full
+                $fdesc set tbucket_ $init  
+                set slot [$self installNext $fdesc]
+                $self set-hash $hashbucket $src $dst $fid $slot
+        }
+
+        $cl proc no-slot slotnum {
+                #
+                # note: we can wind up here when a packet passes
+                # through either an Out or a Drop Snoop Queue for
+                # a queue that the flow doesn't belong to anymore.
+                # Since there is no longer hash state in the
+                # hash classifier, we get a -1 return value for the
+                # hash classifier's classify() function, and there
+                # is no node at slot_[-1].  What to do about this?
+                # Well, we are talking about flows that have already
+                # been moved and so should rightly have their stats
+                # zero'd anyhow, so for now just ignore this case..
+                # puts "classifier $self, no-slot for slotnum $slotnum"
+        }
+        $tagger classifier $cl
+        return $tagger
+}
+
+# Added by Yun Wang
+
+Simulator instproc maketswtagger { cltype { clslots 29 } } {
+
+        set tagger [new QueueMonitor/ED/Tagger]
+        set cl [new Classifier/Hash/$cltype $clslots]
+
+        $cl proc unknown-flow { src dst fid hashbucket }  {
+                set fdesc [new QueueMonitor/ED/Flow/TSW]
+                set dsamp [new Samples]
+                $fdesc set-delay-samples $dsamp
+                set slot [$self installNext $fdesc]
+                $self set-hash $hashbucket $src $dst $fid $slot
+        }
+
+        $cl proc no-slot slotnum {
+                #
+                # note: we can wind up here when a packet passes
+                # through either an Out or a Drop Snoop Queue for
+                # a queue that the flow doesn't belong to anymore.
+                # Since there is no longer hash state in the
+                # hash classifier, we get a -1 return value for the
+                # hash classifier's classify() function, and there
+                # is no node at slot_[-1].  What to do about this?
+                # Well, we are talking about flows that have already
+                # been moved and so should rightly have their stats
+                # zero'd anyhow, so for now just ignore this case..
+                # puts "classifier $self, no-slot for slotnum $slotnum"
+        }
+        $tagger classifier $cl
+        return $tagger
+}
+
+# attach a Tagger to a link
+# Added by Yun Wang
+
+Simulator instproc attach-tagger {lnk fm} {
+        set isnoop [new SnoopQueue/Tagger]
+        $lnk attach-taggers $isnoop $fm
+}
+
+# Imported from session.tcl. It is deleted there.
+### to insert loss module to regular links in detailed Simulator
+Simulator instproc lossmodel {lossobj from to} {
+	set link [$self link $from $to]
+	$link errormodule $lossobj
+}
+
+# This function generates losses that can be visualized by nam.
+Simulator instproc link-lossmodel {lossobj from to} {
+	set link [$self link $from $to]
+	$link insert-linkloss $lossobj
+}
+
+
+#### Polly Huang: Simulator class instproc to support abstract tcp simulations
+
+Simulator instproc rtt { src dst } {
+	$self instvar routingTable_ delay_
+	set srcid [[$src set node_] id]
+	set dstid [[$dst set node_] id]
+	set delay 0
+	set tmpid $srcid
+	while {$tmpid != $dstid} {
+		set nextid [$routingTable_ lookup $tmpid $dstid]
+		set tmpnode [$self get-node-by-id $tmpid]
+		set nextnode [$self get-node-by-id $nextid]
+		set tmplink [[$self link $tmpnode $nextnode] link]
+		set delay [expr $delay + [expr 2 * [$tmplink set delay_]]]
+		set delay [expr $delay + [expr 8320 / [$tmplink set bandwidth_]]]
+		set tmpid $nextid
+	}
+	$src rtt $delay
+	return $delay
+}
+
+Simulator instproc abstract-tcp {} {
+	$self instvar TahoeAckfsm_ RenoAckfsm_ TahoeDelAckfsm_ RenoDelAckfsm_ dropper_ 
+	$self set TahoeAckfsm_ [new FSM/TahoeAck]
+	$self set RenoAckfsm_ [new FSM/RenoAck]
+	$self set TahoeDelAckfsm_ [new FSM/TahoeDelAck]
+	$self set RenoDelAckfsm_ [new FSM/RenoDelAck]
+	$self set nullAgent_ [new DropTargetAgent]
+}
+
+# Chalermek: For Diffusion, Flooding, and Omnicient Multicast 
+
+Simulator instproc create-diffusion-rate-agent {node} {
+	global opt
+	set diff [new Agent/Diffusion/RateGradient]
+
+	$node set diffagent_ $diff
+	$node set ragent_ $diff
+
+	$diff on-node $node
+
+	if [info exist opt(enablePos)] {
+		if {$opt(enablePos) == "true"} {
+			$diff enable-pos
+		} else {
+			$diff disable-pos
+		}
+	} 
+
+	if [info exist opt(enableNeg)] {
+		if {$opt(enableNeg) == "true"} {
+			$diff enable-neg
+		} else {
+			$diff disable-neg
+		}
+	} 
+    
+	if [info exist opt(suppression)] {
+		if {$opt(suppression) == "true"} {
+			$diff enable-suppression
+		} else {
+			$diff disable-suppression
+		}
+	} 
+
+	if [info exist opt(subTxType)] {
+		$diff set-sub-tx-type $opt(subTxType)
+	} 
+
+	if [info exist opt(orgTxType)] {
+		$diff set-org-tx-type $opt(orgTxType)
+	} 
+
+	if [info exist opt(posType)] {
+		$diff set-pos-type $opt(posType)
+	} 
+
+	if [info exist opt(posNodeType)] {
+		$diff set-pos-node-type $opt(posNodeType)
+	} 
+
+	if [info exist opt(negWinType)] {
+		$diff set-neg-win-type $opt(negWinType)
+	} 
+
+	if [info exist opt(negThrType)] {
+		$diff set-neg-thr-type $opt(negThrType)
+	} 
+
+	if [info exist opt(negMaxType)] {
+		$diff set-neg-max-type $opt(negMaxType)
+	} 
+
+	$self put-in-list $diff
+	$self at 0.0 "$diff start"
+	
+	return $diff
+}
+
+Simulator instproc create-diffusion-probability-agent {node} {
+	global opt
+	set diff [new Agent/Diffusion/ProbGradient]
+
+	$node set diffagent_ $diff
+	$node set ragent_ $diff
+
+	$diff on-node $node
+
+	if [info exist opt(enablePos)] {
+		if {$opt(enablePos) == "true"} {
+			$diff enable-pos
+		} else {
+			$diff disable-pos
+		}
+	} 
+	if [info exist opt(enableNeg)] {
+		if {$opt(enableNeg) == "true"} {
+			$diff enable-neg
+		} else {
+			$diff disable-neg
+		}
+	} 
+	
+	$self put-in-list $diff
+	$self at 0.0 "$diff start"
+
+	return $diff
+}
+
+# Diffusioncore agent (in diffusion) maps to the wireless routing agent
+# in ns
+Simulator instproc create-core-diffusion-rtg-agent {node} {
+	$self instvar stopTime_ diffFilter_
+	Node instvar ragent_ dmux_
+	set ragent [new Agent/DiffusionRouting [$node id]]
+	$node set ragent_ $ragent
+	# at stop-time core-diffusion dumps stats data
+	# see diffusion.cc for details
+	if { [info exists stopTime_] } {
+		$ragent stop-time $stopTime_
+	}
+	if { ![info exists diffFilter_] } {
+		puts stderr "Error: No filter defined for diffusion!\n"
+		exit 1
+	}
+	$node create-diffusionApp-agent $diffFilter_
+	return $ragent
+}
+
+Simulator instproc create-flooding-agent {node} {
+	set flood [new Agent/Flooding]
+
+	$node set ragent_ $flood
+
+	$flood on-node $node
+
+	$self put-in-list $flood
+	$self at 0.0 "$flood start"
+
+	return $flood
+}
+
+Simulator instproc create-fsr-agent {node} {
+	set ragent [new Agent/FSR [$node node-addr]]
+	$self at 0.0 "$ragent start-fsr"
+	$node set ragent_ $ragent
+	return $ragent
+}
+
+Simulator instproc create-omnimcast-agent {node} {
+	set omni [new Agent/OmniMcast]
+
+	$node set ragent_ $omni
+
+	$omni on-node $node
+
+	$self put-in-list $omni
+	$self at 0.0 "$omni start"
+
+	return $omni
+}
+
+# XXX These are very simulation-specific methods, why should they belong here?
+Simulator instproc put-in-list {agent} {
+	$self instvar lagent
+	lappend lagent $agent
+}
+
+Simulator instproc terminate-all-agents {} {
+	$self instvar lagent
+	foreach i $lagent {
+		$i terminate
+	}
+}
+
+Simulator instproc prepare-to-stop {} {
+	$self instvar lagent
+	foreach i $lagent {
+		$i stop
+	}
+}
+    
diff -urN ns-2.34.original/tcl/lib/ns-mobilenode.tcl ns-2.34/tcl/lib/ns-mobilenode.tcl
--- ns-2.34.original/tcl/lib/ns-mobilenode.tcl	2009-06-15 01:35:42.000000000 +0800
+++ ns-2.34/tcl/lib/ns-mobilenode.tcl	2012-08-08 16:40:50.827625000 +0800
@@ -1,930 +1,936 @@
-# -*-	Mode:tcl; tcl-indent-level:8; tab-width:8; indent-tabs-mode:t -*-
-#
-# Copyright (c) 1998-2000 Regents of the University of California.
-# All rights reserved.
-# 
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions
-# are met:
-# 1. Redistributions of source code must retain the above copyright
-#    notice, this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright
-#    notice, this list of conditions and the following disclaimer in the
-#    documentation and/or other materials provided with the distribution.
-# 3. All advertising materials mentioning features or use of this software
-#    must display the following acknowledgement:
-# 	This product includes software developed by the MASH Research
-# 	Group at the University of California Berkeley.
-# 4. Neither the name of the University nor of the Research Group may be
-#    used to endorse or promote products derived from this software without
-#    specific prior written permission.
-# 
-# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
-# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
-# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-# SUCH DAMAGE.
-#
-# $Header: /cvsroot/nsnam/ns-2/tcl/lib/ns-mobilenode.tcl,v 1.60 2009/01/15 06:23:49 tom_henderson Exp $
-#
-# Ported from CMU-Monarch project's mobility extensions -Padma, 10/98.
-#
-
-# IT IS NOT ENCOURAGED TO SUBCLASSS MOBILENODE CLASS DEFINED IN THIS FILE
-
-#======================================================================
-# The ARPTable class
-#======================================================================
-ARPTable instproc init args {
-	eval $self next $args		;# parent class constructor
-}
-
-ARPTable set bandwidth_         0
-ARPTable set delay_             5us
-
-#======================================================================
-# The Node/MobileNodeNode class
-#======================================================================
-
-Node/MobileNode instproc init args {
-#  	# I don't care about address classifier; it's not my business
-#  	# All I do is to setup port classifier so we can do broadcast, 
-#  	# and to set up interface stuff.
-#  	$self attach-node $node
-#  	$node port-notify $self
-
-	eval $self next $args
-
-	$self instvar nifs_ arptable_ X_ Y_ Z_ nodetype_
-	set X_ 0.0
-	set Y_ 0.0
-	set Z_ 0.0
-        set arptable_ ""                ;# no ARP table yet
-	set nifs_	0		;# number of network interfaces
-	# Mobile IP node processing
-        $self makemip-New$nodetype_
-}
-
-#----------------------------------------------------------------------
-
-# XXX Following are the last remnant of nodetype_. Need to be completely 
-# removed, however, we need a better mechanism to distinguish vanilla 
-# mobile node from MIP base station, and MIP mobile host.
-
-Node/MobileNode instproc makemip-NewMobile {} {
-}
-
-Node/MobileNode instproc makemip-NewBase {} {
-}
-
-Node/MobileNode instproc makemip-New {} {
-}
-
-Node/MobileNode instproc makemip-NewMIPBS {} {
-	$self instvar regagent_ encap_ decap_ agents_ id_
-
-	set dmux [new Classifier/Port/Reserve]
-	$dmux set mask_ 0x7fffffff
-	$dmux set shift_ 0
-	$self install-demux $dmux
-   
-	set regagent_ [new Agent/MIPBS $self]
-	$self attach $regagent_ [Node/MobileNode set REGAGENT_PORT]
-	$self attach-encap 
-	$self attach-decap
-}
-
-Node/MobileNode instproc attach-encap {} {
-	$self instvar encap_ 
-	
-	set encap_ [new MIPEncapsulator]
-
-	$encap_ set mask_ [AddrParams NodeMask 1]
-	$encap_ set shift_ [AddrParams NodeShift 1]
-	#set mask 0x7fffffff
-	#set shift 0
-	set nodeaddr [AddrParams addr2id [$self node-addr]]
-	$encap_ set addr_ [expr ( ~([AddrParams NodeMask 1] << \
-			[AddrParams NodeShift 1]) & $nodeaddr )]
-	$encap_ set port_ 1
-	$encap_ target [$self entry]
-	$encap_ set node_ $self
-}
-
-Node/MobileNode instproc attach-decap {} {
-	$self instvar decap_ dmux_ agents_
-	set decap_ [new Classifier/Addr/MIPDecapsulator]
-	lappend agents_ $decap_
-	$decap_ set mask_ [AddrParams NodeMask 1]
-	$decap_ set shift_ [AddrParams NodeShift 1]
-	$dmux_ install [Node/MobileNode set DECAP_PORT] $decap_
-}
-
-Node/MobileNode instproc makemip-NewMIPMH {} {
-	$self instvar regagent_
- 
-	set dmux [new Classifier/Port/Reserve]
-	$dmux set mask_ 0x7fffffff
-	$dmux set shift_ 0
-	$self install-demux $dmux
-
-	set regagent_ [new Agent/MIPMH $self]
-	$self attach $regagent_ [Node/MobileNode set REGAGENT_PORT]
-	$regagent_ set mask_ [AddrParams NodeMask 1]
-	$regagent_ set shift_ [AddrParams NodeShift 1]
- 	$regagent_ set dst_addr_ [expr (~0) << [AddrParams NodeShift 1]]
-	$regagent_ set dst_port_ 0
-	$regagent_ node $self
-}
-
-#----------------------------------------------------------------------
-
-Node/MobileNode instproc reset {} {
-	$self instvar arptable_ nifs_ netif_ mac_ ifq_ ll_ imep_
-        for {set i 0} {$i < $nifs_} {incr i} {
-		$netif_($i) reset
-		$mac_($i) reset
-		$ll_($i) reset
-		$ifq_($i) reset
-		if { [info exists opt(imep)] && $opt(imep) == "ON" } { 
-			$imep_($i) reset 
-		}
-	}
-	if { $arptable_ != "" } {
-		$arptable_ reset 
-	}
-}
-
-#
-# Attach an agent to a node.  Pick a port and
-# bind the agent to the port number.
-# if portnumber is 255, default target is set to the routing agent
-#
-Node/MobileNode instproc add-target { agent port } {
-	$self instvar dmux_ imep_ toraDebug_ 
-
-	set ns [Simulator instance]
-	set newapi [$ns imep-support]
-
-	$agent set sport_ $port
-
-	# special processing for TORA/IMEP node
-	set toraonly [string first "TORA" [$agent info class]] 
-	if {$toraonly != -1 } {
-		$agent if-queue [$self set ifq_(0)]  ;# ifq between LL and MAC
-		#
-		# XXX: The routing protocol and the IMEP agents needs handles
-		# to each other.
-		#
-		$agent imep-agent [$self set imep_(0)]
-		[$self set imep_(0)] rtagent $agent
-	}
-	
-	# Special processing for AOMDV
-	set aomdvonly [string first "AOMDV" [$agent info class]] 
-	if {$aomdvonly != -1 } {
-		$agent if-queue [$self set ifq_(0)]   ;# ifq between LL and MAC
-	}
-	
-	# Special processing for AODV
-	set aodvonly [string first "AODV" [$agent info class]] 
-	if {$aodvonly != -1 } {
-		$agent if-queue [$self set ifq_(0)]   ;# ifq between LL and MAC
-	}
-	
-	#<zheng: add>
-	# Special processing for ZBR
-	#set zbronly [string first "ZBR" [$agent info class]] 
-	#if {$zbronly != -1 } {
-	#	$agent if-queue [$self set ifq_(0)]   ;# ifq between LL and MAC
-	#}
-	#</zheng: add>
-
-	if { $port == [Node set rtagent_port_] } {			
-		# Ad hoc routing agent setup needs special handling
-		$self add-target-rtagent $agent $port
-		return
-	}
-
-	# Attaching a normal agent
-	set namfp [$ns get-nam-traceall]
-	if { [Simulator set AgentTrace_] == "ON" } {
-		#
-		# Send Target
-		#
-		if {$newapi != ""} {
-			set sndT [$self mobility-trace Send "AGT"]
-		} else {
-			set sndT [cmu-trace Send AGT $self]
-		}
-		if { $namfp != "" } {
-			$sndT namattach $namfp
-		}
-		$sndT target [$self entry]
-		$agent target $sndT
-		#
-		# Recv Target
-		#
-		if {$newapi != ""} {
-			set rcvT [$self mobility-trace Recv "AGT"]
-		} else {
-			set rcvT [cmu-trace Recv AGT $self]
-		}
-		if { $namfp != "" } {
-			$rcvT namattach $namfp
-		}
-		$rcvT target $agent
-		$dmux_ install $port $rcvT
-	} else {
-		#
-		# Send Target
-		#
-		$agent target [$self entry]
-		#
-		# Recv Target
-		#
-		$dmux_ install $port $agent
-	}
-}
-
-Node/MobileNode instproc add-target-rtagent { agent port } {
-	$self instvar imep_ toraDebug_ 
-
-	set ns [Simulator instance]
-	set newapi [$ns imep-support]
-	set namfp [$ns get-nam-traceall]
-
-	set dmux_ [$self demux]
-	set classifier_ [$self entry]
-
-	# let the routing agent know about the port dmux
-	$agent port-dmux $dmux_
-
-	if { [Simulator set RouterTrace_] == "ON" } {
-		#
-		# Send Target
-		#
-		if {$newapi != ""} {
-			set sndT [$self mobility-trace Send "RTR"]
-		} else {
-			set sndT [cmu-trace Send "RTR" $self]
-		}
-		if { $namfp != "" } {
-			$sndT namattach $namfp
-		}
-		if { $newapi == "ON" } {
-			$agent target $imep_(0)
-			$imep_(0) sendtarget $sndT
-			# second tracer to see the actual
-			# types of tora packets before imep packs them
-			if { [info exists toraDebug_] && $toraDebug_ == "ON"} {
-				set sndT2 [$self mobility-trace Send "TRP"]
-				$sndT2 target $imep_(0)
-				$agent target $sndT2
-			}
-		} else {  ;#  no IMEP
-			$agent target $sndT
-		}
-		$sndT target [$self set ll_(0)]
-		#
-		# Recv Target
-		#
-		if {$newapi != ""} {
-			set rcvT [$self mobility-trace Recv "RTR"]
-		} else {
-			set rcvT [cmu-trace Recv "RTR" $self]
-		}
-		if { $namfp != "" } {
-			$rcvT namattach $namfp
-		}
-		if {$newapi == "ON" } {
-			[$self set ll_(0)] up-target $imep_(0)
-			$classifier_ defaulttarget $agent
-			# need a second tracer to see the actual
-			# types of tora packets after imep unpacks them
-			# no need to support any hier node
-			if {[info exists toraDebug_] && $toraDebug_ == "ON" } {
-				set rcvT2 [$self mobility-trace Recv "TRP"]
-				$rcvT2 target $agent
-				$classifier_ defaulttarget $rcvT2
-			}
-		} else {
-			$rcvT target $agent
-			$classifier_ defaulttarget $rcvT
-			$dmux_ install $port $rcvT
-		}
-	} else {
-		#
-		# Send Target
-		#
-		# if tora is used
-		if { $newapi == "ON" } {
-			$agent target $imep_(0)
-			# second tracer to see the actual
-			# types of tora packets before imep packs them
-			if { [info exists toraDebug_] && $toraDebug_ == "ON"} {
-				set sndT2 [$self mobility-trace Send "TRP"]
-				$sndT2 target $imep_(0)
-				$agent target $sndT2
-			}
-			$imep_(0) sendtarget [$self set ll_(0)]
-			
-		} else {  ;#  no IMEP
-			$agent target [$self set ll_(0)]
-		}    
-		#
-		# Recv Target
-		#
-		if {$newapi == "ON" } {
-			[$self set ll_(0)] up-target $imep_(0)
-			$classifier_ defaulttarget $agent
-			# need a second tracer to see the actual
-			# types of tora packets after imep unpacks them
-			# no need to support any hier node
-			if {[info exists toraDebug_] && $toraDebug_ == "ON" } {
-				set rcvT2 [$self mobility-trace Recv "TRP"]
-				$rcvT2 target $agent
-				[$self set classifier_] defaulttarget $rcvT2
-			}
-		} else {
-			$classifier_ defaulttarget $agent
-			$dmux_ install $port $agent
-		}
-	}
-}
-
-#
-# The following setups up link layer, mac layer, network interface
-# and physical layer structures for the mobile node.
-#
-Node/MobileNode instproc add-interface { channel pmodel lltype mactype qtype qlen iftype anttype topo inerrproc outerrproc fecproc } {
-	$self instvar arptable_ nifs_ netif_ mac_ ifq_ ll_ imep_ inerr_ outerr_ fec_
-	
-	set ns [Simulator instance]
-	set imepflag [$ns imep-support]
-	set t $nifs_
-	incr nifs_
-
-	set netif_($t)	[new $iftype]		;# interface
-	set mac_($t)	[new $mactype]		;# mac layer
-	set ifq_($t)	[new $qtype]		;# interface queue
-	set ll_($t)	[new $lltype]		;# link layer
-        set ant_($t)    [new $anttype]
-
-	$ns mac-type $mactype
-	set inerr_($t) ""
-	if {$inerrproc != ""} {
-		set inerr_($t) [$inerrproc]
-	}
-	set outerr_($t) ""
-	if {$outerrproc != ""} {
-		set outerr_($t) [$outerrproc]
-	}
-	set fec_($t) ""
-	if {$fecproc != ""} {
-		set fec_($t) [$fecproc]
-	}
-
-	set namfp [$ns get-nam-traceall]
-        if {$imepflag == "ON" } {              
-		# IMEP layer
-		set imep_($t) [new Agent/IMEP [$self id]]
-		set imep $imep_($t)
-		set drpT [$self mobility-trace Drop "RTR"]
-		if { $namfp != "" } {
-			$drpT namattach $namfp
-		}
-		$imep drop-target $drpT
-		$ns at 0.[$self id] "$imep_($t) start"   ;# start beacon timer
-        }
-	#
-	# Local Variables
-	#
-	set nullAgent_ [$ns set nullAgent_]
-	set netif $netif_($t)
-	set mac $mac_($t)
-	set ifq $ifq_($t)
-	set ll $ll_($t)
-
-	set inerr $inerr_($t)
-	set outerr $outerr_($t)
-	set fec $fec_($t)
-
-	#
-	# Initialize ARP table only once.
-	#
-	if { $arptable_ == "" } {
-		set arptable_ [new ARPTable $self $mac]
-		# FOR backward compatibility sake, hack only
-		if {$imepflag != ""} {
-			set drpT [$self mobility-trace Drop "IFQ"]
-		} else {
-			set drpT [cmu-trace Drop "IFQ" $self]
-		}
-		$arptable_ drop-target $drpT
-		if { $namfp != "" } {
-			$drpT namattach $namfp
-		}
-        }
-	#
-	# Link Layer
-	#
-	$ll arptable $arptable_
-	$ll mac $mac
-	$ll down-target $ifq
-
-	if {$imepflag == "ON" } {
-		$imep recvtarget [$self entry]
-		$imep sendtarget $ll
-		$ll up-target $imep
-        } else {
-		$ll up-target [$self entry]
-	}
-
-	#
-	# Interface Queue
-	#
-	$ifq target $mac
-	$ifq set limit_ $qlen
-	if {$imepflag != ""} {
-		set drpT [$self mobility-trace Drop "IFQ"]
-	} else {
-		set drpT [cmu-trace Drop "IFQ" $self]
-        }
-	$ifq drop-target $drpT
-	if { $namfp != "" } {
-		$drpT namattach $namfp
-	}
-	if {[$ifq info class] == "Queue/XCP"} {		
-		$mac set bandwidth_ [$ll set bandwidth_]
-		$mac set delay_ [$ll set delay_]
-		$ifq set-link-capacity [$mac set bandwidth_]
-		$ifq queue-limit $qlen
-		$ifq link $ll
-		$ifq reset
-		
-	}
-
-	#
-	# Mac Layer
-	#
-	
-	$mac netif $netif
-	$mac up-target $ll
-
-	if {$outerr == "" && $fec == ""} {
-		$mac down-target $netif
-	} elseif {$outerr != "" && $fec == ""} {
-		$mac down-target $outerr
-		$outerr target $netif
-	} elseif {$outerr == "" && $fec != ""} {
-		$mac down-target $fec
-		$fec down-target $netif
-	} else {
-		$mac down-target $fec
-		$fec down-target $outerr
-		$err target $netif
-	}
-
-	set god_ [God instance]
-    if {$mactype == "Mac/802_11Ext"} {
-		$mac nodes [$god_ num_nodes]
-	}
-    if {$mactype == "Mac/802_11"} {
-		$mac nodes [$god_ num_nodes]
-	}
-	#
-	# Network Interface
-	#
-	#if {$fec == ""} {
-        #		$netif up-target $mac
-	#} else {
-        #		$netif up-target $fec
-	#	$fec up-target $mac
-	#}
-
-	$netif channel $channel
-	if {$inerr == "" && $fec == ""} {
-		$netif up-target $mac
-	} elseif {$inerr != "" && $fec == ""} {
-		$netif up-target $inerr
-		$inerr target $mac
-	} elseif {$err == "" && $fec != ""} {
-		$netif up-target $fec
-		$fec up-target $mac
-	} else {
-		$netif up-target $inerr
-		$inerr target $fec
-		$fec up-target $mac
-	}
-
-	$netif propagation $pmodel	;# Propagation Model
-	$netif node $self		;# Bind node <---> interface
-	$netif antenna $ant_($t)
-	#
-	# Physical Channel
-	#
-	$channel addif $netif
-	
-        # List-based improvement
-	# For nodes talking to multiple channels this should
-	# be called multiple times for each channel
-	$channel add-node $self		
-
-	# let topo keep handle of channel
-	$topo channel $channel
-	# ============================================================
-
-	if { [Simulator set PhyTrace_] == "ON" } {
-		#
-		# Trace Dropped Packets
-		#
-		if {$imepflag != ""} {
-			set drpPhyT [$self mobility-trace Drop "PHY"]
-		} else {
-			set drpPhyT [cmu-trace Drop "PHY" $self]
-		}
-		$netif drop-target $drpPhyT
-		if { $namfp != "" } {
-			$drpPhyT namattach $namfp
-		}
-
-		#
-		# Trace Sent Packets
-		#
-        if {$imepflag != ""} {
-            set sndPhyT [$self mobility-trace Send "PHY"]
-        } else {
-            set sndPhyT [cmu-trace Send "PHY" $self]
-        }
-        $sndPhyT target $channel
-        $netif down-target $sndPhyT
-        if { $namfp != "" } {
-            $sndPhyT namattach $namfp
-        }
-        
-	} else {
-		$netif drop-target [$ns set nullAgent_]
-	}
-
-	if { [Simulator set MacTrace_] == "ON" } {
-		#
-		# Trace RTS/CTS/ACK Packets
-		#
-		if {$imepflag != ""} {
-			set rcvT [$self mobility-trace Recv "MAC"]
-		} else {
-			set rcvT [cmu-trace Recv "MAC" $self]
-		}
-		$mac log-target $rcvT
-		if { $namfp != "" } {
-			$rcvT namattach $namfp
-		}
-		#
-		# Trace Sent Packets
-		#
-		if {$imepflag != ""} {
-			set sndT [$self mobility-trace Send "MAC"]
-		} else {
-			set sndT [cmu-trace Send "MAC" $self]
-		}
-		$sndT target [$mac down-target]
-		$mac down-target $sndT
-		if { $namfp != "" } {
-			$sndT namattach $namfp
-		}
-		#
-		# Trace Received Packets
-		#
-		if {$imepflag != ""} {
-			set rcvT [$self mobility-trace Recv "MAC"]
-		} else {
-			set rcvT [cmu-trace Recv "MAC" $self]
-		}
-		$rcvT target [$mac up-target]
-		$mac up-target $rcvT
-		if { $namfp != "" } {
-			$rcvT namattach $namfp
-		}
-		#
-		# Trace Dropped Packets
-		#
-		if {$imepflag != ""} {
-			set drpT [$self mobility-trace Drop "MAC"]
-		} else {
-			set drpT [cmu-trace Drop "MAC" $self]
-		}
-		$mac drop-target $drpT
-		if { $namfp != "" } {
-			$drpT namattach $namfp
-		}
-	} else {
-		$mac log-target [$ns set nullAgent_]
-		$mac drop-target [$ns set nullAgent_]
-	}
-
-# change wrt Mike's code
-       if { [Simulator set EotTrace_] == "ON" } {
-               #
-               # Also trace end of transmission time for packets
-               #
-
-               if {$imepflag != ""} {
-                       set eotT [$self mobility-trace EOT "MAC"]
-               } else {
-                       set eoT [cmu-trace EOT "MAC" $self]
-               }
-               $mac eot-target $eotT
-       }
-
-
-
-	# ============================================================
-
-	$self addif $netif
-}
-
-# set transmission power
-Node/MobileNode instproc setPt { val } {
-	$self instvar netif_
-	$netif_(0) setTxPower $val
-}
-
-# set receiving power
-Node/MobileNode instproc setPr { val } {
-	$self instvar netif_
-	$netif_(0) setRxPower $val
-}
-
-# set idle power -- Chalermek
-Node/MobileNode instproc setPidle { val } {
-	$self instvar netif_
-	$netif_(0) setIdlePower $val
-}
-#
-Node/MobileNode instproc setPsleep { val } {
-	$self instvar netif_
-	$netif_(0) setSleepPower $val
-}
-#
-Node/MobileNode instproc setTSleep { val } {
-	$self instvar netif_
-	$netif_(0) setSleepTime $val
-}
-#
-Node/MobileNode instproc setPtransition { val } {
-	$self instvar netif_
-	$netif_(0) setTransitionPower $val
-}
-
-Node/MobileNode instproc setTtransition { val } {
-	$self instvar netif_
-	$netif_(0) setTransitionTime $val
-}
-#
-# change wrt Mike's code
- Node/MobileNode instproc getMac {param0} {
-       $self instvar mac_
-       return $mac_($param0)
- }
-
- Node/MobileNode instproc CFP { beacon_period cfp_duration } {
-       if {$mactype == "Mac/802_11"} {
-               $self instvar mac_
-               set ns_ [Simulator instance]
-               set beacon_period [$ns_ delay_parse $beacon_period]
-               set cfp_duration [$ns_ delay_parse $cfp_duration]
-               $mac_(0) cfp $beacon_period $cfp_duration
-       }
- }
-
-
-
-Node/MobileNode instproc mobility-trace { ttype atype } {
-	set ns [Simulator instance]
-        set tracefd [$ns get-ns-traceall]
-        if { $tracefd == "" } {
-	        puts "Warning: You have not defined you tracefile yet!"
-	        puts "Please use trace-all command to define it."
-		return ""
-	}
-	set T [new CMUTrace/$ttype $atype]
-	$T newtrace [Simulator set WirelessNewTrace_]
-	$T tagged [Simulator set TaggedTrace_]
-	$T target [$ns nullagent]
-	$T attach $tracefd
-        $T set src_ [$self id]
-        $T node $self
-	return $T
-}
-
-Node/MobileNode instproc nodetrace { tracefd } {
-	#
-	# This Trace Target is used to log changes in direction
-	# and velocity for the mobile node.
-	#
-	set T [new Trace/Generic]
-	$T target [[Simulator instance] set nullAgent_]
-	$T attach $tracefd
-	$T set src_ [$self id]
-	$self log-target $T    
-}
-
-Node/MobileNode instproc agenttrace {tracefd} {
-	set ns [Simulator instance]
-	set ragent [$self set ragent_]
-	#
-	# Drop Target (always on regardless of other tracing)
-	#
-	set drpT [$self mobility-trace Drop "RTR"]
-	set namfp [$ns get-nam-traceall]
-	if { $namfp != ""} {
-		$drpT namattach $namfp
-	}
-	$ragent drop-target $drpT
-	#
-	# Log Target
-	#
-	set T [new Trace/Generic]
-	$T target [$ns set nullAgent_]
-	$T attach $tracefd
-	$T set src_ [$self id]
-	$ragent tracetarget $T
-	#
-	# XXX: let the IMEP agent use the same log target.
-	#
-	set imepflag [$ns imep-support]
-	if {$imepflag == "ON"} {
-		[$self set imep_(0)] log-target $T
-	}
-}
-
-Node/MobileNode instproc mip-call {ragent} {
-	$self instvar regagent_
-	if [info exists regagent_] {
-		$regagent_ ragent $ragent
-	}
-}
-
-Node/MobileNode instproc attach-gafpartner {} {
-
-        $self instvar gafpartner_ address_ ll_ 
-
-        set gafpartner_ [new GAFPartner]
-
-	$gafpartner_ set mask_ [AddrParams NodeMask 1]
-	$gafpartner_ set shift_ [AddrParams NodeShift 1]
-	set nodeaddr [AddrParams addr2id [$self node-addr]]
-	
-	#$gafpartner_ set addr_ [expr ( ~([AddrParams NodeMask 1] << \
-	#		[AddrParams NodeShift 1]) & $nodeaddr )]
-
-	
-	$gafpartner_ set addr_ $nodeaddr
-	$gafpartner_ set port_ 254
-
-	#puts [$gafpartner_ set addr_]
-
-        $gafpartner_ target [$self entry]
-	$ll_(0) up-target $gafpartner_
-}
-
-Node/MobileNode instproc unset-gafpartner {} {
-	$self instvar gafpartner_
-	
-	$gafpartner_ set-gafagent 0
-
-}
-
-# <zheng: add>
-Node/MobileNode instproc sscs args {
-	$self instvar mac_
-	eval $mac_(0) sscs $args
-}
-
-Node/MobileNode instproc NodeClr {arg1} {
-	$self instvar mac_
-	$mac_(0) NodeClr $arg1
-}
-
-Node/MobileNode instproc NodeLabel args {
-	$self instvar mac_
-	eval $mac_(0) NodeLabel $args
-}
-
-Node/MobileNode instproc node-down {} {
-	$self instvar mac_
-	$mac_(0) node-down
-}
-
-Node/MobileNode instproc node-up {} {
-	$self instvar mac_
-	$mac_(0) node-up
-}
-
-Node/MobileNode instproc RNType args {
-	$self instvar ragent_
-	eval $ragent_ RNType $args
-}
-# </zheng: add>
-
-Class SRNodeNew -superclass Node/MobileNode
-
-SRNodeNew instproc init args {
-	$self instvar dsr_agent_ dmux_ entry_point_ address_
-
-        set ns [Simulator instance]
-
-	eval $self next $args	;# parent class constructor
-
-	if {$dmux_ == "" } {
-		# Use the default mash and shift
-		set dmux_ [new Classifier/Port]
-	}
-	set dsr_agent_ [new Agent/DSRAgent]
-
-	# setup address (supports hier-address) for dsragent
-	$dsr_agent_ addr $address_
-	$dsr_agent_ node $self
-	if [Simulator set mobile_ip_] {
-		$dsr_agent_ port-dmux [$self set dmux_]
-	}
-	# set up IP address
-	$self addr $address_
-	
-	if { [Simulator set RouterTrace_] == "ON" } {
-		# Recv Target
-		set rcvT [$self mobility-trace Recv "RTR"]
-		set namfp [$ns get-nam-traceall]
-		if {  $namfp != "" } {
-			$rcvT namattach $namfp
-		}
-		$rcvT target $dsr_agent_
-		set entry_point_ $rcvT	
-	} else {
-		# Recv Target
-		set entry_point_ $dsr_agent_
-	}
-
-	$self set ragent_ $dsr_agent_
-	$dsr_agent_ target $dmux_
-
-	# packets to the DSR port should be dropped, since we've
-	# already handled them in the DSRAgent at the entry.
-	set nullAgent_ [$ns set nullAgent_]
-	$dmux_ install [Node set rtagent_port_] $nullAgent_
-
-	# SRNodes don't use the IP addr classifier.  The DSRAgent should
-	# be the entry point
-	$self instvar classifier_
-	set classifier_ "srnode made illegal use of classifier_"
-
-	return $self
-}
-
-SRNodeNew instproc start-dsr {} {
-	$self instvar dsr_agent_
-	$dsr_agent_ startdsr
-}
-
-SRNodeNew instproc entry {} {
-        $self instvar entry_point_
-        return $entry_point_
-}
-
-SRNodeNew instproc add-interface args {
-	eval $self next $args
-
-	$self instvar dsr_agent_ ll_ mac_ ifq_
-
-	set ns [Simulator instance]
-	$dsr_agent_ mac-addr [$mac_(0) id]
-
-	if { [Simulator set RouterTrace_] == "ON" } {
-		# Send Target
-		set sndT [$self mobility-trace Send "RTR"]
-		set namfp [$ns get-nam-traceall]
-		if {$namfp != "" } {
-			$sndT namattach $namfp
-		}
-		$sndT target $ll_(0)
-		$dsr_agent_ add-ll $sndT $ifq_(0)
-	} else {
-		# Send Target
-		$dsr_agent_ add-ll $ll_(0) $ifq_(0)
-	}
-	# setup promiscuous tap into mac layer
-	$dsr_agent_ install-tap $mac_(0)
-}
-
-SRNodeNew instproc reset args {
-	$self instvar dsr_agent_
-	eval $self next $args
-	$dsr_agent_ reset
-}
+# -*-	Mode:tcl; tcl-indent-level:8; tab-width:8; indent-tabs-mode:t -*-
+#
+# Copyright (c) 1998-2000 Regents of the University of California.
+# All rights reserved.
+# 
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+# 3. All advertising materials mentioning features or use of this software
+#    must display the following acknowledgement:
+# 	This product includes software developed by the MASH Research
+# 	Group at the University of California Berkeley.
+# 4. Neither the name of the University nor of the Research Group may be
+#    used to endorse or promote products derived from this software without
+#    specific prior written permission.
+# 
+# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+# $Header: /cvsroot/nsnam/ns-2/tcl/lib/ns-mobilenode.tcl,v 1.60 2009/01/15 06:23:49 tom_henderson Exp $
+#
+# Ported from CMU-Monarch project's mobility extensions -Padma, 10/98.
+#
+
+# IT IS NOT ENCOURAGED TO SUBCLASSS MOBILENODE CLASS DEFINED IN THIS FILE
+
+#======================================================================
+# The ARPTable class
+#======================================================================
+ARPTable instproc init args {
+	eval $self next $args		;# parent class constructor
+}
+
+ARPTable set bandwidth_         0
+ARPTable set delay_             5us
+
+#======================================================================
+# The Node/MobileNodeNode class
+#======================================================================
+
+Node/MobileNode instproc init args {
+#  	# I don't care about address classifier; it's not my business
+#  	# All I do is to setup port classifier so we can do broadcast, 
+#  	# and to set up interface stuff.
+#  	$self attach-node $node
+#  	$node port-notify $self
+
+	eval $self next $args
+
+	$self instvar nifs_ arptable_ X_ Y_ Z_ nodetype_
+	set X_ 0.0
+	set Y_ 0.0
+	set Z_ 0.0
+        set arptable_ ""                ;# no ARP table yet
+	set nifs_	0		;# number of network interfaces
+	# Mobile IP node processing
+        $self makemip-New$nodetype_
+}
+
+#----------------------------------------------------------------------
+
+# XXX Following are the last remnant of nodetype_. Need to be completely 
+# removed, however, we need a better mechanism to distinguish vanilla 
+# mobile node from MIP base station, and MIP mobile host.
+
+Node/MobileNode instproc makemip-NewMobile {} {
+}
+
+Node/MobileNode instproc makemip-NewBase {} {
+}
+
+Node/MobileNode instproc makemip-New {} {
+}
+
+Node/MobileNode instproc makemip-NewMIPBS {} {
+	$self instvar regagent_ encap_ decap_ agents_ id_
+
+	set dmux [new Classifier/Port/Reserve]
+	$dmux set mask_ 0x7fffffff
+	$dmux set shift_ 0
+	$self install-demux $dmux
+   
+	set regagent_ [new Agent/MIPBS $self]
+	$self attach $regagent_ [Node/MobileNode set REGAGENT_PORT]
+	$self attach-encap 
+	$self attach-decap
+}
+
+Node/MobileNode instproc attach-encap {} {
+	$self instvar encap_ 
+	
+	set encap_ [new MIPEncapsulator]
+
+	$encap_ set mask_ [AddrParams NodeMask 1]
+	$encap_ set shift_ [AddrParams NodeShift 1]
+	#set mask 0x7fffffff
+	#set shift 0
+	set nodeaddr [AddrParams addr2id [$self node-addr]]
+	$encap_ set addr_ [expr ( ~([AddrParams NodeMask 1] << \
+			[AddrParams NodeShift 1]) & $nodeaddr )]
+	$encap_ set port_ 1
+	$encap_ target [$self entry]
+	$encap_ set node_ $self
+}
+
+Node/MobileNode instproc attach-decap {} {
+	$self instvar decap_ dmux_ agents_
+	set decap_ [new Classifier/Addr/MIPDecapsulator]
+	lappend agents_ $decap_
+	$decap_ set mask_ [AddrParams NodeMask 1]
+	$decap_ set shift_ [AddrParams NodeShift 1]
+	$dmux_ install [Node/MobileNode set DECAP_PORT] $decap_
+}
+
+Node/MobileNode instproc makemip-NewMIPMH {} {
+	$self instvar regagent_
+ 
+	set dmux [new Classifier/Port/Reserve]
+	$dmux set mask_ 0x7fffffff
+	$dmux set shift_ 0
+	$self install-demux $dmux
+
+	set regagent_ [new Agent/MIPMH $self]
+	$self attach $regagent_ [Node/MobileNode set REGAGENT_PORT]
+	$regagent_ set mask_ [AddrParams NodeMask 1]
+	$regagent_ set shift_ [AddrParams NodeShift 1]
+ 	$regagent_ set dst_addr_ [expr (~0) << [AddrParams NodeShift 1]]
+	$regagent_ set dst_port_ 0
+	$regagent_ node $self
+}
+
+#----------------------------------------------------------------------
+
+Node/MobileNode instproc reset {} {
+	$self instvar arptable_ nifs_ netif_ mac_ ifq_ ll_ imep_
+        for {set i 0} {$i < $nifs_} {incr i} {
+		$netif_($i) reset
+		$mac_($i) reset
+		$ll_($i) reset
+		$ifq_($i) reset
+		if { [info exists opt(imep)] && $opt(imep) == "ON" } { 
+			$imep_($i) reset 
+		}
+	}
+	if { $arptable_ != "" } {
+		$arptable_ reset 
+	}
+}
+
+#
+# Attach an agent to a node.  Pick a port and
+# bind the agent to the port number.
+# if portnumber is 255, default target is set to the routing agent
+#
+Node/MobileNode instproc add-target { agent port } {
+	$self instvar dmux_ imep_ toraDebug_ 
+
+	set ns [Simulator instance]
+	set newapi [$ns imep-support]
+
+	$agent set sport_ $port
+
+	# special processing for TORA/IMEP node
+	set toraonly [string first "TORA" [$agent info class]] 
+	if {$toraonly != -1 } {
+		$agent if-queue [$self set ifq_(0)]  ;# ifq between LL and MAC
+		#
+		# XXX: The routing protocol and the IMEP agents needs handles
+		# to each other.
+		#
+		$agent imep-agent [$self set imep_(0)]
+		[$self set imep_(0)] rtagent $agent
+	}
+	
+	# Special processing for AOMDV
+	set aomdvonly [string first "AOMDV" [$agent info class]] 
+	if {$aomdvonly != -1 } {
+		$agent if-queue [$self set ifq_(0)]   ;# ifq between LL and MAC
+	}
+	
+	# Special processing for AODV
+	set aodvonly [string first "AODV" [$agent info class]] 
+	if {$aodvonly != -1 } {
+		$agent if-queue [$self set ifq_(0)]   ;# ifq between LL and MAC
+	}
+
+	# Special processing for FSR
+	set aodvonly [string first "FSR" [$agent info class]] 
+	if {$aodvonly != -1 } {
+		$agent if-queue [$self set ifq_(0)]   ;# ifq between LL and MAC
+	}
+	
+	#<zheng: add>
+	# Special processing for ZBR
+	#set zbronly [string first "ZBR" [$agent info class]] 
+	#if {$zbronly != -1 } {
+	#	$agent if-queue [$self set ifq_(0)]   ;# ifq between LL and MAC
+	#}
+	#</zheng: add>
+
+	if { $port == [Node set rtagent_port_] } {			
+		# Ad hoc routing agent setup needs special handling
+		$self add-target-rtagent $agent $port
+		return
+	}
+
+	# Attaching a normal agent
+	set namfp [$ns get-nam-traceall]
+	if { [Simulator set AgentTrace_] == "ON" } {
+		#
+		# Send Target
+		#
+		if {$newapi != ""} {
+			set sndT [$self mobility-trace Send "AGT"]
+		} else {
+			set sndT [cmu-trace Send AGT $self]
+		}
+		if { $namfp != "" } {
+			$sndT namattach $namfp
+		}
+		$sndT target [$self entry]
+		$agent target $sndT
+		#
+		# Recv Target
+		#
+		if {$newapi != ""} {
+			set rcvT [$self mobility-trace Recv "AGT"]
+		} else {
+			set rcvT [cmu-trace Recv AGT $self]
+		}
+		if { $namfp != "" } {
+			$rcvT namattach $namfp
+		}
+		$rcvT target $agent
+		$dmux_ install $port $rcvT
+	} else {
+		#
+		# Send Target
+		#
+		$agent target [$self entry]
+		#
+		# Recv Target
+		#
+		$dmux_ install $port $agent
+	}
+}
+
+Node/MobileNode instproc add-target-rtagent { agent port } {
+	$self instvar imep_ toraDebug_ 
+
+	set ns [Simulator instance]
+	set newapi [$ns imep-support]
+	set namfp [$ns get-nam-traceall]
+
+	set dmux_ [$self demux]
+	set classifier_ [$self entry]
+
+	# let the routing agent know about the port dmux
+	$agent port-dmux $dmux_
+
+	if { [Simulator set RouterTrace_] == "ON" } {
+		#
+		# Send Target
+		#
+		if {$newapi != ""} {
+			set sndT [$self mobility-trace Send "RTR"]
+		} else {
+			set sndT [cmu-trace Send "RTR" $self]
+		}
+		if { $namfp != "" } {
+			$sndT namattach $namfp
+		}
+		if { $newapi == "ON" } {
+			$agent target $imep_(0)
+			$imep_(0) sendtarget $sndT
+			# second tracer to see the actual
+			# types of tora packets before imep packs them
+			if { [info exists toraDebug_] && $toraDebug_ == "ON"} {
+				set sndT2 [$self mobility-trace Send "TRP"]
+				$sndT2 target $imep_(0)
+				$agent target $sndT2
+			}
+		} else {  ;#  no IMEP
+			$agent target $sndT
+		}
+		$sndT target [$self set ll_(0)]
+		#
+		# Recv Target
+		#
+		if {$newapi != ""} {
+			set rcvT [$self mobility-trace Recv "RTR"]
+		} else {
+			set rcvT [cmu-trace Recv "RTR" $self]
+		}
+		if { $namfp != "" } {
+			$rcvT namattach $namfp
+		}
+		if {$newapi == "ON" } {
+			[$self set ll_(0)] up-target $imep_(0)
+			$classifier_ defaulttarget $agent
+			# need a second tracer to see the actual
+			# types of tora packets after imep unpacks them
+			# no need to support any hier node
+			if {[info exists toraDebug_] && $toraDebug_ == "ON" } {
+				set rcvT2 [$self mobility-trace Recv "TRP"]
+				$rcvT2 target $agent
+				$classifier_ defaulttarget $rcvT2
+			}
+		} else {
+			$rcvT target $agent
+			$classifier_ defaulttarget $rcvT
+			$dmux_ install $port $rcvT
+		}
+	} else {
+		#
+		# Send Target
+		#
+		# if tora is used
+		if { $newapi == "ON" } {
+			$agent target $imep_(0)
+			# second tracer to see the actual
+			# types of tora packets before imep packs them
+			if { [info exists toraDebug_] && $toraDebug_ == "ON"} {
+				set sndT2 [$self mobility-trace Send "TRP"]
+				$sndT2 target $imep_(0)
+				$agent target $sndT2
+			}
+			$imep_(0) sendtarget [$self set ll_(0)]
+			
+		} else {  ;#  no IMEP
+			$agent target [$self set ll_(0)]
+		}    
+		#
+		# Recv Target
+		#
+		if {$newapi == "ON" } {
+			[$self set ll_(0)] up-target $imep_(0)
+			$classifier_ defaulttarget $agent
+			# need a second tracer to see the actual
+			# types of tora packets after imep unpacks them
+			# no need to support any hier node
+			if {[info exists toraDebug_] && $toraDebug_ == "ON" } {
+				set rcvT2 [$self mobility-trace Recv "TRP"]
+				$rcvT2 target $agent
+				[$self set classifier_] defaulttarget $rcvT2
+			}
+		} else {
+			$classifier_ defaulttarget $agent
+			$dmux_ install $port $agent
+		}
+	}
+}
+
+#
+# The following setups up link layer, mac layer, network interface
+# and physical layer structures for the mobile node.
+#
+Node/MobileNode instproc add-interface { channel pmodel lltype mactype qtype qlen iftype anttype topo inerrproc outerrproc fecproc } {
+	$self instvar arptable_ nifs_ netif_ mac_ ifq_ ll_ imep_ inerr_ outerr_ fec_
+	
+	set ns [Simulator instance]
+	set imepflag [$ns imep-support]
+	set t $nifs_
+	incr nifs_
+
+	set netif_($t)	[new $iftype]		;# interface
+	set mac_($t)	[new $mactype]		;# mac layer
+	set ifq_($t)	[new $qtype]		;# interface queue
+	set ll_($t)	[new $lltype]		;# link layer
+        set ant_($t)    [new $anttype]
+
+	$ns mac-type $mactype
+	set inerr_($t) ""
+	if {$inerrproc != ""} {
+		set inerr_($t) [$inerrproc]
+	}
+	set outerr_($t) ""
+	if {$outerrproc != ""} {
+		set outerr_($t) [$outerrproc]
+	}
+	set fec_($t) ""
+	if {$fecproc != ""} {
+		set fec_($t) [$fecproc]
+	}
+
+	set namfp [$ns get-nam-traceall]
+        if {$imepflag == "ON" } {              
+		# IMEP layer
+		set imep_($t) [new Agent/IMEP [$self id]]
+		set imep $imep_($t)
+		set drpT [$self mobility-trace Drop "RTR"]
+		if { $namfp != "" } {
+			$drpT namattach $namfp
+		}
+		$imep drop-target $drpT
+		$ns at 0.[$self id] "$imep_($t) start"   ;# start beacon timer
+        }
+	#
+	# Local Variables
+	#
+	set nullAgent_ [$ns set nullAgent_]
+	set netif $netif_($t)
+	set mac $mac_($t)
+	set ifq $ifq_($t)
+	set ll $ll_($t)
+
+	set inerr $inerr_($t)
+	set outerr $outerr_($t)
+	set fec $fec_($t)
+
+	#
+	# Initialize ARP table only once.
+	#
+	if { $arptable_ == "" } {
+		set arptable_ [new ARPTable $self $mac]
+		# FOR backward compatibility sake, hack only
+		if {$imepflag != ""} {
+			set drpT [$self mobility-trace Drop "IFQ"]
+		} else {
+			set drpT [cmu-trace Drop "IFQ" $self]
+		}
+		$arptable_ drop-target $drpT
+		if { $namfp != "" } {
+			$drpT namattach $namfp
+		}
+        }
+	#
+	# Link Layer
+	#
+	$ll arptable $arptable_
+	$ll mac $mac
+	$ll down-target $ifq
+
+	if {$imepflag == "ON" } {
+		$imep recvtarget [$self entry]
+		$imep sendtarget $ll
+		$ll up-target $imep
+        } else {
+		$ll up-target [$self entry]
+	}
+
+	#
+	# Interface Queue
+	#
+	$ifq target $mac
+	$ifq set limit_ $qlen
+	if {$imepflag != ""} {
+		set drpT [$self mobility-trace Drop "IFQ"]
+	} else {
+		set drpT [cmu-trace Drop "IFQ" $self]
+        }
+	$ifq drop-target $drpT
+	if { $namfp != "" } {
+		$drpT namattach $namfp
+	}
+	if {[$ifq info class] == "Queue/XCP"} {		
+		$mac set bandwidth_ [$ll set bandwidth_]
+		$mac set delay_ [$ll set delay_]
+		$ifq set-link-capacity [$mac set bandwidth_]
+		$ifq queue-limit $qlen
+		$ifq link $ll
+		$ifq reset
+		
+	}
+
+	#
+	# Mac Layer
+	#
+	
+	$mac netif $netif
+	$mac up-target $ll
+
+	if {$outerr == "" && $fec == ""} {
+		$mac down-target $netif
+	} elseif {$outerr != "" && $fec == ""} {
+		$mac down-target $outerr
+		$outerr target $netif
+	} elseif {$outerr == "" && $fec != ""} {
+		$mac down-target $fec
+		$fec down-target $netif
+	} else {
+		$mac down-target $fec
+		$fec down-target $outerr
+		$err target $netif
+	}
+
+	set god_ [God instance]
+    if {$mactype == "Mac/802_11Ext"} {
+		$mac nodes [$god_ num_nodes]
+	}
+    if {$mactype == "Mac/802_11"} {
+		$mac nodes [$god_ num_nodes]
+	}
+	#
+	# Network Interface
+	#
+	#if {$fec == ""} {
+        #		$netif up-target $mac
+	#} else {
+        #		$netif up-target $fec
+	#	$fec up-target $mac
+	#}
+
+	$netif channel $channel
+	if {$inerr == "" && $fec == ""} {
+		$netif up-target $mac
+	} elseif {$inerr != "" && $fec == ""} {
+		$netif up-target $inerr
+		$inerr target $mac
+	} elseif {$err == "" && $fec != ""} {
+		$netif up-target $fec
+		$fec up-target $mac
+	} else {
+		$netif up-target $inerr
+		$inerr target $fec
+		$fec up-target $mac
+	}
+
+	$netif propagation $pmodel	;# Propagation Model
+	$netif node $self		;# Bind node <---> interface
+	$netif antenna $ant_($t)
+	#
+	# Physical Channel
+	#
+	$channel addif $netif
+	
+        # List-based improvement
+	# For nodes talking to multiple channels this should
+	# be called multiple times for each channel
+	$channel add-node $self		
+
+	# let topo keep handle of channel
+	$topo channel $channel
+	# ============================================================
+
+	if { [Simulator set PhyTrace_] == "ON" } {
+		#
+		# Trace Dropped Packets
+		#
+		if {$imepflag != ""} {
+			set drpPhyT [$self mobility-trace Drop "PHY"]
+		} else {
+			set drpPhyT [cmu-trace Drop "PHY" $self]
+		}
+		$netif drop-target $drpPhyT
+		if { $namfp != "" } {
+			$drpPhyT namattach $namfp
+		}
+
+		#
+		# Trace Sent Packets
+		#
+        if {$imepflag != ""} {
+            set sndPhyT [$self mobility-trace Send "PHY"]
+        } else {
+            set sndPhyT [cmu-trace Send "PHY" $self]
+        }
+        $sndPhyT target $channel
+        $netif down-target $sndPhyT
+        if { $namfp != "" } {
+            $sndPhyT namattach $namfp
+        }
+        
+	} else {
+		$netif drop-target [$ns set nullAgent_]
+	}
+
+	if { [Simulator set MacTrace_] == "ON" } {
+		#
+		# Trace RTS/CTS/ACK Packets
+		#
+		if {$imepflag != ""} {
+			set rcvT [$self mobility-trace Recv "MAC"]
+		} else {
+			set rcvT [cmu-trace Recv "MAC" $self]
+		}
+		$mac log-target $rcvT
+		if { $namfp != "" } {
+			$rcvT namattach $namfp
+		}
+		#
+		# Trace Sent Packets
+		#
+		if {$imepflag != ""} {
+			set sndT [$self mobility-trace Send "MAC"]
+		} else {
+			set sndT [cmu-trace Send "MAC" $self]
+		}
+		$sndT target [$mac down-target]
+		$mac down-target $sndT
+		if { $namfp != "" } {
+			$sndT namattach $namfp
+		}
+		#
+		# Trace Received Packets
+		#
+		if {$imepflag != ""} {
+			set rcvT [$self mobility-trace Recv "MAC"]
+		} else {
+			set rcvT [cmu-trace Recv "MAC" $self]
+		}
+		$rcvT target [$mac up-target]
+		$mac up-target $rcvT
+		if { $namfp != "" } {
+			$rcvT namattach $namfp
+		}
+		#
+		# Trace Dropped Packets
+		#
+		if {$imepflag != ""} {
+			set drpT [$self mobility-trace Drop "MAC"]
+		} else {
+			set drpT [cmu-trace Drop "MAC" $self]
+		}
+		$mac drop-target $drpT
+		if { $namfp != "" } {
+			$drpT namattach $namfp
+		}
+	} else {
+		$mac log-target [$ns set nullAgent_]
+		$mac drop-target [$ns set nullAgent_]
+	}
+
+# change wrt Mike's code
+       if { [Simulator set EotTrace_] == "ON" } {
+               #
+               # Also trace end of transmission time for packets
+               #
+
+               if {$imepflag != ""} {
+                       set eotT [$self mobility-trace EOT "MAC"]
+               } else {
+                       set eoT [cmu-trace EOT "MAC" $self]
+               }
+               $mac eot-target $eotT
+       }
+
+
+
+	# ============================================================
+
+	$self addif $netif
+}
+
+# set transmission power
+Node/MobileNode instproc setPt { val } {
+	$self instvar netif_
+	$netif_(0) setTxPower $val
+}
+
+# set receiving power
+Node/MobileNode instproc setPr { val } {
+	$self instvar netif_
+	$netif_(0) setRxPower $val
+}
+
+# set idle power -- Chalermek
+Node/MobileNode instproc setPidle { val } {
+	$self instvar netif_
+	$netif_(0) setIdlePower $val
+}
+#
+Node/MobileNode instproc setPsleep { val } {
+	$self instvar netif_
+	$netif_(0) setSleepPower $val
+}
+#
+Node/MobileNode instproc setTSleep { val } {
+	$self instvar netif_
+	$netif_(0) setSleepTime $val
+}
+#
+Node/MobileNode instproc setPtransition { val } {
+	$self instvar netif_
+	$netif_(0) setTransitionPower $val
+}
+
+Node/MobileNode instproc setTtransition { val } {
+	$self instvar netif_
+	$netif_(0) setTransitionTime $val
+}
+#
+# change wrt Mike's code
+ Node/MobileNode instproc getMac {param0} {
+       $self instvar mac_
+       return $mac_($param0)
+ }
+
+ Node/MobileNode instproc CFP { beacon_period cfp_duration } {
+       if {$mactype == "Mac/802_11"} {
+               $self instvar mac_
+               set ns_ [Simulator instance]
+               set beacon_period [$ns_ delay_parse $beacon_period]
+               set cfp_duration [$ns_ delay_parse $cfp_duration]
+               $mac_(0) cfp $beacon_period $cfp_duration
+       }
+ }
+
+
+
+Node/MobileNode instproc mobility-trace { ttype atype } {
+	set ns [Simulator instance]
+        set tracefd [$ns get-ns-traceall]
+        if { $tracefd == "" } {
+	        puts "Warning: You have not defined you tracefile yet!"
+	        puts "Please use trace-all command to define it."
+		return ""
+	}
+	set T [new CMUTrace/$ttype $atype]
+	$T newtrace [Simulator set WirelessNewTrace_]
+	$T tagged [Simulator set TaggedTrace_]
+	$T target [$ns nullagent]
+	$T attach $tracefd
+        $T set src_ [$self id]
+        $T node $self
+	return $T
+}
+
+Node/MobileNode instproc nodetrace { tracefd } {
+	#
+	# This Trace Target is used to log changes in direction
+	# and velocity for the mobile node.
+	#
+	set T [new Trace/Generic]
+	$T target [[Simulator instance] set nullAgent_]
+	$T attach $tracefd
+	$T set src_ [$self id]
+	$self log-target $T    
+}
+
+Node/MobileNode instproc agenttrace {tracefd} {
+	set ns [Simulator instance]
+	set ragent [$self set ragent_]
+	#
+	# Drop Target (always on regardless of other tracing)
+	#
+	set drpT [$self mobility-trace Drop "RTR"]
+	set namfp [$ns get-nam-traceall]
+	if { $namfp != ""} {
+		$drpT namattach $namfp
+	}
+	$ragent drop-target $drpT
+	#
+	# Log Target
+	#
+	set T [new Trace/Generic]
+	$T target [$ns set nullAgent_]
+	$T attach $tracefd
+	$T set src_ [$self id]
+	$ragent tracetarget $T
+	#
+	# XXX: let the IMEP agent use the same log target.
+	#
+	set imepflag [$ns imep-support]
+	if {$imepflag == "ON"} {
+		[$self set imep_(0)] log-target $T
+	}
+}
+
+Node/MobileNode instproc mip-call {ragent} {
+	$self instvar regagent_
+	if [info exists regagent_] {
+		$regagent_ ragent $ragent
+	}
+}
+
+Node/MobileNode instproc attach-gafpartner {} {
+
+        $self instvar gafpartner_ address_ ll_ 
+
+        set gafpartner_ [new GAFPartner]
+
+	$gafpartner_ set mask_ [AddrParams NodeMask 1]
+	$gafpartner_ set shift_ [AddrParams NodeShift 1]
+	set nodeaddr [AddrParams addr2id [$self node-addr]]
+	
+	#$gafpartner_ set addr_ [expr ( ~([AddrParams NodeMask 1] << \
+	#		[AddrParams NodeShift 1]) & $nodeaddr )]
+
+	
+	$gafpartner_ set addr_ $nodeaddr
+	$gafpartner_ set port_ 254
+
+	#puts [$gafpartner_ set addr_]
+
+        $gafpartner_ target [$self entry]
+	$ll_(0) up-target $gafpartner_
+}
+
+Node/MobileNode instproc unset-gafpartner {} {
+	$self instvar gafpartner_
+	
+	$gafpartner_ set-gafagent 0
+
+}
+
+# <zheng: add>
+Node/MobileNode instproc sscs args {
+	$self instvar mac_
+	eval $mac_(0) sscs $args
+}
+
+Node/MobileNode instproc NodeClr {arg1} {
+	$self instvar mac_
+	$mac_(0) NodeClr $arg1
+}
+
+Node/MobileNode instproc NodeLabel args {
+	$self instvar mac_
+	eval $mac_(0) NodeLabel $args
+}
+
+Node/MobileNode instproc node-down {} {
+	$self instvar mac_
+	$mac_(0) node-down
+}
+
+Node/MobileNode instproc node-up {} {
+	$self instvar mac_
+	$mac_(0) node-up
+}
+
+Node/MobileNode instproc RNType args {
+	$self instvar ragent_
+	eval $ragent_ RNType $args
+}
+# </zheng: add>
+
+Class SRNodeNew -superclass Node/MobileNode
+
+SRNodeNew instproc init args {
+	$self instvar dsr_agent_ dmux_ entry_point_ address_
+
+        set ns [Simulator instance]
+
+	eval $self next $args	;# parent class constructor
+
+	if {$dmux_ == "" } {
+		# Use the default mash and shift
+		set dmux_ [new Classifier/Port]
+	}
+	set dsr_agent_ [new Agent/DSRAgent]
+
+	# setup address (supports hier-address) for dsragent
+	$dsr_agent_ addr $address_
+	$dsr_agent_ node $self
+	if [Simulator set mobile_ip_] {
+		$dsr_agent_ port-dmux [$self set dmux_]
+	}
+	# set up IP address
+	$self addr $address_
+	
+	if { [Simulator set RouterTrace_] == "ON" } {
+		# Recv Target
+		set rcvT [$self mobility-trace Recv "RTR"]
+		set namfp [$ns get-nam-traceall]
+		if {  $namfp != "" } {
+			$rcvT namattach $namfp
+		}
+		$rcvT target $dsr_agent_
+		set entry_point_ $rcvT	
+	} else {
+		# Recv Target
+		set entry_point_ $dsr_agent_
+	}
+
+	$self set ragent_ $dsr_agent_
+	$dsr_agent_ target $dmux_
+
+	# packets to the DSR port should be dropped, since we've
+	# already handled them in the DSRAgent at the entry.
+	set nullAgent_ [$ns set nullAgent_]
+	$dmux_ install [Node set rtagent_port_] $nullAgent_
+
+	# SRNodes don't use the IP addr classifier.  The DSRAgent should
+	# be the entry point
+	$self instvar classifier_
+	set classifier_ "srnode made illegal use of classifier_"
+
+	return $self
+}
+
+SRNodeNew instproc start-dsr {} {
+	$self instvar dsr_agent_
+	$dsr_agent_ startdsr
+}
+
+SRNodeNew instproc entry {} {
+        $self instvar entry_point_
+        return $entry_point_
+}
+
+SRNodeNew instproc add-interface args {
+	eval $self next $args
+
+	$self instvar dsr_agent_ ll_ mac_ ifq_
+
+	set ns [Simulator instance]
+	$dsr_agent_ mac-addr [$mac_(0) id]
+
+	if { [Simulator set RouterTrace_] == "ON" } {
+		# Send Target
+		set sndT [$self mobility-trace Send "RTR"]
+		set namfp [$ns get-nam-traceall]
+		if {$namfp != "" } {
+			$sndT namattach $namfp
+		}
+		$sndT target $ll_(0)
+		$dsr_agent_ add-ll $sndT $ifq_(0)
+	} else {
+		# Send Target
+		$dsr_agent_ add-ll $ll_(0) $ifq_(0)
+	}
+	# setup promiscuous tap into mac layer
+	$dsr_agent_ install-tap $mac_(0)
+}
+
+SRNodeNew instproc reset args {
+	$self instvar dsr_agent_
+	eval $self next $args
+	$dsr_agent_ reset
+}
diff -urN ns-2.34.original/tcl/mobility/fsr.tcl ns-2.34/tcl/mobility/fsr.tcl
--- ns-2.34.original/tcl/mobility/fsr.tcl	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.34/tcl/mobility/fsr.tcl	2012-07-27 14:30:02.000000000 +0800
@@ -0,0 +1,123 @@
+#                          fsr.tcl  -  description
+#                             -------------------
+#    begin                : Thu Jul 29 2004
+#    copyright            : (C) 2004 by Sven Jaap
+#    email                : jaap@ibr.cs.tu-bs.de
+# ***************************************************************************/
+#
+#/***************************************************************************
+# *                                                                         *
+# *   This program is free software; you can redistribute it and/or modify  *
+# *   it under the terms of the GNU General Public License as published by  *
+# *   the Free Software Foundation; either version 2 of the License, or     *
+# *   (at your option) any later version.                                   *
+# *                                                                         *
+# ***************************************************************************/
+#
+set opt(ragent)		Agent/FSR
+set opt(pos)		NONE			;# Box or NONE
+
+
+Agent/FSR set sport_        0
+Agent/FSR set dport_        0
+
+
+if { $opt(pos) == "Box" } {
+	puts "*** FSR using Box configuration..."
+}
+
+# ======================================================================
+Agent instproc init args {
+        eval $self next $args
+}
+
+Agent/FSR instproc init args {
+        eval $self next $args
+}
+
+# ===== Get rid of the warnings in bind ================================
+
+# ======================================================================
+
+proc create-fsr-routing-agent { node id } {
+    puts "Create routing agent\n"
+    global ns_ ragent_ tracefd opt
+
+    #
+    #  Create the Routing Agent and attach it to port 255.
+    #
+    set ragent_($id) [new $opt(ragent) $id]
+    set ragent $ragent_($id)
+    $node attach $ragent 255
+
+    $ragent if-queue [$node set ifq(0)] 	;# ifq between LL and MAC
+    $ns_ at 0.$id "$ragent_($id) start-fsr"	;# start updates
+
+    #
+    # Drop Target (always on regardless of other tracing)
+    #
+    set drpT [cmu-trace Drop "RTR" $node]
+    $ragent drop-target $drpT
+
+    #
+    # Log Target
+    #
+    set T [new Trace/Generic]
+    $T target [$ns_ set nullAgent_]
+    $T attach $tracefd
+    $T set src_ $id
+    $ragent tracetarget $T
+}
+
+
+proc fsr-create-mobile-node { id args } {
+	puts "Create mobile node\n"
+	global ns ns_ chan prop topo tracefd opt node_
+	global chan prop tracefd topo opt
+
+	set node_($id) [MobileNode]
+
+	set node $node_($id)
+	$node random-motion 0		;# disable random motion
+	$node topography $topo
+
+	#
+	# This Trace Target is used to log changes in direction
+	# and velocity for the mobile node.
+	#
+	set T [new Trace/Generic]
+	$T target [$ns_ set nullAgent_]
+	$T attach $tracefd
+	$T set src_ $id
+	$node log-target $T
+
+	$node add-interface $chan $prop $opt(ll) $opt(mac)	\
+	    $opt(ifq) $opt(ifqlen) $opt(netif) $opt(ant)
+	#
+	# Create a Routing Agent for the Node
+	#
+	create-$opt(rp)-routing-agent $node $id
+
+	if { $opt(pos) == "Box" } {
+		#
+		# Box Configuration
+		#
+		set spacing 200
+		set maxrow 3
+		set col [expr ($id - 1) % $maxrow]
+		set row [expr ($id - 1) / $maxrow]
+		$node set X_ [expr $col * $spacing]
+		$node set Y_ [expr $row * $spacing]
+		$node set Z_ 0.0
+		$node set speed_ 0.0
+
+		$ns_ at 0.0 "$node_($id) start"
+
+	} elseif { $opt(pos) == "Random" }{
+
+		$node random-motion 1
+
+		$ns_ at 0.0 "$node_($id) start"
+
+	}
+}
